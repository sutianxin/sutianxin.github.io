<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM学习笔记（二）-垃圾回收 | Arno</title><meta name="keywords" content="☕Java,💻后端学习"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="三、垃圾回收3.1、如何判断对象可以回收1、引用计数法 定义   此种算法会在每一个对象上记录这个对象被引用的次数，只要有任何一个对象引用了次对象，这个对象的计数器就+1，取消对这个对象的引用时，计数器就-1，在分配对象时会将计数器的值置为1。 任何一个时刻，如果该对象的计数器为0，那么这个对象就是可以回收的。   缺点   计数器值增减频繁 实现繁琐，更新引用时很容易导致内存泄露。 循环引用无法"><meta property="og:type" content="article"><meta property="og:title" content="JVM学习笔记（二）-垃圾回收"><meta property="og:url" content="https://sutianxin.top/posts/1529856079.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="三、垃圾回收3.1、如何判断对象可以回收1、引用计数法 定义   此种算法会在每一个对象上记录这个对象被引用的次数，只要有任何一个对象引用了次对象，这个对象的计数器就+1，取消对这个对象的引用时，计数器就-1，在分配对象时会将计数器的值置为1。 任何一个时刻，如果该对象的计数器为0，那么这个对象就是可以回收的。   缺点   计数器值增减频繁 实现繁琐，更新引用时很容易导致内存泄露。 循环引用无法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/blogImage/raw/master/20210529214344.jpg"><meta property="article:published_time" content="2021-05-29T13:37:15.000Z"><meta property="article:modified_time" content="2021-08-25T14:35:14.438Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="☕Java"><meta property="article:tag" content="💻后端学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/blogImage/raw/master/20210529214344.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/1529856079"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-08-25 22:35:14"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,a={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(a)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/blogImage/raw/master/20210529214344.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM学习笔记（二）-垃圾回收</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-29T13:37:15.000Z" title="发表于 2021-05-29 21:37:15">2021-05-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-25T14:35:14.438Z" title="更新于 2021-08-25 22:35:14">2021-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.6k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="3-1、如何判断对象可以回收"><a href="#3-1、如何判断对象可以回收" class="headerlink" title="3.1、如何判断对象可以回收"></a>3.1、如何判断对象可以回收</h2><h3 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h3><ul><li>定义</li></ul><blockquote><p>此种算法会在每一个对象上<strong>记录这个对象被引用的次数</strong>，只要有任何一个对象引用了次对象，这个对象的计数器就+1，取消对这个对象的引用时，计数器就-1，<strong>在分配对象时会将计数器的值置为1</strong>。</p><p>任何一个时刻，如果该对象的计数器为0，那么这个对象就是可以回收的。</p></blockquote><ul><li>缺点</li></ul><ol><li>计数器值增减频繁</li><li>实现繁琐，更新引用时很容易导致内存泄露。</li><li>循环引用无法回收(最重要的缺点)，两个已经失去作用、但互相引用的对象无法被<strong>引用计数法</strong>判断为可回收垃圾。</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521172331.png" alt="image-20210521172324702"></p><ul><li>注意：JVM 没有使用<strong>引用计数法</strong></li></ul><h3 id="2、可达性分析方法"><a href="#2、可达性分析方法" class="headerlink" title="2、可达性分析方法"></a>2、可达性分析方法</h3><ul><li>定义</li></ul><blockquote><p>这个算法的基本思想是通过一系列称为 “<strong>GC Roots</strong>“（肯定不能被当为垃圾回收的对象） 的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象可以被当成垃圾进行回收。</p><p><code>JVM</code> 中的垃圾回收器采用<strong>可达性分析算法</strong>来探索所有存活的对象。</p></blockquote><ul><li>哪些对象可以作为 <code>GC Root</code> ？</li></ul><ol><li><p>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</p></li><li><p>方法区中的类静态属性引用的对象和常量引用的对象。</p></li><li><p>本地方法栈中JNI(Native方法)引用的对象。</p></li><li><p>正在加锁的对象</p></li></ol><h3 id="3、五种引用"><a href="#3、五种引用" class="headerlink" title="3、五种引用"></a>3、五种引用</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521193931.png" alt="image-20210521193931546"></p><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521190911.png" alt="image-20210521190911142"></p><blockquote><p>Java 中常见的五种引用分别为：强引用、弱引用、虚引用、软引用和终结器引用</p></blockquote><ul><li>强引用：不回收</li></ul><blockquote><p>如果一个对象具有强引用，那就类似于<strong>必不可少的</strong>物品，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，使程序异常终止，也不回收这种对象。</p><p>Java 中绝大部分引用都是强引用。</p></blockquote><ul><li>软引用：内存不足即回收</li></ul><blockquote><p>软引用是用来描述一些<strong>有用但并不是必需</strong>的对象，在Java中用 <code>java.lang.ref.SoftReference</code> 类来表示。</p><p>对于只有软引用的对象来说：当系统内存充足时它不会被回收，当系统内存不足时它才会被回收。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p></blockquote><ul><li>弱引用：发现即回收</li></ul><blockquote><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>弱引用需要用<code>java.lang.ref.WeakReference</code>类来实现，它比软引用的生存期更短。</p><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，<strong>不管 JVM 的内存空间是否足够</strong>，都会回收该对象占用的内存。</p><p><code>ThreadLocal</code> 中的 <code>ThreadLocalMap</code> 的 <code>Entry</code> 就继承了 <code>WeakReference</code></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521192343.png" alt="image-20210521192342894"></p><ul><li>虚引用：对象回收跟踪</li></ul><blockquote><p>虚引用也称为<strong>幽灵引用</strong>或者<strong>幻影引用</strong>，它是最弱的一种引用关系。</p><p>虚引用，顾名思义，就是形同虚设，与其他几种引用都不太一样，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p><p>虚引用需要<code>java.lang.ref.PhantomReference</code> 来实现。</p><p>如果一个对象<strong>仅持有虚引用</strong>，那么它就和<strong>没有任何引用一样</strong>，<strong>在任何时候都可能被垃圾回收器回收</strong>，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列（<code>RefenenceQueue</code>）联合使用。</p><p>虚引用的主要作用是跟踪对象垃圾回收的状态。仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。</p></blockquote><ul><li>终结器引用</li></ul><blockquote><p>它用以实现对象的 <code>finalize</code> 方法，也可以称为终结器引用。无需手动编码， 其内部配合引用队列使用。</p></blockquote><h2 id="3-2、垃圾回收算法-–-标记清除"><a href="#3-2、垃圾回收算法-–-标记清除" class="headerlink" title="3.2、垃圾回收算法 – 标记清除"></a>3.2、垃圾回收算法 – 标记清除</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p>标记清除算法是一种分两阶段对对象进行垃圾回收的算法。</p><p>第一阶段：标记。从根节点（GC Root）出发遍历对象，对访问过的对象打上标记（一般是在对象的 Header 中记录），证明该节点为可达，并非可以回收的垃圾节点</p><p>第二阶段：清除。对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521201558.png" alt="image-20210521201558262"></p><h3 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h3><ul><li>回收后<strong>会产生大量不连续的内存空间</strong>，即内存碎片。</li></ul><blockquote><p>由于Java在分配内存时通常是按连续内存分配，那么当碎片空间不足以分配给新的对象时，就造成了内存浪费。</p></blockquote><ul><li><strong>进行垃圾回收时，应用需要挂起</strong></li><li><strong>标记和清除的效率不高</strong>，尤其是要扫描的对象比较多的时候</li></ul><h3 id="3、优点"><a href="#3、优点" class="headerlink" title="3、优点"></a>3、优点</h3><ul><li>可以解决循环引用的问题</li><li>必要时才回收(内存不足时)</li></ul><h2 id="3-3、垃圾回收算法-–-标记整理"><a href="#3-3、垃圾回收算法-–-标记整理" class="headerlink" title="3.3、垃圾回收算法 – 标记整理"></a>3.3、垃圾回收算法 – 标记整理</h2><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521204010.png" alt="image-20210521204010481"></p><h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p>标记整理算法和标记清除算法一样分为两个阶段，即先标记后整理。由于标记清除算法的一个缺点就是会产生大量内存碎片，而标记整理算法会对内存空间进行一次整理，解决内存碎片化问题。</p></blockquote><ul><li>标记。从根节点（GC Root）出发遍历对象，对访问过的对象打上标记（一般是在对象的 Header 中记录），证明该节点为可达，并非可以回收的垃圾节点</li><li>整理。在遍历结束后， <strong>对于标记过的对象，把它们从内存开始的区域按顺序依次摆好，整整齐齐的， 中间没有任何的缝隙</strong>。在摆放完最后一个标记过的对象后， 把之后的内存区域直接回收掉. (这里最耗时的步骤是，当你移动一个对象的内存位置时，你需要让所有之前依赖这个对象的对象更新一下引用地址信息，这样才不会在移动之后出错.)</li></ul><h3 id="2、优点"><a href="#2、优点" class="headerlink" title="2、优点"></a>2、优点</h3><ul><li>消除了标记清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h3 id="3、缺点"><a href="#3、缺点" class="headerlink" title="3、缺点"></a>3、缺点</h3><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li><li>移动过程中，需要全程暂停用户应用程序。</li></ul><h2 id="3-4、垃圾回收算法-–-复制"><a href="#3-4、垃圾回收算法-–-复制" class="headerlink" title="3.4、垃圾回收算法 – 复制"></a>3.4、垃圾回收算法 – 复制</h2><h3 id="1、定义-2"><a href="#1、定义-2" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p><strong>复制算法将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的</strong>。</p><p>当有效内存空间耗尽时，<code>JVM</code> 将暂停程序运行，开启复制算法 <code>GC</code> 线程。<strong>接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址</strong>。</p><p>此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。</p></blockquote><ul><li>垃圾清理前（1、4 为垃圾）</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521231513.png" alt="image-20210521231513342"></p><ul><li>将所有存活对象复制到原来的空闲区间中，并按照内存地址排序，更新引用，然后清除原来活动区间（现空闲区间）中的所有垃圾对象（1、4）</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521231610.png" alt="image-20210521231610100"></p><h3 id="2、优点-1"><a href="#2、优点-1" class="headerlink" title="2、优点"></a>2、优点</h3><ul><li>不产生内存碎片问题，能保持对象的完整性。</li><li>可实现高速分配</li></ul><blockquote><p>GC 复制算法不使用空闲链表。这是因为分块是一个连续的内存空间。比起 GC 标记 - 清除算法和引用计数法等使用空闲链表的分配，GC 复制算法明显快得多。</p></blockquote><h3 id="3、缺点-1"><a href="#3、缺点-1" class="headerlink" title="3、缺点"></a>3、缺点</h3><ul><li><strong>复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视</strong>。</li></ul><blockquote><p>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。</p></blockquote><ul><li>堆使用效率低下，会浪费 50% 的内存</li></ul><blockquote><p>GC 复制算法把堆二等分，通常只能利用其中的一半来安排对象。也就是说，只有一半 堆能被使用。相比其他能使用整个堆的 GC 算法而言，可以说这是 GC 复制算法的一个重大的缺陷。</p><p>通过搭配使用 GC 复制算法和 GC 标记 - 清除算法可以改善这个缺点</p><p><strong>复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费</strong>。</p></blockquote><h2 id="3-5、三种垃圾回收算法对比"><a href="#3-5、三种垃圾回收算法对比" class="headerlink" title="3.5、三种垃圾回收算法对比"></a>3.5、三种垃圾回收算法对比</h2><h3 id="1、内存整齐度"><a href="#1、内存整齐度" class="headerlink" title="1、内存整齐度"></a>1、内存整齐度</h3><p>复制算法 = 标记整理算法 &gt; 标记清理算法</p><h3 id="2、内存利用率"><a href="#2、内存利用率" class="headerlink" title="2、内存利用率"></a>2、内存利用率</h3><p>标记整理算法 = 复制算法 &gt; 标记清理算法</p><h2 id="3-6、分代垃圾回收"><a href="#3-6、分代垃圾回收" class="headerlink" title="3.6、分代垃圾回收"></a>3.6、分代垃圾回收</h2><h3 id="1、分代说明"><a href="#1、分代说明" class="headerlink" title="1、分代说明"></a>1、分代说明</h3><blockquote><p>堆内存是JAVA虚拟机所管理的内存最大的一块，Java堆被所有线程共享，几乎所有的对象实例都是在堆中分配内存，因此<strong>Java的堆是垃圾回收的主要区域</strong>。</p><p><strong>JVM的内存分代讲的就是堆内存的分代</strong>，为了更加高效的回收垃圾，将内存划分为了多个generation（代）。</p><p>JVM堆可以划分为新生代、老年代、永久代（JDK1.7），在JDK1.8中，永久代被元空间（<code>Metaspace</code>）所代替，并且元空间已经不在堆中了。</p></blockquote><h3 id="2、永久代和元数据的区别"><a href="#2、永久代和元数据的区别" class="headerlink" title="2、永久代和元数据的区别"></a>2、永久代和元数据的区别</h3><blockquote><p>永久代是 <code>HotSpot</code> 虚拟机特有的概念，并且在JDK1.8之后，永久代就彻底消失了。</p><p>永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，并且永久代必须指定大小限制，因此就会导致性能问题和内存溢出的问题。永久代会给GC带来不必要的复杂性。</p><p>元空间的本质和永久代类似，但是<strong>元空间并不在堆中，而是直接使用了本地内存</strong>，元数据可以设置限制，也可以不设置，它的大小仅受本地内存限制。</p></blockquote><h3 id="3、新生代和老年代"><a href="#3、新生代和老年代" class="headerlink" title="3、新生代和老年代"></a>3、新生代和老年代</h3><blockquote><p>新生代和老年代是垃圾回收最主要的区域。</p><p>一般将更有价值，需要长时间存活的对象放在老年代中，用完则丢弃的对象放在新生代中。</p><p>老年代的垃圾回收触发频率较低，新生代频繁触发垃圾回收</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522131120.png" alt="image-20210522131113329"></p><blockquote><p>新生代和老年代都在堆内存中，新生代和老年代所占的默认比例为1 ： 2，其中新生代又由一个伊甸（Eden）区和两个幸存者（Survivor）区组成，三个区的默认比例为8：1：1。</p></blockquote><ul><li>新生代</li></ul><blockquote><p><code>YoungGC</code> 对应于新生代，<strong>第一次YGC</strong>只回收 <code>eden</code> 区域，回收后大多数（百分之九十八左右）的对象会被回收，活着的对象通过复制算法进入Survivor0（后续用S0和S1代替）。<strong>再次YGC后</strong>，<code>eden+S0</code>中活着的对象进入S1。<strong>再次YGC</strong>，<code>eden+S1</code>中活着的对象进入到S0。依次循环。</p><p>在将 <code>eden</code> 区与其中一个survivor区作为 From 区时，需要将另外一个survivor区作为 To 区，即保证 To 区为空。</p></blockquote><ul><li><p>当一个<strong>对象的年龄</strong>（经历的YGC次数）足够时（传统的垃圾回收器一般是15，CMS垃圾回收器是6），<strong>进入老年代</strong>。</p></li><li><p>如果遇到一个<strong>对象S区装不下</strong>，则直接进入老年代。</p></li><li><p>老年代</p></li></ul><blockquote><p>老年代的垃圾回收或称叫做 <code>FullGC</code>，当老年代空间不足时，就会触发 <code>FullGC</code>；另外，如果元空间区域的内存达到了所设定的阈值<code>-XX:MetaspaceSize=</code>，也会触发<code>FullGC</code>。</p><p><code>FullGC</code> 采用的是<strong>标记整理算法</strong>，这个算法的效率是比较低的，因为它要标记出或者的对象，然后移到内存的一侧，最后再清空区域外的内存。这个过程会十分消耗时间。</p><p>因此优化 <code>JVM</code> 最重要的一点就是优化 <code>FullGC</code>，尽可能的不要执行 <code>FullGC</code>。</p></blockquote><h3 id="4、对象转移过程"><a href="#4、对象转移过程" class="headerlink" title="4、对象转移过程"></a>4、对象转移过程</h3><ul><li>当我们创建一个新对象后，这个新对象会默认占用新生代中伊甸（Eden）区的一块空间</li><li>当伊甸区空间不够时，此时会触发一次 <strong>Minor GC（Young GC）</strong>，第一次 <strong>Minor GC</strong> 只针对伊甸区，并将第一块幸存者（survivor0）区作为复制算法的 To 区，然后将存活下来进入幸存区的对象的寿命 + 1。</li><li>此时由于伊甸区已经被清空，所以后面新创建的对象可以继续存放在伊甸区中，在后面的复制算法中，会将伊甸区和上面的第一块幸存者（survivor0）区作为 From 区，然后将另外一块幸存者（survivor1）区作为 To 区，此时需要对幸存的对象的寿命 + 1</li><li>新生代中的对象不会永远呆在新生代中，当新生代中对象的寿命超过一个阈值（15）时，这个对象会被转移到老年代。GC分代年龄存储在对象的 header 中</li><li>如果遇到一个<strong>对象 Survivor 区装不下</strong>，则直接进入老年代。</li><li>当新生代空间实在不足或老年代空间不足时，会使用 <code>Full GC</code> 对新生代与老年代进行一次力度较大的垃圾回收。</li><li><code>Minor GC</code> 会引发 stop the world，即暂停其他用户线程，直到垃圾回收线程完成工作后继续运行其他用户线程，<code>Minor GC</code> 使用的时间较短</li><li>对象寿命的阈值是15，超过这个阈值，新生代对象会被转移到老年代中，这是由于对象头中，寿命占 4 bit，而4 bit 最大的值即为15，不同垃圾回收器中寿命阈值不同。</li><li>Full GC 也会引发 stop the world，但占用的时间会更长。</li></ul><h3 id="5、相关-VM-参数"><a href="#5、相关-VM-参数" class="headerlink" title="5、相关 VM 参数"></a>5、相关 VM 参数</h3><table><thead><tr><th align="center">含义</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">堆初始大小</td><td align="center"><code>-Xms</code></td></tr><tr><td align="center">堆最大大小</td><td align="center"><code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></td></tr><tr><td align="center">新生代大小</td><td align="center"><code>-Xmn</code> 或 <code>(-XX:NewSize=size + -XX:MaxNewSize=size)</code></td></tr><tr><td align="center">幸存者比例（动态）</td><td align="center"><code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></td></tr><tr><td align="center">幸存者比例</td><td align="center"><code>-XX:SurvivorRatio=ratio</code></td></tr><tr><td align="center">晋升阈值</td><td align="center"><code>-XX:MaxTenuringThreshold=threshold</code></td></tr><tr><td align="center">晋升详情</td><td align="center"><code>-XX:+PrintTenuringDistribution</code></td></tr><tr><td align="center">GC 详情</td><td align="center"><code>-XX:+PrintGCDetails -verbose:gc</code></td></tr><tr><td align="center"><code>Full GC</code> 前 <code>Minor GC</code></td><td align="center"><code>-XX:+ScavengeBeforeFullGC</code></td></tr></tbody></table><h3 id="6、分析以下参数和日志"><a href="#6、分析以下参数和日志" class="headerlink" title="6、分析以下参数和日志"></a>6、分析以下参数和日志</h3><blockquote><p>在参数中，我们指定堆初始大小和堆最大大小为 20M，新生代大小为 10M ，所以老年代大小为 10M （20 - 10）</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522143436.png" alt="image-20210522143436418"></p><ul><li>在截图中，显示了堆和元空间的数据</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522143719.png" alt="image-20210522143718997"></p><blockquote><p>在新生代中，内存空间被划分为3块，其中伊甸区占 4/5 ，其余两块幸存区各占 1/10 ，由于一块幸存者区要作为复制算法的 To 区，所以 10M 内存中有 1M 必须为空，故可用内存只有 9M.</p><p>total 为可用的内存大小，used 表示已经使用的大小</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522144237.png" alt="image-20210522144237324"></p><blockquote><p>从上面日志中可以看到新生代中内存划分和分配比例。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522144500.png" alt="image-20210522144500450"></p><blockquote><p>上面日志打印了老年代的内存占用信息，由于堆初始大小、堆最大大小和新生代内存大小都已经被指定，所以老年代内存大小也被指定。</p></blockquote><h3 id="7、大对象直接晋升至老年代"><a href="#7、大对象直接晋升至老年代" class="headerlink" title="7、大对象直接晋升至老年代"></a>7、大对象直接晋升至老年代</h3><blockquote><p>对于无法放入新生代，但可以放入老年代的大对象来说，JVM 会直接将该对象放入老年代，不会触发 GC</p></blockquote><ul><li>放置大对象前</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522143436.png" alt="image-20210522143436418"></p><ul><li>往堆中直接塞一个 8M 的大对象，查看日志</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522145752.png" alt="image-20210522145752735"></p><blockquote><p>可以看到，大对象直接被塞进了老年代，同时没有触发 GC</p></blockquote><ul><li><strong>一个线程的OOM不会导致进程失效</strong></li></ul><h2 id="3-7、垃圾回收器"><a href="#3-7、垃圾回收器" class="headerlink" title="3.7、垃圾回收器"></a>3.7、垃圾回收器</h2><h3 id="1、串行（Serial）"><a href="#1、串行（Serial）" class="headerlink" title="1、串行（Serial）"></a>1、串行（Serial）</h3><ul><li>简介</li></ul><blockquote><p>Serial 是一类<strong>用于新生代</strong>的<strong>单线程收集器</strong>，采用<strong>复制算法</strong>进行垃圾收集。Serial进行垃圾收集时，不仅只用一条单线程执行垃圾收集工作，<strong>它还在收集的同时，所用的用户必须暂停</strong>。</p><p>适用于堆内存较小的个人电脑</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522153952.png" alt="image-20210522153952355"></p><blockquote><p>从上图可知当应用程序进行到一个安全的节点的时候，所有的线程全都暂停，等到GC完成后，应用程序线程继续执行。</p></blockquote><ul><li>优点</li></ul><blockquote><p>简单高效，由于采用的是单线程的方法，因此与其他类型的收集器相比，对单个 <code>cpu</code> 来说没有了上下文之间的的切换，效率比较高。</p></blockquote><ul><li>缺点</li></ul><blockquote><p>会在用户不知道的情况下停止所有工作线程，用户体验感极差，令人难以接受。</p></blockquote><ul><li>开启命令</li></ul><blockquote><p>其中 Serial 工作在新生代，使用的算法是复制算法</p><p><code>SerialOld</code> 工作在老年代，使用的是标记整理算法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserSerialGC = Serial + SerialOld</span><br></pre></td></tr></table></figure><h3 id="2、吞吐量优先"><a href="#2、吞吐量优先" class="headerlink" title="2、吞吐量优先"></a>2、吞吐量优先</h3><blockquote><p>使用于多线程、堆内存较大、拥有多核 CPU 的环境（服务器）</p></blockquote><ul><li>简介</li></ul><blockquote><p>Parallel Scavenge 是一款用于新生代的多线程收集器，采用复制算法。与 <code>ParNew</code> 的不同之处在于 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量，而 <code>ParNew</code> 收集器关注点在于尽可能的缩短垃圾收集时用户线程的停顿时间。</p><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值， 即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522152437.png" alt="image-20210522152437296"></p><ul><li>优点</li></ul><blockquote><p>追求高吞吐量，高效利用CPU，是吞吐量优先，且能进行精确控制。</p></blockquote><ul><li>开启命令</li></ul><blockquote><p>JDK 8 默认开启，<code>ParallelOldGC</code> 工作在老年代，使用 <strong>标记整理算法</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC ~ -XX:++UseParallelOldGC</span><br></pre></td></tr></table></figure><h3 id="3、响应时间优先"><a href="#3、响应时间优先" class="headerlink" title="3、响应时间优先"></a>3、响应时间优先</h3><blockquote><p>使用于多线程、堆内存较大、拥有多核 CPU 的环境（服务器）</p></blockquote><ul><li>简介</li></ul><blockquote><p><code>ParNew</code> 收集器其实就是Serial的一个多线程版本，其在单核 <code>cpu</code> 上的表现并不会比 <code>Serail</code> 收集器更好，在多核机器上，其默认开启的收集线程数与 <code>cpu</code> 数量相等。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522152620.png" alt="image-20210522152620792"></p><ul><li>优点</li></ul><blockquote><p>随着 <code>cpu</code> 的有效利用，对于GC时系统资源的有效利用有好处。</p></blockquote><ul><li>缺点</li></ul><blockquote><p>会在用户不知道的情况下停止所有工作线程</p></blockquote><h2 id="3-8、垃圾回收器-–-G1"><a href="#3-8、垃圾回收器-–-G1" class="headerlink" title="3.8、垃圾回收器 – G1"></a>3.8、垃圾回收器 – G1</h2><blockquote><p>这块垃圾回收器的特点是 <strong>区域化分代式</strong></p></blockquote><h3 id="1、定义-3"><a href="#1、定义-3" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p>G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为 <code>HotSpot</code> 重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，<strong>G1也是关注最小时延的垃圾回收器</strong>。</p><p>G1最大的特点是<strong>引入分区的思路，弱化了分代的概念</strong>，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。</p><p>G1 是一个并行回收器，它将堆内存分割为很多个不相关的区域（Region），使用不同的 Region 来表示 Eden 、 幸存者 0 区 、 幸存者 1 区和老年代等。</p></blockquote><ul><li>2004 论文发布</li><li>2009 JDK 6 体验</li><li>2012 JDK 7 官方支持</li><li>2017 JDK 9 默认</li></ul><blockquote><p>官方给 G1 设定的目标是<strong>在低延迟可控的情况下获得尽可能高的吞吐量</strong>。</p><p>G1 GC 有计划地<strong>避免在整个 Java 堆中进行全区域的垃圾回收</strong>，G1 <strong>跟踪各个 Region 里面的垃圾堆积的价值大小</strong>（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个 <strong>优先列表</strong>，每次<strong>根据允许的收集时间，优先回收价值最大的 Region</strong></p></blockquote><h3 id="2、使用场景和相关-JVM-参数"><a href="#2、使用场景和相关-JVM-参数" class="headerlink" title="2、使用场景和相关 JVM 参数"></a>2、使用场景和相关 JVM 参数</h3><ul><li><p>同时注重吞吐量和低延迟，默认的暂停目标是 200 <code>ms</code></p></li><li><p>适合<strong>超大堆内存</strong>，G1 会<strong>将堆划分为多个大小相等的 Region</strong></p></li><li><p>整体上是标记 + 整理算法，两个区域间是复制算法</p></li><li><p>开启方式</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><ul><li>指定 G1 区域的大小</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:G1HeapRegionSize=size</span><br></pre></td></tr></table></figure><h3 id="3、G1-回收器的特点"><a href="#3、G1-回收器的特点" class="headerlink" title="3、G1 回收器的特点"></a>3、G1 回收器的特点</h3><blockquote><p>与其他的 GC 收集器相比， G1 使用了全新的分区算法，其特点如下</p></blockquote><ul><li>并发与并行</li></ul><ol><li>并行性</li></ol><blockquote><p>G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核 CPU 的计算能力。<strong>此时用户线程需要进行 STW</strong></p></blockquote><ol start="2"><li>并发性：</li></ol><blockquote><p>G1 <strong>拥有与应用程序交替执行的能力</strong>，部分工作可以与应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</p></blockquote><ul><li>分代收集</li></ul><ol><li><p>从分代上看，<strong>G1 依然属于分代型垃圾回收器</strong>，它会区分年轻代与老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它<strong>不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量</strong></p></li><li><p>将<strong>堆空间划分为若干个区域（Region）</strong>，这些区域中包含了逻辑上的年轻代和老年代。</p></li><li><p>G1 <strong>同时兼顾老年代和年轻代</strong></p></li></ol><ul><li>空间整合</li></ul><blockquote><p>G1 的垃圾回收以 Region 作为基本单位，Region 之间是复制算法，但<strong>整体上实际可以看作 标记 - 压缩 算法</strong>，这两种算法都可以避免内存碎片</p><p>这种特点有利于程序长时间运行，分配大对象时不会因为无法找到连续空间而提前触发下一次 GC ，尤其是当 Java 堆非常大时，G1 的优势更加明显</p></blockquote><h3 id="4、分区-Region"><a href="#4、分区-Region" class="headerlink" title="4、分区 Region"></a>4、分区 Region</h3><blockquote><p><strong>化整为零</strong>，将之前物理连续的年轻代、老年代打散开来，分为一块块大小相同，但在物理上不连续的分区，对于一块 Region，它扮演的角色是单一的，不能半块是 Eden、半块是老年代</p><p>但 Region 的角色是可以改变的，当一块 Eden 区被清理干净后，它可以变为其他区域。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210825214306.png" alt="image-20210825214259444"></p><ul><li>humongous区</li></ul><blockquote><p>主要用于存储大对象，如果对象超过 1.5 个 Region，那么就放到 H 区</p><p>如果一个 H 区无法装入大对象，那么 G1 会寻找连续的 H 区来存储，为了能找到连续的 H 区，有时候不得不启动 FULL GC。</p><p>G1 的大多数行为都把 H 区看为老年代的一部分。</p></blockquote><h3 id="5、G1-垃圾回收阶段"><a href="#5、G1-垃圾回收阶段" class="headerlink" title="5、G1 垃圾回收阶段"></a>5、G1 垃圾回收阶段</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210529214306.png" alt="image-20210522192817910"></p><blockquote><p>G1 垃圾回收器的回收工作可以分为三个阶段，分别为</p></blockquote><ul><li><code>Young Collection</code> ：对新生代的垃圾进行收集</li><li><code>Young Collection + Concurrent Mark</code>： 对新生代垃圾进行收集，同时对老年代添加并发标记</li><li><code>Mixed Collection</code> ：混合垃圾收集（对新生代、新生区、老年代都进行一次规模较大的垃圾收集）</li></ul><blockquote><p>以上三个过程循环进行</p><p>如果需要，<strong>单线程、独占式、高强度的 Full GC 依然会存在</strong>，它针对 GC 的评估失败提供了一种失败保护机制，即<strong>强力回收</strong></p></blockquote><h3 id="6、Young-Collection"><a href="#6、Young-Collection" class="headerlink" title="6、Young Collection"></a>6、<code>Young Collection</code></h3><blockquote><p>会产生 <code>Stop The World</code> ，阻塞其他用户线程</p><p>注意，只有当 Eden 区空间不够的时候才会触发 Young GC ，幸存区空间不够时不触发</p></blockquote><ul><li>新创建的对象放入伊甸（Eden）区中，在新生区的伊甸区被占满后，此时会触发一次 <code>Young Collection</code></li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522193725.png" alt="image-20210522193725471"></p><ul><li><code>Young Collection</code> 会将伊甸区中的存活对象拷贝到幸存区中。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522194038.png" alt="image-20210522194038070"></p><ul><li>在幸存区空间不足或者幸存区对象寿命达到阈值后，此时幸存区中的一部分对象会被放入老年代，一部分会被当成垃圾回收，另一部分会放入其他的幸存区中。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522201635.png" alt="image-20210522201635379"></p><h3 id="7、Young-Collection-CM"><a href="#7、Young-Collection-CM" class="headerlink" title="7、Young Collection + CM"></a>7、<code>Young Collection + CM</code></h3><ul><li>在 <code>Young GC</code> 时会进行 <code>GC Root</code> 的初始标记</li><li>老年待占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW ），由下面的 <code>JVM</code> 参数决定</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent=percent（默认为 45%）</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522204057.png" alt="image-20210522204057591"></p><h3 id="8、Mixed-Collection"><a href="#8、Mixed-Collection" class="headerlink" title="8、Mixed Collection"></a>8、<code>Mixed Collection</code></h3><blockquote><p>会对 E 、 S 、O 进行全部垃圾回收</p></blockquote><ul><li>最终标记（Remark）会产生 STW</li><li>拷贝存活（Evacuation）会产生 STW</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522204500.png" alt="image-20210522204500487"></p><blockquote><p>由于我们会指定一个 <code>GC</code> 最大暂停时间，在这个事件内，G1 可能无法对所有老年代垃圾进行回收，所以它会有选择地回收一部分老年代的垃圾（回收价值最大的垃圾）进行回收</p><p>优先回收垃圾最多的区域</p></blockquote><h3 id="9、Full-GC-和-Minor-Young-GC"><a href="#9、Full-GC-和-Minor-Young-GC" class="headerlink" title="9、Full GC 和 Minor(Young) GC"></a>9、Full GC 和 Minor(Young) GC</h3><ul><li><p>Serial GC</p><ul><li>新生代内存不足发生的垃圾收集 - <code>Minor GC</code></li><li>老年代内存不足发生的垃圾收集 - <code>Full GC</code></li></ul></li><li><p>Parallel GC</p><ul><li>新生代内存不足发生的垃圾收集 - <code>Minor GC</code></li><li>老年代内存不足发生的垃圾收集 - <code>Full GC</code></li></ul></li><li><p>CMS</p><ul><li>新生代内存不足发生的垃圾收集 - <code>Minor GC</code></li><li>老年代内存不足</li></ul></li><li><p>G1</p><ul><li>新生代内存不足发生的垃圾收集 - <code>Minor GC</code></li><li>老年代内存不足</li></ul><blockquote><p>在 G1 进行并发标记、混合收集（且垃圾清除的速度大于垃圾产生速度）时，不直接称为 Full GC，此时仍然处于并发垃圾收集的阶段；</p><p>只有垃圾回收的速度更不上垃圾产生的速度时，这个时候并发收集失败，这个时候退化为一个串行（Serial）收集，此时称为 Full GC</p></blockquote></li></ul><h3 id="10、JDK-8-字符串去重"><a href="#10、JDK-8-字符串去重" class="headerlink" title="10、JDK 8 字符串去重"></a>10、JDK 8 字符串去重</h3><ul><li>优点：节省大量内存</li><li>缺点：略微多占用了 CPU 时间，新生代回收时间略微增加</li></ul><blockquote><p>开启参数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseStringDeduplication # 默认打开</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[] &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[] &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>将所有新分配的字符串放入一个队列</li><li>当新生代回收时，G1 并发检查是否有字符串重复</li><li>如果它们值一样，让他们引用同一个 char[]</li><li>注意，与 <code>String.intern()</code> 不一样<ul><li><code>String.intern()</code> 关注的是字符串对象</li><li>字符串去重关注的是 char[]</li><li>在 <code>JVM</code> 内部，使用了不同的字符串表</li></ul></li></ul><h3 id="11、JDK-8-并发标记类卸载"><a href="#11、JDK-8-并发标记类卸载" class="headerlink" title="11、JDK 8 并发标记类卸载"></a>11、JDK 8 并发标记类卸载</h3><blockquote><p>所有对象都经过并发标记后，就能直到哪些类不再被使用，当一个类加载器的所有类都不再使用后，则卸载它所加载的所有类</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ClassUnloadingWithConcurrentMark #默认启用</span><br></pre></td></tr></table></figure><h3 id="12、巨型对象"><a href="#12、巨型对象" class="headerlink" title="12、巨型对象"></a>12、巨型对象</h3><ul><li>一个对象大于 <code>Region</code> 的一半时，称为巨型对象。</li><li>G1 不会对巨型对象进行拷贝，回收时优先考虑巨型对象。</li><li>G1 会跟踪老年代所有 <code>incoming</code> 引用，这样老年代 <code>incoming</code> 引用为 0 的巨型对象就可以在新生代垃圾回收时被处理掉。</li></ul><blockquote><p>巨型对象存放在 H 区中。</p></blockquote><h3 id="12、Remembered-Set"><a href="#12、Remembered-Set" class="headerlink" title="12、Remembered Set"></a>12、Remembered Set</h3><blockquote><p>与 CMS 相比，G1 还需要额外消耗一部分内存（大约是 10 % - 20 %）用于自身运行，这一部分额外消耗的内存中就包含了 Remembered Set</p></blockquote><ul><li>Remembered Set 的出现是为了解决一个对象被不同区域引用的问题</li></ul><blockquote><p>Region 不可能是独立的，一个 Region 中的对象可能被任意其他 Region 引用，如果这个对象被其他 Region 引用，那么在判断此对象是否存活时，我们可能需要对其他 Region 进行扫描（甚至是整个堆）</p><p>如果在回收新生代垃圾时，这个 Region 中的对象被老年代 Region 所引用，此时我们将必须扫描老年代 Region ，此时会降低 Minor GC 的效率</p></blockquote><ul><li>G1 使用了 <strong>Remembered Set</strong> 来<strong>避免</strong>进行<strong>全局扫描</strong></li></ul><blockquote><p>对于<strong>每个 Region 都有对应的一个 Remembered Set</strong></p></blockquote><ul><li>在每次进行引用类型数据的写操作时，都会产生一个 Write Barrier 来暂停中断操作</li></ul><blockquote><p>然后<strong>检查将要写入的引用指向的对象是否和该引用类型对象处于不同的 Region **，如果不同，那么将信息记录到 **Remembered Set</strong> 中</p></blockquote><ul><li>在进行垃圾回收时， <strong>Remembered Set</strong> 的存在就可以保证不进行全局扫描，也不会有遗漏</li></ul><h2 id="3-9、三色标记算法"><a href="#3-9、三色标记算法" class="headerlink" title="3.9、三色标记算法"></a>3.9、三色标记算法</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><blockquote><p>三色标记法是一种垃圾回收法，它可以让JVM不发生或仅短时间发生STW(Stop The World)，从而达到清除JVM内存垃圾的目的。JVM中的<strong>CMS、G1垃圾回收器</strong>所使用垃圾回收算法即为三色标记法。</p></blockquote><h3 id="2、三色说明"><a href="#2、三色说明" class="headerlink" title="2、三色说明"></a>2、三色说明</h3><ul><li>白色</li></ul><blockquote><p>该对象从未被标记过（对象垃圾）</p></blockquote><ul><li>灰色</li></ul><blockquote><p>该对象已经被标记过，但该对象下的属性没有完全标记完（GC需要从此对象中去寻找垃圾）</p></blockquote><ul><li>黑色</li></ul><blockquote><p>该对象已经被标记过了，且该对象下的属性也全部都被标记过了。（程序所需要的对象）</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210821162942.png" alt="image-20210821162935333"></p><h3 id="3、算法流程"><a href="#3、算法流程" class="headerlink" title="3、算法流程"></a>3、算法流程</h3><blockquote><p>从 GC Root 对象开始沿着它们的对象向下查找，使用黑灰白的规则，标记除所有与 <code>GC Root</code> 相连接的对象，在第一遍扫描结束后，一般需要进行一次短暂的 STW ，再次进行扫描，此时由于黑色对象的属性都已经扫描标记完成，所以只需要对灰色对象的属性进行扫描标记（且因为大部分的标记工作已经在第一次并发的时候发生了，所以灰色对象数量会很少，标记时间也会短很多）, 此时程序继续执行，<code>GC</code> 线程扫描所有的内存，找出扫描之后依旧被标记为白色的对象（垃圾）清除。</p></blockquote><ul><li>首先创建三个集合，即白、灰、黑</li><li>将所有对象全部放入白色集合中</li><li>从 GC Root 开始遍历所有对象，将遍历到的对象从白色集合放入灰色集合。</li><li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，重复本次操作直到灰色集合为空</li><li>通过write-barrier检测对象有变化，重复以上操作</li><li>收集所有白色对象（垃圾）</li></ul><h3 id="4、存在问题"><a href="#4、存在问题" class="headerlink" title="4、存在问题"></a>4、存在问题</h3><ul><li>浮动垃圾</li></ul><blockquote><p>在并发标记的过程中，如果一个对象已经被标记为黑色或者灰色，那么即使其在标记期间变为垃圾，由于不会再对黑色标记过的对象重新扫描，所以这个垃圾对象不会被发现，也自然不会清除，<strong>浮动垃圾对系统的影响不大，将这块垃圾留给下一次 GC 进行处理即可</strong></p></blockquote><ul><li>对象漏标（需要的对象被回收）</li></ul><blockquote><p>并发标记过程中，一个业务线程将一个未被扫描过的白色对象断开引用使其称为垃圾，同时一个黑色对象引用了该对象；此时由于不会再对黑色对象及其属性进行扫描，所以这个本不该成为垃圾的对象没有被标记，导致需要的对象被 GC 回收，<strong>漏标问题可能导致系统需要的对象被当成垃圾回收，所以可能会导致系统出现问题。</strong></p></blockquote><h2 id="3-10、垃圾回收器-CMS"><a href="#3-10、垃圾回收器-CMS" class="headerlink" title="3.10、垃圾回收器 - CMS"></a>3.10、垃圾回收器 - CMS</h2><blockquote><p>这款垃圾收集器的特点是 <strong>低延迟</strong></p></blockquote><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><ul><li>在 JDK 5 时期，HotSpot 推出了一款在<strong>强交互应用</strong>中几乎可认为是有划时代意义的垃圾回收器，即 CMS （Concurrent-Mark-Sweep），<strong>这款垃圾回收器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾回收线程与用户线程同时工作</strong></li><li>CMS 收集器的关注点是<strong>尽可能缩短垃圾收集时用户线程的停顿时间</strong>。一般来说，停顿时间越短，就越适合与用户交互的程序，良好的响应速度可以提升用户体验</li></ul><blockquote><p><strong>目前很大一部分的 Java 应用集中在互联网网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验</strong>。</p><p>而 CMS 垃圾收集器就非常适合这类应用的需求。</p></blockquote><ul><li>CMS 垃圾收集器作用于<strong>老年代</strong>，采用<strong>标记 - 清除算法</strong>回收垃圾，也会 STW</li></ul><h3 id="2、工作流程"><a href="#2、工作流程" class="headerlink" title="2、工作流程"></a>2、工作流程</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210824221701.png" alt="image-20210824221654007"></p><blockquote><p>在进行<strong>初始标记</strong>时，用户线程会 STW ，不过这个<strong>时间非常短</strong>，在进行重新标记时也会 STW</p><p>CMS 的垃圾回收过程主要分为四个阶段，即<strong>初始标记</strong>阶段、<strong>并发标记</strong>阶段、<strong>重新标记</strong>阶段和<strong>并发清除</strong>阶段</p></blockquote><ul><li><strong>初始标记</strong>（Initial-Mark）阶段</li></ul><blockquote><p>在这个阶段中，程序中<strong>所有的工作线程都会因为 STW 机制而出现短暂的暂停</strong>，这个阶段的主要任务<strong>仅仅只是标记处 GC Roots 能直接关联到的对象</strong>。</p><p>一旦<strong>标记完成之后就会立即恢复之前被暂停的所有应用线程</strong>，由于直接关联对象比较小，所以<strong>这里的速度非常快</strong></p></blockquote><ul><li><strong>并发标记</strong>（Concurrent-Mark）阶段</li></ul><blockquote><p>从 GC Roots 的<strong>直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长</strong>但<strong>不需要暂停用户线程</strong>，可以与垃圾收集线程一起并发运行。</p></blockquote><ul><li><strong>重新标记</strong>（Remark）阶段</li></ul><blockquote><p>由于在并发标记过程中，线程的工作线程会和垃圾收集线程同时或交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分的对象的标记记录</strong>，这个阶段的<strong>停顿时间通常比初始标记的停顿时间长</strong>，但<strong>远短于并发标记消耗的时间</strong>。</p></blockquote><ul><li><strong>并发清除</strong>（Concurrent-Sweep）阶段</li></ul><blockquote><p>此阶段<strong>清理删除掉标记阶段判定的已经死亡的对象，释放内存空间</strong>，由于<strong>不需要对存活的对象进行整理移动</strong>，所以这个阶段也是<strong>可以与用户线程同时并发</strong>的。</p><p>清除后会产生<strong>内存碎片</strong>的问题。</p></blockquote><h3 id="3、特点"><a href="#3、特点" class="headerlink" title="3、特点"></a>3、特点</h3><blockquote><p>目前所有的垃圾回收器都无法做到完全不 STW ，只能做到尽量减少 STW 的时间</p></blockquote><ul><li>低延迟（低停顿）</li></ul><blockquote><p><strong>由于最耗费时间的并发标记阶段与并发清除阶段都不需要暂停用户线程，所以整体的回收是低停顿的</strong>。</p></blockquote><ul><li>在堆内存使用率达到一定阈值时就要开始回收垃圾</li></ul><blockquote><p>由于在并发标记、并发清除两个最耗时的阶段没有暂停用户线程，所以<strong>我们应该保证程序的用户线程拥有足够的内存可用</strong>（想象一下，如果并发标记过程中用户现场跑一半发现内存不够了该怎么办？）。</p><p>因此，<strong>CMS 收集器不能像其他收集器那样等到老年代几乎被填满了再进行回收</strong>，而是<strong>当堆内存的内存达到某一阈值时，就要开始进行垃圾回收</strong>，以<strong>确保应用程序在 CMS 工作过程总依然有足够空间支持应用程序运行</strong>。</p><p>如果 CMS 运行期间预留的内存无法满足程序需要，那么就会出现一次 <strong>Concurrent Mode Failure</strong> 失败，这时虚拟机会启动后备预案，即<strong>临时启用 Serial Old 收集器来重新进行老年代的垃圾回收</strong>，这样停顿时间就很长了。</p></blockquote><h3 id="4、为什么-CMS-不使用标记压缩算法？"><a href="#4、为什么-CMS-不使用标记压缩算法？" class="headerlink" title="4、为什么 CMS 不使用标记压缩算法？"></a>4、为什么 CMS 不使用标记压缩算法？</h3><blockquote><p>这是因为 CMS 在并发清除阶段时，没有进行 STW ，而是与用户线程并发运行，在进行垃圾回收时，用户线程还在工作，而标记压缩算法需要对存活对象进行压缩整合，这涉及到空间的重新分配，所以<strong>为了保证清除过程中用户线程可以继续执行，我们需要保证它的资源（对象空间）不受影响，所以不能使用标记压缩算法</strong>。</p></blockquote><h3 id="5、优点"><a href="#5、优点" class="headerlink" title="5、优点"></a>5、优点</h3><ul><li>低延迟</li><li>并发收集垃圾</li></ul><h3 id="6、缺点"><a href="#6、缺点" class="headerlink" title="6、缺点"></a>6、缺点</h3><ul><li>会产生内存碎片</li></ul><blockquote><p>CMS 采用的标记清除算法可能**会降低内存的利用率，造成内存碎片。在无法分配大对象的情况下，可能会提前触发 Full GC **（可能老年代的空间总和远远大于要分配的大对象，但是由于内存碎片的存在，导致没有一块连续的空间能够容纳这个大对象，此时触发 Full GC）</p></blockquote><ul><li>CMS 收集器对 CPU 资源非常敏感</li></ul><blockquote><p>在并发阶段，它虽然不会导致用户线程停顿，但由于垃圾回收线程占用了一部分线程资源，所以导致应用程序对外界的总吞吐降低。</p></blockquote><ul><li>CMS 收集器无法处理浮动垃圾</li></ul><h3 id="7、CMS-在后续-JDK-中的变化"><a href="#7、CMS-在后续-JDK-中的变化" class="headerlink" title="7、CMS 在后续 JDK 中的变化"></a>7、CMS 在后续 JDK 中的变化</h3><ul><li>在 JDK 9 中， CMS 被标记为 Deprecate</li><li>在 JDK 14 中， CMS 被彻底删除</li></ul></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>JVM学习笔记（二）-垃圾回收</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/1529856079.html">https://sutianxin.top/posts/1529856079.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-05-29</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-08-25</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%98%95Java/">☕Java</a><a class="post-meta__tags" href="/tags/%F0%9F%92%BB%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/">💻后端学习</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/blogImage/raw/master/20210529214344.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/476546087.html"><img class="prev-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210529214020.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM学习笔记（一）-JVM内存结构</div></div></a></div><div class="next-post pull-right"><a href="/posts/913123791.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210516192228.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Cloud学习（七）-Spring Cloud Config</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1128227004.html" title="Java应用学习（七）-回顾Mybatis和Spring MVC"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210430102830.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">Java应用学习（七）-回顾Mybatis和Spring MVC</div></div></a></div><div><a href="/posts/2938255980.html" title="Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210208120213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-12</div><div class="title">Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用</div></div></a></div><div><a href="/posts/913123791.html" title="Spring Cloud学习（七）-Spring Cloud Config"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210516192228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="title">Spring Cloud学习（七）-Spring Cloud Config</div></div></a></div><div><a href="/posts/2863462089.html" title="Spring Cloud学习（二）-OpenFeign微服务调用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504192527.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-11</div><div class="title">Spring Cloud学习（二）-OpenFeign微服务调用</div></div></a></div><div><a href="/posts/995752607.html" title="Spring Cloud学习（四）-Eureka服务注册中心"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210214225250.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-14</div><div class="title">Spring Cloud学习（四）-Eureka服务注册中心</div></div></a></div><div><a href="/posts/650479038.html" title="在线教育项目总结（二）-用户认证"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210205204706.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-05</div><div class="title">在线教育项目总结（二）-用户认证</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">三、垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-text">3.1、如何判断对象可以回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">1、引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">2、可达性分析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-text">3、五种引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-%E2%80%93-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-text">3.2、垃圾回收算法 – 标记清除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-text">2、缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E7%82%B9"><span class="toc-text">3、优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-%E2%80%93-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-text">3.3、垃圾回收算法 – 标记整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-1"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E7%82%B9"><span class="toc-text">2、优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-text">3、缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-%E2%80%93-%E5%A4%8D%E5%88%B6"><span class="toc-text">3.4、垃圾回收算法 – 复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-2"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E7%82%B9-1"><span class="toc-text">2、优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BC%BA%E7%82%B9-1"><span class="toc-text">3、缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E3%80%81%E4%B8%89%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">3.5、三种垃圾回收算法对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E6%95%B4%E9%BD%90%E5%BA%A6"><span class="toc-text">1、内存整齐度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-text">2、内存利用率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6%E3%80%81%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">3.6、分代垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%86%E4%BB%A3%E8%AF%B4%E6%98%8E"><span class="toc-text">1、分代说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2、永久代和元数据的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">3、新生代和老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AF%B9%E8%B1%A1%E8%BD%AC%E7%A7%BB%E8%BF%87%E7%A8%8B"><span class="toc-text">4、对象转移过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%9B%B8%E5%85%B3-VM-%E5%8F%82%E6%95%B0"><span class="toc-text">5、相关 VM 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%88%86%E6%9E%90%E4%BB%A5%E4%B8%8B%E5%8F%82%E6%95%B0%E5%92%8C%E6%97%A5%E5%BF%97"><span class="toc-text">6、分析以下参数和日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E6%99%8B%E5%8D%87%E8%87%B3%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">7、大对象直接晋升至老年代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">3.7、垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%B2%E8%A1%8C%EF%BC%88Serial%EF%BC%89"><span class="toc-text">1、串行（Serial）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-text">2、吞吐量优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-text">3、响应时间优先</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-%E2%80%93-G1"><span class="toc-text">3.8、垃圾回收器 – G1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-3"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E7%9B%B8%E5%85%B3-JVM-%E5%8F%82%E6%95%B0"><span class="toc-text">2、使用场景和相关 JVM 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81G1-%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">3、G1 回收器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%88%86%E5%8C%BA-Region"><span class="toc-text">4、分区 Region</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-text">5、G1 垃圾回收阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Young-Collection"><span class="toc-text">6、Young Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Young-Collection-CM"><span class="toc-text">7、Young Collection + CM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Mixed-Collection"><span class="toc-text">8、Mixed Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Full-GC-%E5%92%8C-Minor-Young-GC"><span class="toc-text">9、Full GC 和 Minor(Young) GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81JDK-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-text">10、JDK 8 字符串去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81JDK-8-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-text">11、JDK 8 并发标记类卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">12、巨型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81Remembered-Set"><span class="toc-text">12、Remembered Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9%E3%80%81%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-text">3.9、三色标记算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%89%E8%89%B2%E8%AF%B4%E6%98%8E"><span class="toc-text">2、三色说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">3、算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-text">4、存在问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-CMS"><span class="toc-text">3.10、垃圾回收器 - CMS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B-1"><span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">2、工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-text">3、特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88-CMS-%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">4、为什么 CMS 不使用标记压缩算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BC%98%E7%82%B9"><span class="toc-text">5、优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-text">6、缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81CMS-%E5%9C%A8%E5%90%8E%E7%BB%AD-JDK-%E4%B8%AD%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">7、CMS 在后续 JDK 中的变化</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init({el:"#twikoo-wrap",envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai"})},e=()=>{twikoo.getCommentsCount({envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then(function(o){t.innerText=o[0].count}).catch(function(o){console.error(o)})};var n;n=!0,"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" data-lrctype="0" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_yegv7kt2bj.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.js"></script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><script src="https://www.luckyclover.top/rain.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"]):not([href="/contact/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>