<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM学习笔记（二）-垃圾回收 | Arno</title><meta name="keywords" content="☕Java,💻后端学习"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="三、垃圾回收3.1、如何判断对象可以回收1、引用计数法 定义   此种算法会在每一个对象上记录这个对象被引用的次数，只要有任何一个对象引用了次对象，这个对象的计数器就+1，取消对这个对象的引用时，计数器就-1，在分配对象时会将计数器的值置为1。 任何一个时刻，如果该对象的计数器为0，那么这个对象就是可以回收的。   缺点   计数器值增减频繁 实现繁琐，更新引用时很容易导致内存泄露。 循环引用无法"><meta property="og:type" content="article"><meta property="og:title" content="JVM学习笔记（二）-垃圾回收"><meta property="og:url" content="https://sutianxin.top/posts/1529856079.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="三、垃圾回收3.1、如何判断对象可以回收1、引用计数法 定义   此种算法会在每一个对象上记录这个对象被引用的次数，只要有任何一个对象引用了次对象，这个对象的计数器就+1，取消对这个对象的引用时，计数器就-1，在分配对象时会将计数器的值置为1。 任何一个时刻，如果该对象的计数器为0，那么这个对象就是可以回收的。   缺点   计数器值增减频繁 实现繁琐，更新引用时很容易导致内存泄露。 循环引用无法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/blogImage/raw/master/20210529214344.jpg"><meta property="article:published_time" content="2021-05-29T13:37:15.000Z"><meta property="article:modified_time" content="2021-05-29T13:53:19.777Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="☕Java"><meta property="article:tag" content="💻后端学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/blogImage/raw/master/20210529214344.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/1529856079"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-05-29 21:53:19"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,a={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(a)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/blogImage/raw/master/20210529214344.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM学习笔记（二）-垃圾回收</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-29T13:37:15.000Z" title="发表于 2021-05-29 21:37:15">2021-05-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-29T13:53:19.777Z" title="更新于 2021-05-29 21:53:19">2021-05-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.2k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="3-1、如何判断对象可以回收"><a href="#3-1、如何判断对象可以回收" class="headerlink" title="3.1、如何判断对象可以回收"></a>3.1、如何判断对象可以回收</h2><h3 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h3><ul><li>定义</li></ul><blockquote><p>此种算法会在每一个对象上<strong>记录这个对象被引用的次数</strong>，只要有任何一个对象引用了次对象，这个对象的计数器就+1，取消对这个对象的引用时，计数器就-1，<strong>在分配对象时会将计数器的值置为1</strong>。</p><p>任何一个时刻，如果该对象的计数器为0，那么这个对象就是可以回收的。</p></blockquote><ul><li>缺点</li></ul><ol><li>计数器值增减频繁</li><li>实现繁琐，更新引用时很容易导致内存泄露。</li><li>循环引用无法回收(最重要的缺点)，两个已经失去作用、但互相引用的对象无法被<strong>引用计数法</strong>判断为可回收垃圾。</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521172331.png" alt="image-20210521172324702"></p><ul><li>注意：JVM 没有使用<strong>引用计数法</strong></li></ul><h3 id="2、可达性分析方法"><a href="#2、可达性分析方法" class="headerlink" title="2、可达性分析方法"></a>2、可达性分析方法</h3><ul><li>定义</li></ul><blockquote><p>这个算法的基本思想是通过一系列称为 “<strong>GC Roots</strong>“（肯定不能被当为垃圾回收的对象） 的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象可以被当成垃圾进行回收。</p><p><code>JVM</code> 中的垃圾回收器采用<strong>可达性分析算法</strong>来探索所有存活的对象。</p></blockquote><ul><li>哪些对象可以作为 <code>GC Root</code> ？</li></ul><ol><li><p>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</p></li><li><p>方法区中的类静态属性引用的对象和常量引用的对象。</p></li><li><p>本地方法栈中JNI(Native方法)引用的对象。</p></li><li><p>正在加锁的对象</p></li></ol><h3 id="3、五种引用"><a href="#3、五种引用" class="headerlink" title="3、五种引用"></a>3、五种引用</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521193931.png" alt="image-20210521193931546"></p><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521190911.png" alt="image-20210521190911142"></p><blockquote><p>Java 中常见的五种引用分别为：强引用、弱引用、虚引用、软引用和终结器引用</p></blockquote><ul><li>强引用：不回收</li></ul><blockquote><p>如果一个对象具有强引用，那就类似于<strong>必不可少的</strong>物品，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，使程序异常终止，也不回收这种对象。</p><p>Java 中绝大部分引用都是强引用。</p></blockquote><ul><li>软引用：内存不足即回收</li></ul><blockquote><p>软引用是用来描述一些<strong>有用但并不是必需</strong>的对象，在Java中用 <code>java.lang.ref.SoftReference</code> 类来表示。</p><p>对于只有软引用的对象来说：当系统内存充足时它不会被回收，当系统内存不足时它才会被回收。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p></blockquote><ul><li>弱引用：发现即回收</li></ul><blockquote><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>弱引用需要用<code>java.lang.ref.WeakReference</code>类来实现，它比软引用的生存期更短。</p><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，<strong>不管 JVM 的内存空间是否足够</strong>，都会回收该对象占用的内存。</p><p><code>ThreadLocal</code> 中的 <code>ThreadLocalMap</code> 的 <code>Entry</code> 就继承了 <code>WeakReference</code></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521192343.png" alt="image-20210521192342894"></p><ul><li>虚引用：对象回收跟踪</li></ul><blockquote><p>虚引用也称为<strong>幽灵引用</strong>或者<strong>幻影引用</strong>，它是最弱的一种引用关系。</p><p>虚引用，顾名思义，就是形同虚设，与其他几种引用都不太一样，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p><p>虚引用需要<code>java.lang.ref.PhantomReference</code> 来实现。</p><p>如果一个对象<strong>仅持有虚引用</strong>，那么它就和<strong>没有任何引用一样</strong>，<strong>在任何时候都可能被垃圾回收器回收</strong>，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列（<code>RefenenceQueue</code>）联合使用。</p><p>虚引用的主要作用是跟踪对象垃圾回收的状态。仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。</p></blockquote><ul><li>终结器引用</li></ul><blockquote><p>它用以实现对象的 <code>finalize</code> 方法，也可以称为终结器引用。无需手动编码， 其内部配合引用队列使用。</p></blockquote><h2 id="3-2、垃圾回收算法-–-标记清除"><a href="#3-2、垃圾回收算法-–-标记清除" class="headerlink" title="3.2、垃圾回收算法 – 标记清除"></a>3.2、垃圾回收算法 – 标记清除</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p>标记清除算法是一种分两阶段对对象进行垃圾回收的算法。</p><p>第一阶段：标记。从根节点（GC Root）出发遍历对象，对访问过的对象打上标记（一般是在对象的 Header 中记录），证明该节点为可达，并非可以回收的垃圾节点</p><p>第二阶段：清除。对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521201558.png" alt="image-20210521201558262"></p><h3 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h3><ul><li>回收后<strong>会产生大量不连续的内存空间</strong>，即内存碎片。</li></ul><blockquote><p>由于Java在分配内存时通常是按连续内存分配，那么当碎片空间不足以分配给新的对象时，就造成了内存浪费。</p></blockquote><ul><li><strong>进行垃圾回收时，应用需要挂起</strong></li><li><strong>标记和清除的效率不高</strong>，尤其是要扫描的对象比较多的时候</li></ul><h3 id="3、优点"><a href="#3、优点" class="headerlink" title="3、优点"></a>3、优点</h3><ul><li>可以解决循环引用的问题</li><li>必要时才回收(内存不足时)</li></ul><h2 id="3-3、垃圾回收算法-–-标记整理"><a href="#3-3、垃圾回收算法-–-标记整理" class="headerlink" title="3.3、垃圾回收算法 – 标记整理"></a>3.3、垃圾回收算法 – 标记整理</h2><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521204010.png" alt="image-20210521204010481"></p><h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p>标记整理算法和标记清除算法一样分为两个阶段，即先标记后整理。由于标记清除算法的一个缺点就是会产生大量内存碎片，而标记整理算法会对内存空间进行一次整理，解决内存碎片化问题。</p></blockquote><ul><li>标记。从根节点（GC Root）出发遍历对象，对访问过的对象打上标记（一般是在对象的 Header 中记录），证明该节点为可达，并非可以回收的垃圾节点</li><li>整理。在遍历结束后， <strong>对于标记过的对象，把它们从内存开始的区域按顺序依次摆好，整整齐齐的， 中间没有任何的缝隙</strong>。在摆放完最后一个标记过的对象后， 把之后的内存区域直接回收掉. (这里最耗时的步骤是，当你移动一个对象的内存位置时，你需要让所有之前依赖这个对象的对象更新一下引用地址信息，这样才不会在移动之后出错.)</li></ul><h3 id="2、优点"><a href="#2、优点" class="headerlink" title="2、优点"></a>2、优点</h3><ul><li>消除了标记清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h3 id="3、缺点"><a href="#3、缺点" class="headerlink" title="3、缺点"></a>3、缺点</h3><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li><li>移动过程中，需要全程暂停用户应用程序。</li></ul><h2 id="3-4、垃圾回收算法-–-复制"><a href="#3-4、垃圾回收算法-–-复制" class="headerlink" title="3.4、垃圾回收算法 – 复制"></a>3.4、垃圾回收算法 – 复制</h2><h3 id="1、定义-2"><a href="#1、定义-2" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p><strong>复制算法将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的</strong>。</p><p>当有效内存空间耗尽时，<code>JVM</code> 将暂停程序运行，开启复制算法 <code>GC</code> 线程。<strong>接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址</strong>。</p><p>此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。</p></blockquote><ul><li>垃圾清理前（1、4 为垃圾）</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521231513.png" alt="image-20210521231513342"></p><ul><li>将所有存活对象复制到原来的空闲区间中，并按照内存地址排序，更新引用，然后清除原来活动区间（现空闲区间）中的所有垃圾对象（1、4）</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210521231610.png" alt="image-20210521231610100"></p><h3 id="2、优点-1"><a href="#2、优点-1" class="headerlink" title="2、优点"></a>2、优点</h3><ul><li>不产生内存碎片问题，能保持对象的完整性。</li><li>可实现高速分配</li></ul><blockquote><p>GC 复制算法不使用空闲链表。这是因为分块是一个连续的内存空间。比起 GC 标记 - 清除算法和引用计数法等使用空闲链表的分配，GC 复制算法明显快得多。</p></blockquote><h3 id="3、缺点-1"><a href="#3、缺点-1" class="headerlink" title="3、缺点"></a>3、缺点</h3><ul><li><strong>复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视</strong>。</li></ul><blockquote><p>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。</p></blockquote><ul><li>堆使用效率低下，会浪费 50% 的内存</li></ul><blockquote><p>GC 复制算法把堆二等分，通常只能利用其中的一半来安排对象。也就是说，只有一半 堆能被使用。相比其他能使用整个堆的 GC 算法而言，可以说这是 GC 复制算法的一个重大的缺陷。</p><p>通过搭配使用 GC 复制算法和 GC 标记 - 清除算法可以改善这个缺点</p><p><strong>复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费</strong>。</p></blockquote><h2 id="3-5、三种垃圾回收算法对比"><a href="#3-5、三种垃圾回收算法对比" class="headerlink" title="3.5、三种垃圾回收算法对比"></a>3.5、三种垃圾回收算法对比</h2><h3 id="1、内存整齐度"><a href="#1、内存整齐度" class="headerlink" title="1、内存整齐度"></a>1、内存整齐度</h3><p>复制算法 = 标记整理算法 &gt; 标记清理算法</p><h3 id="2、内存利用率"><a href="#2、内存利用率" class="headerlink" title="2、内存利用率"></a>2、内存利用率</h3><p>标记整理算法 = 复制算法 &gt; 标记清理算法</p><h2 id="3-6、分代垃圾回收"><a href="#3-6、分代垃圾回收" class="headerlink" title="3.6、分代垃圾回收"></a>3.6、分代垃圾回收</h2><h3 id="1、分代说明"><a href="#1、分代说明" class="headerlink" title="1、分代说明"></a>1、分代说明</h3><blockquote><p>堆内存是JAVA虚拟机所管理的内存最大的一块，Java堆被所有线程共享，几乎所有的对象实例都是在堆中分配内存，因此<strong>Java的堆是垃圾回收的主要区域</strong>。</p><p><strong>JVM的内存分代讲的就是堆内存的分代</strong>，为了更加高效的回收垃圾，将内存划分为了多个generation（代）。</p><p>JVM堆可以划分为新生代、老年代、永久代（JDK1.7），在JDK1.8中，永久代被元空间（<code>Metaspace</code>）所代替，并且元空间已经不在堆中了。</p></blockquote><h3 id="2、永久代和元数据的区别"><a href="#2、永久代和元数据的区别" class="headerlink" title="2、永久代和元数据的区别"></a>2、永久代和元数据的区别</h3><blockquote><p>永久代是 <code>HotSpot</code> 虚拟机特有的概念，并且在JDK1.8之后，永久代就彻底消失了。</p><p>永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，并且永久代必须指定大小限制，因此就会导致性能问题和内存溢出的问题。永久代会给GC带来不必要的复杂性。</p><p>元空间的本质和永久代类似，但是<strong>元空间并不在堆中，而是直接使用了本地内存</strong>，元数据可以设置限制，也可以不设置，它的大小仅受本地内存限制。</p></blockquote><h3 id="3、新生代和老年代"><a href="#3、新生代和老年代" class="headerlink" title="3、新生代和老年代"></a>3、新生代和老年代</h3><blockquote><p>新生代和老年代是垃圾回收最主要的区域。</p><p>一般将更有价值，需要长时间存活的对象放在老年代中，用完则丢弃的对象放在新生代中。</p><p>老年代的垃圾回收触发频率较低，新生代频繁触发垃圾回收</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522131120.png" alt="image-20210522131113329"></p><blockquote><p>新生代和老年代都在堆内存中，新生代和老年代所占的默认比例为1 ： 2，其中新生代又由一个伊甸（Eden）区和两个幸存者（Survivor）区组成，三个区的默认比例为8：1：1。</p></blockquote><ul><li>新生代</li></ul><blockquote><p><code>YoungGC</code> 对应于新生代，<strong>第一次YGC</strong>只回收 <code>eden</code> 区域，回收后大多数（百分之九十八左右）的对象会被回收，活着的对象通过复制算法进入Survivor0（后续用S0和S1代替）。<strong>再次YGC后</strong>，<code>eden+S0</code>中活着的对象进入S1。<strong>再次YGC</strong>，<code>eden+S1</code>中活着的对象进入到S0。依次循环。</p><p>在将 <code>eden</code> 区与其中一个survivor区作为 From 区时，需要将另外一个survivor区作为 To 区，即保证 To 区为空。</p></blockquote><ul><li><p>当一个<strong>对象的年龄</strong>（经历的YGC次数）足够时（传统的垃圾回收器一般是15，CMS垃圾回收器是6），<strong>进入老年代</strong>。</p></li><li><p>如果遇到一个<strong>对象S区装不下</strong>，则直接进入老年代。</p></li><li><p>老年代</p></li></ul><blockquote><p>老年代的垃圾回收或称叫做 <code>FullGC</code>，当老年代空间不足时，就会触发 <code>FullGC</code>；另外，如果元空间区域的内存达到了所设定的阈值<code>-XX:MetaspaceSize=</code>，也会触发<code>FullGC</code>。</p><p><code>FullGC</code> 采用的是<strong>标记整理算法</strong>，这个算法的效率是比较低的，因为它要标记出或者的对象，然后移到内存的一侧，最后再清空区域外的内存。这个过程会十分消耗时间。</p><p>因此优化 <code>JVM</code> 最重要的一点就是优化 <code>FullGC</code>，尽可能的不要执行 <code>FullGC</code>。</p></blockquote><h3 id="4、对象转移过程"><a href="#4、对象转移过程" class="headerlink" title="4、对象转移过程"></a>4、对象转移过程</h3><ul><li>当我们创建一个新对象后，这个新对象会默认占用新生代中伊甸（Eden）区的一块空间</li><li>当伊甸区空间不够时，此时会触发一次 <strong>Minor GC（Young GC）</strong>，第一次 <strong>Minor GC</strong> 只针对伊甸区，并将第一块幸存者（survivor0）区作为复制算法的 To 区，然后将存活下来进入幸存区的对象的寿命 + 1。</li><li>此时由于伊甸区已经被清空，所以后面新创建的对象可以继续存放在伊甸区中，在后面的复制算法中，会将伊甸区和上面的第一块幸存者（survivor0）区作为 From 区，然后将另外一块幸存者（survivor1）区作为 To 区，此时需要对幸存的对象的寿命 + 1</li><li>新生代中的对象不会永远呆在新生代中，当新生代中对象的寿命超过一个阈值（15）时，这个对象会被转移到老年代。GC分代年龄存储在对象的 header 中</li><li>如果遇到一个<strong>对象 Survivor 区装不下</strong>，则直接进入老年代。</li><li>当新生代空间实在不足或老年代空间不足时，会使用 <code>Full GC</code> 对新生代与老年代进行一次力度较大的垃圾回收。</li><li><code>Minor GC</code> 会引发 stop the world，即暂停其他用户线程，直到垃圾回收线程完成工作后继续运行其他用户线程，<code>Minor GC</code> 使用的时间较短</li><li>对象寿命的阈值是15，超过这个阈值，新生代对象会被转移到老年代中，这是由于对象头中，寿命占 4 bit，而4 bit 最大的值即为15，不同垃圾回收器中寿命阈值不同。</li><li>Full GC 也会引发 stop the world，但占用的时间会更长。</li></ul><h3 id="5、相关-VM-参数"><a href="#5、相关-VM-参数" class="headerlink" title="5、相关 VM 参数"></a>5、相关 VM 参数</h3><table><thead><tr><th align="center">含义</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">堆初始大小</td><td align="center"><code>-Xms</code></td></tr><tr><td align="center">堆最大大小</td><td align="center"><code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></td></tr><tr><td align="center">新生代大小</td><td align="center"><code>-Xmn</code> 或 <code>(-XX:NewSize=size + -XX:MaxNewSize=size)</code></td></tr><tr><td align="center">幸存者比例（动态）</td><td align="center"><code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></td></tr><tr><td align="center">幸存者比例</td><td align="center"><code>-XX:SurvivorRatio=ratio</code></td></tr><tr><td align="center">晋升阈值</td><td align="center"><code>-XX:MaxTenuringThreshold=threshold</code></td></tr><tr><td align="center">晋升详情</td><td align="center"><code>-XX:+PrintTenuringDistribution</code></td></tr><tr><td align="center">GC 详情</td><td align="center"><code>-XX:+PrintGCDetails -verbose:gc</code></td></tr><tr><td align="center"><code>Full GC</code> 前 <code>Minor GC</code></td><td align="center"><code>-XX:+ScavengeBeforeFullGC</code></td></tr></tbody></table><h3 id="6、分析以下参数和日志"><a href="#6、分析以下参数和日志" class="headerlink" title="6、分析以下参数和日志"></a>6、分析以下参数和日志</h3><blockquote><p>在参数中，我们指定堆初始大小和堆最大大小为 20M，新生代大小为 10M ，所以老年代大小为 10M （20 - 10）</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522143436.png" alt="image-20210522143436418"></p><ul><li>在截图中，显示了堆和元空间的数据</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522143719.png" alt="image-20210522143718997"></p><blockquote><p>在新生代中，内存空间被划分为3块，其中伊甸区占 4/5 ，其余两块幸存区各占 1/10 ，由于一块幸存者区要作为复制算法的 To 区，所以 10M 内存中有 1M 必须为空，故可用内存只有 9M.</p><p>total 为可用的内存大小，used 表示已经使用的大小</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522144237.png" alt="image-20210522144237324"></p><blockquote><p>从上面日志中可以看到新生代中内存划分和分配比例。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522144500.png" alt="image-20210522144500450"></p><blockquote><p>上面日志打印了老年代的内存占用信息，由于堆初始大小、堆最大大小和新生代内存大小都已经被指定，所以老年代内存大小也被指定。</p></blockquote><h3 id="7、大对象直接晋升至老年代"><a href="#7、大对象直接晋升至老年代" class="headerlink" title="7、大对象直接晋升至老年代"></a>7、大对象直接晋升至老年代</h3><blockquote><p>对于无法放入新生代，但可以放入老年代的大对象来说，JVM 会直接将该对象放入老年代，不会触发 GC</p></blockquote><ul><li>放置大对象前</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522143436.png" alt="image-20210522143436418"></p><ul><li>往堆中直接塞一个 8M 的大对象，查看日志</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522145752.png" alt="image-20210522145752735"></p><blockquote><p>可以看到，大对象直接被塞进了老年代，同时没有触发 GC</p></blockquote><ul><li><strong>一个线程的OOM不会导致进程失效</strong></li></ul><h2 id="3-7、垃圾回收器"><a href="#3-7、垃圾回收器" class="headerlink" title="3.7、垃圾回收器"></a>3.7、垃圾回收器</h2><h3 id="1、串行（Serial）"><a href="#1、串行（Serial）" class="headerlink" title="1、串行（Serial）"></a>1、串行（Serial）</h3><ul><li>简介</li></ul><blockquote><p>Serial 是一类<strong>用于新生代</strong>的<strong>单线程收集器</strong>，采用<strong>复制算法</strong>进行垃圾收集。Serial进行垃圾收集时，不仅只用一条单线程执行垃圾收集工作，<strong>它还在收集的同时，所用的用户必须暂停</strong>。</p><p>适用于堆内存较小的个人电脑</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522153952.png" alt="image-20210522153952355"></p><blockquote><p>从上图可知当应用程序进行到一个安全的节点的时候，所有的线程全都暂停，等到GC完成后，应用程序线程继续执行。</p></blockquote><ul><li>优点</li></ul><blockquote><p>简单高效，由于采用的是单线程的方法，因此与其他类型的收集器相比，对单个 <code>cpu</code> 来说没有了上下文之间的的切换，效率比较高。</p></blockquote><ul><li>缺点</li></ul><blockquote><p>会在用户不知道的情况下停止所有工作线程，用户体验感极差，令人难以接受。</p></blockquote><ul><li>开启命令</li></ul><blockquote><p>其中 Serial 工作在新生代，使用的算法是复制算法</p><p><code>SerialOld</code> 工作在老年代，使用的是标记整理算法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserSerialGC = Serial + SerialOld</span><br></pre></td></tr></table></figure><h3 id="2、吞吐量优先"><a href="#2、吞吐量优先" class="headerlink" title="2、吞吐量优先"></a>2、吞吐量优先</h3><blockquote><p>使用于多线程、堆内存较大、拥有多核 CPU 的环境（服务器）</p></blockquote><ul><li>简介</li></ul><blockquote><p>Parallel Scavenge 是一款用于新生代的多线程收集器，采用复制算法。与 <code>ParNew</code> 的不同之处在于 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量，而 <code>ParNew</code> 收集器关注点在于尽可能的缩短垃圾收集时用户线程的停顿时间。</p><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值， 即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522152437.png" alt="image-20210522152437296"></p><ul><li>优点</li></ul><blockquote><p>追求高吞吐量，高效利用CPU，是吞吐量优先，且能进行精确控制。</p></blockquote><ul><li>开启命令</li></ul><blockquote><p>JDK 8 默认开启，<code>ParallelOldGC</code> 工作在老年代，使用 <strong>标记整理算法</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC ~ -XX:++UseParallelOldGC</span><br></pre></td></tr></table></figure><h3 id="3、响应时间优先"><a href="#3、响应时间优先" class="headerlink" title="3、响应时间优先"></a>3、响应时间优先</h3><blockquote><p>使用于多线程、堆内存较大、拥有多核 CPU 的环境（服务器）</p></blockquote><ul><li>简介</li></ul><blockquote><p><code>ParNew</code> 收集器其实就是Serial的一个多线程版本，其在单核 <code>cpu</code> 上的表现并不会比 <code>Serail</code> 收集器更好，在多核机器上，其默认开启的收集线程数与 <code>cpu</code> 数量相等。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522152620.png" alt="image-20210522152620792"></p><ul><li>优点</li></ul><blockquote><p>随着 <code>cpu</code> 的有效利用，对于GC时系统资源的有效利用有好处。</p></blockquote><ul><li>缺点</li></ul><blockquote><p>会在用户不知道的情况下停止所有工作线程</p></blockquote><h2 id="3-8、垃圾回收器-–-G1"><a href="#3-8、垃圾回收器-–-G1" class="headerlink" title="3.8、垃圾回收器 – G1"></a>3.8、垃圾回收器 – G1</h2><h3 id="1、定义-3"><a href="#1、定义-3" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p>G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为 <code>HotSpot</code> 重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器。</p><p>G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。</p></blockquote><ul><li>2004 论文发布</li><li>2009 JDK 6 体验</li><li>2012 JDK 7 官方支持</li><li>2017 JDK 9 默认</li></ul><h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><ul><li><p>同时注重吞吐量和低延迟，默认的暂停目标是 200 <code>ms</code></p></li><li><p>适合超大堆内存，G1 会将堆划分为多个大小相等的 Region</p></li><li><p>整体上是标记 + 整理算法，两个区域间是复制算法</p></li></ul><h3 id="3、相关-JVM-参数"><a href="#3、相关-JVM-参数" class="headerlink" title="3、相关 JVM 参数"></a>3、相关 <code>JVM</code> 参数</h3><ul><li>开启方式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><ul><li>指定 G1 区域的大小</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:G1HeapRegionSize=size</span><br></pre></td></tr></table></figure><h3 id="4、G1-垃圾回收阶段"><a href="#4、G1-垃圾回收阶段" class="headerlink" title="4、G1 垃圾回收阶段"></a>4、G1 垃圾回收阶段</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210529214306.png" alt="image-20210522192817910"></p><blockquote><p>G1 垃圾回收器的回收工作可以分为三个阶段，分别为</p></blockquote><ul><li><code>Young Collection</code> ：对新生代的垃圾进行收集</li><li><code>Young Collection + Concurrent Mark</code>： 对新生代垃圾进行收集并添加并发标记</li><li><code>Mixed Collection</code> ：混合垃圾收集（对新生代、新生区、老年代都进行一次规模较大的垃圾收集）</li></ul><blockquote><p>以上三个过程循环进行</p></blockquote><h3 id="5、Young-Collection"><a href="#5、Young-Collection" class="headerlink" title="5、Young Collection"></a>5、<code>Young Collection</code></h3><blockquote><p>会产生 <code>Stop The World</code> ，阻塞其他用户线程</p></blockquote><ul><li>新创建的对象放入伊甸（Eden）区中，在新生区的伊甸区被占满后，此时会触发一次 <code>Young Collection</code></li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522193725.png" alt="image-20210522193725471"></p><ul><li><code>Young Collection</code> 会将伊甸区中的存活对象拷贝到幸存区中。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522194038.png" alt="image-20210522194038070"></p><ul><li>在幸存区空间不足或者幸存区对象寿命达到阈值后，此时幸存区中的一部分对象会被放入老年代，一部分会被当成垃圾回收，另一部分会放入其他的幸存区中。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522201635.png" alt="image-20210522201635379"></p><h3 id="6、Young-Collection-CM"><a href="#6、Young-Collection-CM" class="headerlink" title="6、Young Collection + CM"></a>6、<code>Young Collection + CM</code></h3><ul><li>在 <code>Young GC</code> 时会进行 <code>GC Root</code> 的初始标记</li><li>老年待占用堆空间比例达到阈值时，进行并发标记（不会 STW ），由下面的 <code>JVM</code> 参数决定</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent=percent（默认为 45%）</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522204057.png" alt="image-20210522204057591"></p><h3 id="7、Mixed-Collection"><a href="#7、Mixed-Collection" class="headerlink" title="7、Mixed Collection"></a>7、<code>Mixed Collection</code></h3><blockquote><p>会对 E 、 S 、O 进行全部垃圾回收</p></blockquote><ul><li>最终标记（Remark）会产生 STW</li><li>拷贝存活（Evacuation）会产生 STW</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210522204500.png" alt="image-20210522204500487"></p><blockquote><p>由于我们会指定一个 <code>GC</code> 最大暂停时间，在这个事件内，G1 可能无法对所有老年代垃圾进行回收，所以它会有选择地回收一部分老年代的垃圾（回收价值最大的垃圾）进行回收</p><p>优先回收垃圾最多的区域</p></blockquote><h3 id="8、Full-GC-和-Minor-Young-GC"><a href="#8、Full-GC-和-Minor-Young-GC" class="headerlink" title="8、Full GC 和 Minor(Young) GC"></a>8、Full GC 和 Minor(Young) GC</h3><ul><li><p>Serial GC</p><ul><li>新生代内存不足发生的垃圾收集 - <code>Minor GC</code></li><li>老年代内存不足发生的垃圾收集 - <code>Full GC</code></li></ul></li><li><p>Parallel GC</p><ul><li>新生代内存不足发生的垃圾收集 - <code>Minor GC</code></li><li>老年代内存不足发生的垃圾收集 - <code>Full GC</code></li></ul></li><li><p>CMS</p><ul><li>新生代内存不足发生的垃圾收集 - <code>Minor GC</code></li><li>老年代内存不足</li></ul></li><li><p>G1</p><ul><li>新生代内存不足发生的垃圾收集 - <code>Minor GC</code></li><li>老年代内存不足</li></ul><blockquote><p>在 G1 进行并发标记、混合收集（且垃圾清除的速度大于垃圾产生速度）时，不直接称为 Full GC，此时仍然处于并发垃圾收集的阶段；</p><p>只有垃圾回收的速度更不上垃圾产生的速度时，这个时候并发收集失败，这个时候退化为一个串行（Serial）收集，此时称为 Full GC</p></blockquote></li></ul><h3 id="9、JDK-8-字符串去重"><a href="#9、JDK-8-字符串去重" class="headerlink" title="9、JDK 8 字符串去重"></a>9、JDK 8 字符串去重</h3><ul><li>优点：节省大量内存</li><li>缺点：略微多占用了 CPU 时间，新生代回收时间略微增加</li></ul><blockquote><p>开启参数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseStringDeduplication # 默认打开</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[] &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[] &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>将所有新分配的字符串放入一个队列</li><li>当新生代回收时，G1 并发检查是否有字符串重复</li><li>如果它们值一样，让他们引用同一个 char[]</li><li>注意，与 <code>String.intern()</code> 不一样<ul><li><code>String.intern()</code> 关注的是字符串对象</li><li>字符串去重关注的是 char[]</li><li>在 <code>JVM</code> 内部，使用了不同的字符串表</li></ul></li></ul><h3 id="10、JDK-8-并发标记类卸载"><a href="#10、JDK-8-并发标记类卸载" class="headerlink" title="10、JDK 8 并发标记类卸载"></a>10、JDK 8 并发标记类卸载</h3><blockquote><p>所有对象都经过并发标记后，就能直到哪些类不再被使用，当一个类加载器的所有类都不再使用后，则卸载它所加载的所有类</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ClassUnloadingWithConcurrentMark #默认启用</span><br></pre></td></tr></table></figure><h3 id="11、巨型对象"><a href="#11、巨型对象" class="headerlink" title="11、巨型对象"></a>11、巨型对象</h3><ul><li>一个对象大于 <code>Region</code> 的一半时，称为巨型对象。</li><li>G1 不会对巨型对象进行拷贝，回收时优先考虑巨型对象。</li><li>G1 会跟踪老年代所有 <code>incoming</code> 引用，这样老年代 <code>incoming</code> 引用为 0 的巨型对象就可以在新生代垃圾回收时被处理掉。</li></ul></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>JVM学习笔记（二）-垃圾回收</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/1529856079.html">https://sutianxin.top/posts/1529856079.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-05-29</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-05-29</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%98%95Java/">☕Java</a><a class="post-meta__tags" href="/tags/%F0%9F%92%BB%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/">💻后端学习</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/blogImage/raw/master/20210529214344.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/476546087.html"><img class="prev-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210529214020.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM学习笔记（一）-JVM内存结构</div></div></a></div><div class="next-post pull-right"><a href="/posts/913123791.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210516192228.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Cloud学习（七）-Spring Cloud Config</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1128227004.html" title="Java应用学习（七）-回顾Mybatis和Spring MVC"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210430102830.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">Java应用学习（七）-回顾Mybatis和Spring MVC</div></div></a></div><div><a href="/posts/2938255980.html" title="Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210208120213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-12</div><div class="title">Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用</div></div></a></div><div><a href="/posts/913123791.html" title="Spring Cloud学习（七）-Spring Cloud Config"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210516192228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="title">Spring Cloud学习（七）-Spring Cloud Config</div></div></a></div><div><a href="/posts/2863462089.html" title="Spring Cloud学习（二）-OpenFeign微服务调用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504192527.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-11</div><div class="title">Spring Cloud学习（二）-OpenFeign微服务调用</div></div></a></div><div><a href="/posts/995752607.html" title="Spring Cloud学习（四）-Eureka服务注册中心"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210214225250.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-14</div><div class="title">Spring Cloud学习（四）-Eureka服务注册中心</div></div></a></div><div><a href="/posts/650479038.html" title="在线教育项目总结（二）-用户认证"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210205204706.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-05</div><div class="title">在线教育项目总结（二）-用户认证</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">三、垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-text">3.1、如何判断对象可以回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">1、引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">2、可达性分析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-text">3、五种引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-%E2%80%93-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-text">3.2、垃圾回收算法 – 标记清除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-text">2、缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E7%82%B9"><span class="toc-text">3、优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-%E2%80%93-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-text">3.3、垃圾回收算法 – 标记整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-1"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E7%82%B9"><span class="toc-text">2、优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-text">3、缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-%E2%80%93-%E5%A4%8D%E5%88%B6"><span class="toc-text">3.4、垃圾回收算法 – 复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-2"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E7%82%B9-1"><span class="toc-text">2、优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BC%BA%E7%82%B9-1"><span class="toc-text">3、缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E3%80%81%E4%B8%89%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">3.5、三种垃圾回收算法对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E6%95%B4%E9%BD%90%E5%BA%A6"><span class="toc-text">1、内存整齐度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-text">2、内存利用率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6%E3%80%81%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">3.6、分代垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%86%E4%BB%A3%E8%AF%B4%E6%98%8E"><span class="toc-text">1、分代说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2、永久代和元数据的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">3、新生代和老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AF%B9%E8%B1%A1%E8%BD%AC%E7%A7%BB%E8%BF%87%E7%A8%8B"><span class="toc-text">4、对象转移过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%9B%B8%E5%85%B3-VM-%E5%8F%82%E6%95%B0"><span class="toc-text">5、相关 VM 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%88%86%E6%9E%90%E4%BB%A5%E4%B8%8B%E5%8F%82%E6%95%B0%E5%92%8C%E6%97%A5%E5%BF%97"><span class="toc-text">6、分析以下参数和日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E6%99%8B%E5%8D%87%E8%87%B3%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">7、大对象直接晋升至老年代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">3.7、垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%B2%E8%A1%8C%EF%BC%88Serial%EF%BC%89"><span class="toc-text">1、串行（Serial）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-text">2、吞吐量优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-text">3、响应时间优先</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-%E2%80%93-G1"><span class="toc-text">3.8、垃圾回收器 – G1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-3"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2、使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%9B%B8%E5%85%B3-JVM-%E5%8F%82%E6%95%B0"><span class="toc-text">3、相关 JVM 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-text">4、G1 垃圾回收阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Young-Collection"><span class="toc-text">5、Young Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Young-Collection-CM"><span class="toc-text">6、Young Collection + CM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Mixed-Collection"><span class="toc-text">7、Mixed Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Full-GC-%E5%92%8C-Minor-Young-GC"><span class="toc-text">8、Full GC 和 Minor(Young) GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81JDK-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-text">9、JDK 8 字符串去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81JDK-8-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-text">10、JDK 8 并发标记类卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">11、巨型对象</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init({el:"#twikoo-wrap",envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai"})},e=()=>{twikoo.getCommentsCount({envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then(function(o){t.innerText=o[0].count}).catch(function(o){console.error(o)})};var n;n=!0,"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" data-lrctype="0" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_yegv7kt2bj.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.js"></script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><script src="https://www.luckyclover.top/rain.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"]):not([href="/contact/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>