<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础学习（四）-计算机网络 | Arno</title><meta name="keywords" content="💻后端学习"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="回顾一下计算机网络相关知识"><meta property="og:type" content="article"><meta property="og:title" content="Java基础学习（四）-计算机网络"><meta property="og:url" content="https://sutianxin.top/posts/89666111.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="回顾一下计算机网络相关知识"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/blogImage/raw/master/20210813230548.jpg"><meta property="article:published_time" content="2021-08-13T14:56:10.000Z"><meta property="article:modified_time" content="2021-09-24T12:41:29.237Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="💻后端学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/blogImage/raw/master/20210813230548.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/89666111"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-09-24 20:41:29"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,a={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(a)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/blogImage/raw/master/20210813230548.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础学习（四）-计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-13T14:56:10.000Z" title="发表于 2021-08-13 22:56:10">2021-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-24T12:41:29.237Z" title="更新于 2021-09-24 20:41:29">2021-09-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、七层网络模型（OSI）"><a href="#一、七层网络模型（OSI）" class="headerlink" title="一、七层网络模型（OSI）"></a>一、七层网络模型（OSI）</h1><h2 id="1-1、物理层"><a href="#1-1、物理层" class="headerlink" title="1.1、物理层"></a>1.1、物理层</h2><blockquote><p><strong>为数据端设备提供原始比特流的传输的通路</strong>，传输的内容是 <strong>比特流（Bit）</strong></p></blockquote><h2 id="1-2、数据链路层"><a href="#1-2、数据链路层" class="headerlink" title="1.2、数据链路层"></a>1.2、数据链路层</h2><blockquote><p><strong>数据链路层最基本的服务是将源计算机网络层来的数据可靠的传输到相邻节点的目标计算机的网络层</strong>，数据链路层传输的数据是 <strong>帧（Framing）</strong></p></blockquote><ul><li>将数据封装成帧</li></ul><blockquote><p>数据链路层将网络层传递下来的 <strong>IP 数据报</strong> 进行包装，在数据前后分别添加帧头和帧尾，使其成帧，然后将帧转为比特流进行传输。</p><p>接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210811205736.png" alt="image-20210811205729828"></p><ul><li>透明传输</li></ul><blockquote><p>数据链路层实现透明传输和封装成帧时，<strong>使用到了转义字符</strong>。</p><p>由于<strong>帧的开始和结束的标记是使用专门指明的控制字符</strong>，因此，所传输的数据中的任何 8 比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210811205956.png" alt="image-20210811205956282"></p><ul><li>差错检测</li></ul><h2 id="1-3、网络层"><a href="#1-3、网络层" class="headerlink" title="1.3、网络层"></a>1.3、网络层</h2><blockquote><p>控制子网的运行，如逻辑编址、分组传输和路由选择，网络层<strong>负责在不同的网络之间(基于数据包的IP地址)尽力转发数据包，不负责丢包重传和接收顺序</strong>。</p></blockquote><h2 id="1-4、传输层"><a href="#1-4、传输层" class="headerlink" title="1.4、传输层"></a>1.4、传输层</h2><blockquote><p>传输层主要是提供<strong>不同主机</strong>上的<strong>进程之间</strong>的逻辑通信（端到端的通信），即使在不可靠的网络层（主机之间的逻辑通信）传输下，传输层也能提供可靠的传输。</p><p>(所谓的<strong>逻辑通信</strong>就是指：传输层之间看似是在水平方向传送数据，但是事实上这两个传输层之间并没有水平方向上的物理连接)</p><p>传输层对应的网络协议有 <strong>TCP</strong> 、 <strong>UDP</strong></p></blockquote><h2 id="1-5、会话层"><a href="#1-5、会话层" class="headerlink" title="1.5、会话层"></a>1.5、会话层</h2><blockquote><p>用于在不同机器上的用户之间建立并管理会话。</p><p>HTTPS 使用的 SSL/TLS 协议就在这一层。</p></blockquote><h2 id="1-6、表示层"><a href="#1-6、表示层" class="headerlink" title="1.6、表示层"></a>1.6、表示层</h2><h2 id="1-7、应用层"><a href="#1-7、应用层" class="headerlink" title="1.7、应用层"></a>1.7、应用层</h2><blockquote><p>运输层仅为应用进程提供了端到端的通信服务。但<strong>不同的网络应用的应用进程之间，还需要有不同的通信规则，因此还需要有应用层协议</strong></p><p>应用层对应的网络协议有：<strong>HTTP</strong>、<strong>FTP</strong>、<strong>SMTP</strong> 等</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813213033.png" alt="image-20210812094145539"></p><h1 id="二、IP-网络协议"><a href="#二、IP-网络协议" class="headerlink" title="二、IP 网络协议"></a>二、IP 网络协议</h1><h2 id="2-1、网络协议是什么？"><a href="#2-1、网络协议是什么？" class="headerlink" title="2.1、网络协议是什么？"></a>2.1、网络协议是什么？</h2><blockquote><p>IP 协议是TCP/IP协议族的核心协议，其主要包含两个方面：</p></blockquote><h3 id="1、IP-头部信息"><a href="#1、IP-头部信息" class="headerlink" title="1、IP 头部信息"></a>1、IP 头部信息</h3><blockquote><p>IP头部信息出现在每个IP数据报中，用于指定 IP 通信的源端 IP 地址、目的端 IP 地址，指导 IP 分片和重组，以及指定部分通信行为。</p></blockquote><h3 id="2、IP-数据报的路由和转发"><a href="#2、IP-数据报的路由和转发" class="headerlink" title="2、IP 数据报的路由和转发"></a>2、IP 数据报的路由和转发</h3><blockquote><p>IP 数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及如何转发。</p></blockquote><h2 id="2-2、IP-协议的特点"><a href="#2-2、IP-协议的特点" class="headerlink" title="2.2、IP 协议的特点"></a>2.2、IP 协议的特点</h2><blockquote><p>IP协议是TCP/IP协议族的动力，它为上层协议提供<strong>无状态、无连接、不可靠</strong>的服务。</p></blockquote><h3 id="1、无状态"><a href="#1、无状态" class="headerlink" title="1、无状态"></a>1、无状态</h3><blockquote><p>无状态是<strong>指 IP 通信双方不同步传输数据的状态信息</strong>，因此<strong>所有 IP 数据报的发送、传输和接收都是相互独立、没有上下文关系的</strong>。这种服务最大的缺点就是<strong>无法处理乱序和重复的IP数据报</strong>。</p><p>面向连接的协议（如 TCP ）协议，能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。无状态服务的优点也很明显：<strong>简单、高效</strong>。我们无需为保持通信的状态而分配一些内核资源，也无需每次传输数据时都携带状态信息。</p></blockquote><h3 id="2、无连接"><a href="#2、无连接" class="headerlink" title="2、无连接"></a>2、无连接</h3><blockquote><p>无连接是指IP通信双方都不长久地维持对方的任何信息。这样<strong>上层协议每次发送数据的时候，都必须明确指定对方的IP地址</strong>。</p></blockquote><h3 id="3、不可靠"><a href="#3、不可靠" class="headerlink" title="3、不可靠"></a>3、不可靠</h3><blockquote><p>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力。很多情况都可以导致IP数据报发送失败。因此，使用 IP 服务的上层协议需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p></blockquote><h1 id="三、TCP-协议"><a href="#三、TCP-协议" class="headerlink" title="三、TCP 协议"></a>三、TCP 协议</h1><h2 id="3-1、何谓协议？"><a href="#3-1、何谓协议？" class="headerlink" title="3.1、何谓协议？"></a>3.1、何谓协议？</h2><blockquote><p><strong>所谓协议，是指通信的双方，为了保证通信效果，特意在通信形式和内容上的一致协商</strong>。在计算机世界中，计算机与计算机之间的沟通更加抽象复杂，为了保证能够各种应用场景下的正确通信，众多计算机世界中的协议应运而生。</p><p><strong>这其中最重要的当属TCP协议和Http协议。</strong></p></blockquote><h2 id="3-2、TCP-协议概述"><a href="#3-2、TCP-协议概述" class="headerlink" title="3.2、TCP 协议概述"></a>3.2、TCP 协议概述</h2><blockquote><p>TCP，英文全称 Transmission control protocol，直译为：传输控制协议。</p><p>它是为了在<strong>不可靠</strong>的互联网上提供<strong>可靠</strong>的端到端字节流而专门设计的一个传输协议。</p></blockquote><ul><li>TCP 是面向连接（虚连接）的传输层协议</li><li>TCP 提供可靠交付的服务，无差错、不丢失、不重复、按序到达（不丢不重，可靠有序）</li></ul><blockquote><p>可靠指<strong>保证接收方进程从缓存区中读出的字节流和发送方发出的字节流是完全一样的。</strong></p></blockquote><ul><li>TCP 支持全双工通信，允许通信双方同时发送 / 接收数据，所以在双方都有设计发送缓存和接收缓存</li></ul><blockquote><p>发送缓存中存放<strong>准备发送的数据</strong>和 <strong>已经发送但接收方尚未确认收到的数据</strong></p><p>接收缓存中存放<strong>按序到达但尚未被接收方应用程序读取的数据</strong> 和 <strong>不按序到达的数据</strong></p></blockquote><h2 id="3-3、TCP-如何保证传输可靠性"><a href="#3-3、TCP-如何保证传输可靠性" class="headerlink" title="3.3、TCP 如何保证传输可靠性"></a>3.3、TCP 如何保证传输可靠性</h2><h3 id="1、检验和"><a href="#1、检验和" class="headerlink" title="1、检验和"></a>1、检验和</h3><blockquote><p>TCP 检验和的计算与 UDP 一样，在计算时要加上 12byte 的伪首部，检验范围包括 TCP 首部及数据部分，但是 UDP 的检验和字段为可选的，而TCP中是必须有的。</p><p>计算方法为：在发送方将整个报文段分为多个 16 位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如<strong>最终结果为检验字段所有位是全1则正确</strong>（UDP中为0是正确），否则存在错误。</p></blockquote><h3 id="2、序列号"><a href="#2、序列号" class="headerlink" title="2、序列号"></a>2、序列号</h3><blockquote><p>TCP将每个字节的数据都进行了编号，这就是序列号，序列号的作用如下</p></blockquote><ul><li>保证可靠性（当接收到的数据总共少了某个序号的数据时，可以马上知道）</li><li>保证数据的按序到达</li><li>提高效率，可实现多次发送，一次确认</li><li>去除重复数据</li></ul><blockquote><p>数据传输过程中的确认应答处理、重发控制以及重复控制等功能都可以通过序列号来实现</p></blockquote><h3 id="3、确认应答机制（ACK）"><a href="#3、确认应答机制（ACK）" class="headerlink" title="3、确认应答机制（ACK）"></a>3、确认应答机制（ACK）</h3><blockquote><p><strong>TCP 通过确认应答机制实现可靠的数据传输</strong>。</p><p><strong>在TCP的首部中有一个标志位——ACK，此标志位表示确认号是否有效</strong>。接收方对于按序到达的数据会进行确认，当标志位ACK=1时确认首部的确认字段有效。进行确认时，<strong>确认字段值表示这个值之前的数据都已经按序到达了</strong>。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而<strong>如果等待了一定时间还没有收到确认报文就会启动重传机制</strong>。</p></blockquote><ul><li>正常情况下的应答机制：</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813214252.png" alt="image-20210812101851348"></p><h3 id="4、超时重发机制"><a href="#4、超时重发机制" class="headerlink" title="4、超时重发机制"></a>4、超时重发机制</h3><blockquote><p>当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传（通常是在发出报文段后设定一个闹钟，到点了还没有收到应答则进行重传），有多种原因会导致发送方无法接收到接收端的 ACK</p></blockquote><ul><li>数据包在发送的过程中丢了，接收方压根没收到数据，自然无法确认</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813214400.png" alt="image-20210812101939342"></p><ul><li>接收方已经接收到了数据包，也向发送方发送了 ACK ，但 ACK 在发送过程中丢了</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813214412.png" alt="image-20210812102138526"></p><blockquote><p>当接收方接收到重复的数据时就将其丢掉，重新发送ACK。而要识别出重复的数据，就要用到前面提到的序列号了，<strong>利用序列号很容易就可以做到去重的效果</strong>。</p></blockquote><h3 id="5、连接管理机制"><a href="#5、连接管理机制" class="headerlink" title="5、连接管理机制"></a>5、连接管理机制</h3><blockquote><p>TCP 建立时，使用三次握手建立连接，保证双端的发送、接收消息的能力可以得到保证。</p><p>TCP 断开时，使用四次挥手断开连接</p></blockquote><h3 id="6、流量控制"><a href="#6、流量控制" class="headerlink" title="6、流量控制"></a>6、流量控制</h3><blockquote><p>接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，导致接收端的缓冲区满，而发送方继续发送，就会造成丢包，继而引起丢包重传等一系列连锁反应。<br>因此<strong>TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制叫做流量控制</strong>。</p></blockquote><h3 id="7、拥塞控制"><a href="#7、拥塞控制" class="headerlink" title="7、拥塞控制"></a>7、拥塞控制</h3><blockquote><p>流量控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。<br><strong>为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据</strong>。</p></blockquote><h2 id="3-4、TCP-IP-协议"><a href="#3-4、TCP-IP-协议" class="headerlink" title="3.4、TCP / IP 协议"></a>3.4、TCP / IP 协议</h2><blockquote><p>TCP / IP 协议全称为 <strong>传输控制协议 / 网络协议</strong>，是指能在多个不同网络间实现信息传输的协议族。</p><p>需要注意的是，TCP / IP 协议不仅仅指的是 TCP 和 IP 两个协议，而是指一个由 <strong>FTP</strong>、<strong>SMTP</strong>、<strong>TCP</strong>、<strong>UDP</strong> 、<strong>IP</strong> 等协议构成的协议族，只是因为在 TCP/IP 协议中 TCP 协议和 IP 协议最具代表性，所以被称为 TCP/IP 协议</p></blockquote><h2 id="3-5、TCP-连接管理"><a href="#3-5、TCP-连接管理" class="headerlink" title="3.5、TCP 连接管理"></a>3.5、TCP 连接管理</h2><h3 id="1、TCP-连接建立过程"><a href="#1、TCP-连接建立过程" class="headerlink" title="1、TCP 连接建立过程"></a>1、TCP 连接建立过程</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210920225730.png" alt="image-20210920174645245"></p><ul><li>阶段一</li></ul><blockquote><p>客户端发送<strong>连接请求报文段</strong>，<strong>无应用层数据</strong>，SYN = 1，seq = x （随机），seq 为序列号</p></blockquote><ul><li>阶段二</li></ul><blockquote><p>服务器端为该 TCP 连接<strong>分配缓存（发送缓存和接收缓存）</strong>和<strong>变量</strong>，并向客户端返回<strong>确认报文段</strong>，允许连接，<strong>无应用层数据</strong>， SYN = 1，<code>ACK = 1</code> （确认比特），seq = y（随机），<code>ack = x + 1</code> （确认号），当确认比特 ACK 为 1 时，确认号 <code>ack</code> 有效。</p></blockquote><ul><li>阶段三</li></ul><blockquote><p>客户端为该 TCP 连接<strong>分配缓存（发送缓存和接收缓存）</strong>和<strong>变量</strong>，并向服务端返回确认的确认，<strong>此时可以携带数据</strong>，<code>ACK = 1</code>，<code>seq = x + 1</code>，<code>ack = y + 1</code>，<code>SYN = 0</code></p></blockquote><h3 id="2、TCP-连接关闭过程"><a href="#2、TCP-连接关闭过程" class="headerlink" title="2、TCP 连接关闭过程"></a>2、TCP 连接关闭过程</h3><blockquote><p><strong>参与一条 TCP 连接的两个进程中的任何一个都能终止该连接</strong>，连接结束后，主机中的资源（缓存和变量）将被回收。</p><p>四次挥手的示意图如下，我们假设是客户端想终止本次连接。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210920225807.png" alt="image-20210920180208007"></p><ul><li>阶段一</li></ul><blockquote><p>客户端发送<strong>连接释放报文段</strong>，停止发送数据，主动关闭 TCP 连接，FIN = 1，seq = u</p></blockquote><ul><li>阶段二</li></ul><blockquote><p>服务端返回一个<strong>确认报文段</strong>，此时<strong>客户端到服务器这个方向的连接就被释放了</strong>，称为半关闭状态。</p><p><code>ACK = 1</code>，seq = v，<code>ack = u + 1</code></p></blockquote><ul><li>阶段三</li></ul><blockquote><p>服务端发送完数据，就发出连接释放报文段，主动关闭 TCP 连接，FIN = 1，ACK = 1，seq = w，<code>ack = u + 1</code></p></blockquote><ul><li>阶段四</li></ul><blockquote><p>客户端回送一个确认报文段，再等到时间等待计时器设置的 2MSL （最长报文段寿命）后，彻底关闭连接。ACK = 1，seq = u + 1，ack = w + 1</p></blockquote><ul><li>为什么要进行等待？</li></ul><blockquote><p>这是为了避免阶段四发送的确认报文段在发送途中丢失而导致服务端收不到。如果第四个报文段丢失，那么服务器会再次发送一个<strong>连接释放报文段</strong>，然后让客户端再发送一个确认报文段，此时时间计时器重置。</p></blockquote><h2 id="3-6、SYN-洪泛攻击"><a href="#3-6、SYN-洪泛攻击" class="headerlink" title="3.6、SYN 洪泛攻击"></a>3.6、SYN 洪泛攻击</h2><blockquote><p><strong>SYN 洪泛攻击发生在 OSI 第四层（传输层），这种方式利用 TCP 的特性，也就是第三次握手</strong>。</p><p>攻击者发送 TCP SYN，SYN 是 TCP 三次握手中的<strong>第一个数据包</strong>，当服务器返回 ACK 后，该攻击者就不对其进行再次确认，那么这个 TCP 连接就会处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送 ACK 给攻击者，这样会更加浪费服务器的资源。</p><p>攻击者会根据这个特性发送大量类似这样的 TCP 连接，由于每一个都无法完成三次握手，所以在服务器上，这些 TCP 连接会因为挂起这种状态而消耗 CPU 和内存，最后服务器可能死机，也就无法为正常用户提供服务了。</p></blockquote><h2 id="3-7、TCP-的滑动窗口"><a href="#3-7、TCP-的滑动窗口" class="headerlink" title="3.7、TCP 的滑动窗口"></a>3.7、TCP 的滑动窗口</h2><blockquote><p>为了简单起见，我们现在假设有两台主机，由 A 发出数据， B 接受数据，此时数据的发送仅限于两个窗口，即 A 的发送窗口， B 的接收窗口， <strong>TCP 的窗口是以字节为单位的</strong>，我们假设 A 中有如下图显示的数据，每个小格子代表一个字节</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210924194504.png" alt="image-20210924194456996"></p><ul><li>此时，接收方 B 给 A 发送一个 ACK ， <strong>ACK 报文段中的滑动窗口的值 rwnd 为 20 ，ack 的值为31</strong></li></ul><blockquote><p>这表示告诉发送端，我可以接收的数据长度为 20 ，同时期望收到的数据从 31 开始</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210924194724.png" alt="image-20210924194724661"></p><ul><li>当 A 接收到 B 的确认报文后，它就可以根据这个报文段中的信息（ack = 31、rwnd = 20）构造出它的发送窗口，即从 31 开始长度为 20 的报文段，如图所示</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210924194942.png" alt="image-20210924194942670"></p><blockquote><p>此时我们假设网络中不存在拥塞情况，即发送方的发送窗口为接收方的接收窗口，不考虑拥塞窗口</p></blockquote><ul><li>对于尚未确认的数据，我们不能立即删除，而是要缓存起来留待超时重发使用，<strong>我们将发送窗口的左边界称为后沿，发送窗口右边界表示前沿</strong></li></ul><blockquote><p>处于发送后沿左边的数据表示已经发送且收到确认的数据，这部分数据可以删除，而处于发送前沿右边的数据表示不允许发送的数据</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210924195506.png" alt="image-20210924195506099"></p><blockquote><p>发送窗口后沿的移动情况存在两种可能</p></blockquote><ol><li>不动（此时表示没有收到新的确认）</li><li>前移（收到了新的确认）</li></ol><blockquote><p>发送窗口前沿的移动情况存在三种可能</p></blockquote><ol><li>通常是不断向前移动</li><li>不动<ol><li>没有收到新的确认，对方通知的窗口大小不变</li><li>收到了新确认，但对方通知的窗口大小改变了，使得发送窗口前沿刚好不动</li></ol></li><li>向后收缩（对方通知的窗口缩小了）</li></ol><blockquote><p>TCP 强烈不建议这样做</p></blockquote><ul><li>发送窗口的滑动</li></ul><blockquote><p>在接收方接收到 31 32 33 数据后，此时它会给发送方返回一个 ACK ，同时将自己的接收窗口向右移动</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210924200840.png" alt="image-20210924200840190"></p><blockquote><p>在发送方收到 ACK 后，它将自己的发送窗口向右移动，此时 34 - 53 落入发送窗口中，然后发送方删除已经发送且收到确认的数据</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210924200928.png" alt="image-20210924200928757"></p><h1 id="四、UDP-协议"><a href="#四、UDP-协议" class="headerlink" title="四、UDP 协议"></a>四、UDP 协议</h1><h2 id="4-1、介绍"><a href="#4-1、介绍" class="headerlink" title="4.1、介绍"></a>4.1、介绍</h2><blockquote><p>UDP 是 User Datagram Protocol 的简称， 中文名是用户数据报协议，是 OSI<br>（Open System Interconnection，开放式系统互联） 参考模型中一种<strong>无连接</strong>的<strong>传输层协议</strong>，提供<strong>面向事务</strong>、<strong>基于字符</strong>的<strong>简单不可靠信息</strong>传送服务</p></blockquote><h2 id="4-2、特点"><a href="#4-2、特点" class="headerlink" title="4.2、特点"></a>4.2、特点</h2><ul><li>相比于 TCP ，UDP 的传输效率更高，消耗的资源也更少</li><li>UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的（不可靠，尽最大努力交付）</li><li>UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议。</li></ul><h2 id="4-3、UDP-与-TCP-的区别"><a href="#4-3、UDP-与-TCP-的区别" class="headerlink" title="4.3、UDP 与 TCP 的区别"></a>4.3、UDP 与 TCP 的区别</h2><h3 id="1、概念说明"><a href="#1、概念说明" class="headerlink" title="1、概念说明"></a>1、概念说明</h3><blockquote><p>UDP 和 TCP 均位于网络模型的运输层，都是 socket 通信的两种协议</p></blockquote><ul><li>TCP是一种面向连接、全双工可靠、基于字节的传输层协议，TCP 只支持点对点通信，相当于在通信双方之间建立了一条可以双向通信的通道。</li><li>UDP 是一种无连接、不可靠、基于报文的传输层协议，UDP 支持一对多、多对一、多对多、一对一通信，UDP 只管发送，不管接收，也不会对接收到的包进行校验排序。</li></ul><h3 id="2、优缺点"><a href="#2、优缺点" class="headerlink" title="2、优缺点"></a>2、优缺点</h3><table><thead><tr><th>类型</th><th>安全</th><th>有序</th><th>速度</th><th>对象个数</th><th>开销</th><th>方式</th></tr></thead><tbody><tr><td>TCP</td><td>安全</td><td>有序</td><td>慢</td><td>1:1</td><td>大</td><td>面向字节流</td></tr><tr><td>UDP</td><td>不安全</td><td>无序</td><td>快</td><td>1:1，1:N，N:N，N:1</td><td>小</td><td>面向报文</td></tr></tbody></table><ul><li>传输速度</li></ul><blockquote><p>TCP：慢，必须等待上一个数据包传输完，下一个才能传输。</p><p>UDP：块，UDP 可以不管接收方的接收情况，连续发送数据包</p></blockquote><ul><li>开销</li></ul><blockquote><p>TCP开销较大，首部有 20 个字节，而UDP 开销较小，首部只有八个字节</p></blockquote><h3 id="3、TCP-UDP-比较总结"><a href="#3、TCP-UDP-比较总结" class="headerlink" title="3、TCP UDP 比较总结"></a>3、TCP UDP 比较总结</h3><ul><li>是否面向连接</li></ul><blockquote><p>TCP 是面向连接的传输层协议，在进行通信前需要使用三次握手建立连接（只有第三次握手才能携带数据），在完成通信后需要使用四次挥手断开连接。</p><p>而 UDP 是无连接的。</p></blockquote><ul><li>通信对象</li></ul><blockquote><p>TCP 仅支持点对点通信，而 UDP 既支持单播，也支持多播。</p></blockquote><ul><li>传输的数据格式</li></ul><blockquote><p>TCP 是<strong>面向字节流</strong>的，TCP 在数据的发送和接收过程中会涉及拆分和合并，<strong>面向字节流是 TCP 实现可靠传输、流量控制和拥塞控制的基础</strong>。</p><p>UDP 对应用进程交下来的报文既不拆分也不合并，它是<strong>面向应用报文</strong>的。</p></blockquote><ul><li>应用场景</li></ul><blockquote><p>TCP 向上层提供面向连接的可靠服务，需要传输大量数据且对可靠性要求高的情况下使用 TCP，如：文件传输。</p><p>UDP 向上层提供无连接不可靠的服务，对实时性要求高和高速传输的场合下使用UDP，在可靠性要求低，追求效率的情况下使用UDP，如：视频会议。</p></blockquote><ul><li>两个协议的首部不同</li></ul><h1 id="五、HTTP-协议"><a href="#五、HTTP-协议" class="headerlink" title="五、HTTP 协议"></a>五、HTTP 协议</h1><h2 id="5-1、协议简介"><a href="#5-1、协议简介" class="headerlink" title="5.1、协议简介"></a>5.1、协议简介</h2><blockquote><p>HTTP 全称为超文本传输协议（<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。</p><p>HTTP 是一种能够获取如 HTML 这样的网络资源的协议，<strong>是一种 Client-Server 协议</strong>。</p></blockquote><h2 id="5-2、HTTP-协议概述"><a href="#5-2、HTTP-协议概述" class="headerlink" title="5.2、HTTP 协议概述"></a>5.2、HTTP 协议概述</h2><blockquote><p>HTTP 协议中，客户端发起一个 HTTP 请求到服务器的指定端口（默认端口为 80），而后服务器用户需要的资源以 HTTP 响应的方式返回给客户端，我们将这个客户端称为用户代理（user agent），用户代理通常是浏览器，也可以是爬虫。</p><p>HTTP 协议中并没有规定必须使用它或它支持的层。因此，HTTP 可以在任何互联网协议上，或其他网络上实现，<strong>HTTP 假定其下层协议提供可靠的传输</strong>。</p><p>因此，任何能够提供这种保证的协议都可以被其使用，所以，在 TCP/IP 协议族中，我们使用 TCP 作为传输层协议。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p></blockquote><h2 id="5-3、HTTP-工作原理"><a href="#5-3、HTTP-工作原理" class="headerlink" title="5.3、HTTP 工作原理"></a>5.3、HTTP 工作原理</h2><blockquote><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。</p><p><strong>HTTP 协议采用了请求/响应模型</strong>，客户端向服务器发送一个请求报文，请求报文中包含请求方法、URL 、协议版本、请求头和请求数据。</p><p>服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813215141.png" alt="image-20210812150114787"></p><blockquote><p>在客户端和服务端中，还有许许多多被称为 proxies 的实体，它们主要有以下几种作用：</p></blockquote><ul><li>缓存（可以是公开的也可以是私有的，像浏览器的缓存）</li><li>过滤（像反病毒扫描，家长控制…）</li><li>负载均衡（让多个服务器服务不同的请求）</li><li>认证（对不同资源进行权限管理）</li><li>日志记录（允许存储历史信息）</li></ul><h2 id="5-4、HTTP-请求-响应步骤"><a href="#5-4、HTTP-请求-响应步骤" class="headerlink" title="5.4、HTTP 请求 / 响应步骤"></a>5.4、HTTP 请求 / 响应步骤</h2><ul><li>客户端连接到 WEB 服务器</li></ul><blockquote><p>一个 HTTP 客户端（通常是浏览器），与 WEB 服务器的 HTTP 端口建立一个 TCP 套接字（socket）连接。</p></blockquote><ul><li>发送 HTTP 请求</li></ul><blockquote><p>通过 TCP 套接字，客户端向 WEB 服务器发送一个文本的请求报文，一个<strong>请求报文由请求方法、URL 、协议版本、请求头和请求数据组成</strong></p></blockquote><ul><li>服务器接收 HTTP 请求并返回 HTTP 响应</li></ul><blockquote><p>WEB 服务器处理请求，然后响应用户，返回一个 HTTP 响应，响应的内容包括<strong>协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据</strong></p></blockquote><ul><li>客户端接收响应并解析 HTTP 响应</li></ul><h2 id="5-5、HTTP-特点"><a href="#5-5、HTTP-特点" class="headerlink" title="5.5、HTTP 特点"></a>5.5、HTTP 特点</h2><ul><li>基于 <strong>请求 - 响应</strong> 的模式</li></ul><blockquote><p>HTTP 协议规定，<strong>请求从客户端发出,最后服务器端响应该请求并返回</strong>。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应</p></blockquote><ul><li>无状态保存（服务端不保存任何客户端请求者信息）</li></ul><blockquote><p><strong>HTTP 是一种不保存状态，即无状态(stateless)协议</strong>。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，<strong>协议对于发送过的请求或响应都不做持久化处理</strong>。</p></blockquote><ul><li>无连接</li></ul><blockquote><p>无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。</p><p>无连接有两种方式，早期的 HTTP 协议接收一个请求，返回一个响应后，连接直接断开；</p><p>在 HTTP 1.1 后引入了 Keep-Alive 模式，这个模式默认开启，在开启后，连接会等到 Keep-Alive 时间过期后再关闭，此时在 Keep-Alive 时间内有新的请求过来，那么就可以复用原来的连接通道。</p></blockquote><ul><li>明文传输</li></ul><blockquote><p>HTTP 明文传输，数据都是未加密的，安全性较差，一些别有用心的人可以对传输的数据进行监听、篡改</p></blockquote><h2 id="5-6、HTTP-之-URL"><a href="#5-6、HTTP-之-URL" class="headerlink" title="5.6、HTTP 之 URL"></a>5.6、HTTP 之 URL</h2><blockquote><p>HTTP 使用<strong>统一资源标识符</strong>（Uniform Resource Identifiers， URI）来传输数据和建立连接。URL是一种特殊类型的 URI，包含了用于查找某个资源的足够的信息</p><p>一个完整的 URL 包括以下几个部分，以 <a target="_blank" rel="noopener" href="http://www.example.com/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument">http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument</a> 为例</p></blockquote><ul><li>协议</li></ul><blockquote><p><code>http://</code> 告诉浏览器该请求使用何种协议，对于大部分资源，通常使用 HTTP 协议或者 HTTPS 协议</p><p>同时浏览器也可以处理其他请求，如 <code>ws://</code> 表示 <code>websocket</code> 协议，<code>ftp:</code>协议指示浏览器处理文件传输。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813215158.png" alt="image-20210813111126342"></p><ul><li>主机（host）</li></ul><blockquote><p>在上面的 url 中，<code>www.example.com</code> 是一个域名，它指示了浏览器需要向网络上的哪一台主机发送请求，我们也可以直接向主机的 IP 地址直接发起请求。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813215203.png" alt="image-20210813111311032"></p><ul><li>端口（port）</li></ul><blockquote><p>两个主机发起 TCP 连接需要两个条件，即主机 + 端口。它表示用于访问 web 服务器上资源的入口。</p><p>如果访问的目标服务器使用 HTTP 协议的默认端口（80），那么就可以省略端口不写，否则端口是 URI 的必要部分</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813215208.png" alt="image-20210813111543024"></p><ul><li>虚拟路径</li></ul><blockquote><p><code>/path/to/myfile.html</code> 是 Web 服务器上资源的路径。以端口后面的第一个 <code>/</code> 开始，到 <code>?</code> 号之前结束，中间的 每一个<code>/</code> 都代表了层级（上下级）关系。这个 URL 的请求资源是一个 html 页面。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813215212.png" alt="image-20210813111615295"></p><ul><li>查询参数</li></ul><blockquote><p><code>?key1=value1&amp;key2=value2</code> 是提供给 Web 服务器的额外参数。如果是 GET 请求，一般带有请求 URL 参数，如果是 POST 请求，则不会在路径后面直接加参数。这些参数是用 &amp; 符号分隔的键/值对列表。key1 = value1 是第一对，key2 = value2 是第二对参数</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813215217.png" alt="image-20210813111704087"></p><ul><li>锚点</li></ul><blockquote><p>#SomewhereInTheDocument 是资源本身的某一部分的一个锚点。<strong>锚点代表资源内的一种“书签”</strong>，它给予浏览器显示位于该“加书签”点的内容的指示。 例如，在HTML文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。</p><p><strong>值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器</strong>。</p></blockquote><h1 id="六、HTTPS-协议"><a href="#六、HTTPS-协议" class="headerlink" title="六、HTTPS 协议"></a>六、HTTPS 协议</h1><h2 id="6-1、协议简介"><a href="#6-1、协议简介" class="headerlink" title="6.1、协议简介"></a>6.1、协议简介</h2><blockquote><p>HTTPS 即 Hypertext Transfer Protocol <code>Secure</code>，是一个专门在两点之间<code>安全</code>的传输文字、图片、音频、视频等超文本数据的约定和规范。</p><p><strong>HTTPS 是 HTTP 协议的一种扩展，它本身并不保证传输的安全性，使用TLS/SSL对通信协议进行加密</strong>。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813223351.png" alt="image-20210813223351603"></p><blockquote><p>TLS / SSL 是介于 TCP 与 HTTP 之间的安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813223436.png" alt="image-20210813223436666"></p><h2 id="6-2、为什么要使用-HTTPS"><a href="#6-2、为什么要使用-HTTPS" class="headerlink" title="6.2、为什么要使用 HTTPS ?"></a>6.2、为什么要使用 HTTPS ?</h2><h3 id="1、HTTP-协议存在的风险"><a href="#1、HTTP-协议存在的风险" class="headerlink" title="1、HTTP 协议存在的风险"></a>1、HTTP 协议存在的风险</h3><blockquote><p>这是<strong>因为HTTP 是明文传输，所以HTTP 不安全，主要存在三大风险</strong></p></blockquote><ul><li>窃听风险</li></ul><blockquote><p>中间人可以获取到通信内容，由于内容是明文，所以获取明文后有安全风险</p></blockquote><ul><li>篡改风险</li></ul><blockquote><p>中间人可以篡改报文内容后再发送给对方，风险极大</p></blockquote><ul><li>冒充风险</li></ul><h3 id="2、HTTPS-如何解决以上问题？"><a href="#2、HTTPS-如何解决以上问题？" class="headerlink" title="2、HTTPS 如何解决以上问题？"></a>2、HTTPS 如何解决以上问题？</h3><ul><li>使用<code>混合加密</code>的方式实现信息的机密性，解决了窃听的风险</li><li><code>摘要算法</code>的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<code>数字证书</code>中，解决了冒充的风险。</li></ul><h2 id="6-3、加密算法"><a href="#6-3、加密算法" class="headerlink" title="6.3、加密算法"></a>6.3、加密算法</h2><blockquote><p>加密算法大致可分为两种，分别是 <strong>对称加密</strong> 和 <strong>非对称加密</strong></p></blockquote><h3 id="1、对称加密"><a href="#1、对称加密" class="headerlink" title="1、对称加密"></a>1、对称加密</h3><ul><li>对称加密中，加密和解密的密钥使用的是同一个</li><li>优点</li></ul><blockquote><p>算法公开、计算量小、加密速度快、加密效率高</p></blockquote><ul><li>缺点</li></ul><ol><li><p>在数据传送前，发送方和接收方必须商定好秘钥，双方都能保存好秘钥。<strong>如果一方的秘钥被泄露，那么加密信息也就不安全了</strong>。</p></li><li><p>每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p></li></ol><blockquote><p>同时，由于 HTTP 是使用明文传输的，所以如果有人在传输密钥的过程中进行窃听，那么其他人取到密钥后，对称加密就失去了意义。</p><p>此时就算对密钥进行加密，在传输过程中仍然可能被截获，所以这种做法是不可行的</p></blockquote><h3 id="2、非对称加密"><a href="#2、非对称加密" class="headerlink" title="2、非对称加密"></a>2、非对称加密</h3><blockquote><p>用于解决单向对称密钥的传输问题。</p></blockquote><ul><li>在非对称加密中，公开密钥和私有密钥是一对，如果<strong>使用公钥进行加密，那么只有用对应的私钥才能解密</strong></li><li>反之亦然，<strong>如果使用私钥进行加密，那么只有使用对应的公钥才能解密</strong>。</li></ul><blockquote><p>由于加密和解密使用的是两个不同的密钥，所以这种算法叫作<code>非对称加密算法</code>。</p></blockquote><ul><li>信息交换过程</li></ul><blockquote><p>甲方生成一对密钥并将其中的一把作为<code>公用密钥</code>向大家公开；乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用私钥对加密后的信息进行解密。</p></blockquote><ul><li>优点：安全</li><li>缺点</li></ul><ol><li>速度较慢</li><li>直接传输公钥可能被中间人掉包</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813222556.png" alt="image-20210813222556618"></p><h3 id="3、HTTPS-的加密方式"><a href="#3、HTTPS-的加密方式" class="headerlink" title="3、HTTPS 的加密方式"></a>3、HTTPS 的加密方式</h3><ul><li>HTTPS 使用<strong>混合加密</strong>的方式来保证安全</li></ul><ol><li>在<code>交换密钥环节</code>使用<code>非对称密钥</code>加密方式，其中交换公钥利用第三方机构颁发的数字证书。</li><li>建立通信之后的<code>交换报文</code>阶段则使用<code>对称密钥</code>加密方式。</li></ol><ul><li>为什么使用混合加密？</li></ul><ol><li>对称加密比非对称加密快</li><li>非对称加密比对称加密安全</li></ol><blockquote><p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。</p></blockquote><h2 id="6-4、HTTPS-连接方式"><a href="#6-4、HTTPS-连接方式" class="headerlink" title="6.4、HTTPS 连接方式"></a>6.4、HTTPS 连接方式</h2><ul><li>客户端向服务器发送一个请求</li><li>服务器发送一个 SSL 证书给客户端，内容包括</li></ul><ol><li>证书的发布机构</li><li>有效期</li><li>所有者</li><li>签名以及公钥</li></ol><ul><li>客户端对发来的公钥进行真伪校验，校验结果为真则使用公钥对对称加密算法以及对称密钥进行加密</li><li>服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端</li><li>随后客户端和服务端就使用对称密钥进行信息传输</li></ul><h2 id="6-5、HTTP-与-HTTPS-的区别"><a href="#6-5、HTTP-与-HTTPS-的区别" class="headerlink" title="6.5、HTTP 与 HTTPS 的区别"></a>6.5、HTTP 与 HTTPS 的区别</h2><h3 id="1、安全性"><a href="#1、安全性" class="headerlink" title="1、安全性"></a>1、安全性</h3><ul><li>HTTP 使用明文传输，数据都是未加密的，安全性较差</li><li>HTTPS (TLS / SSL + HTTP)，使用混合加密来对数据进行加密，安全性较好</li></ul><h3 id="2、CA-证书"><a href="#2、CA-证书" class="headerlink" title="2、CA 证书"></a>2、CA 证书</h3><ul><li>使用 HTTPS 协议需要到数字证书认证机构申请证书</li></ul><h3 id="3、响应效率"><a href="#3、响应效率" class="headerlink" title="3、响应效率"></a>3、响应效率</h3><ul><li>HTTP 的响应速度比 HTTPS 快，这是因为 HTTP 使用 TCP 三次握手建立连接，客户端与服务端只需要交换三个包</li><li>而 HTTPS 除了 TCP 三个包外，还需要加上 SSL 握手需要的 9 个包</li></ul><h3 id="4、连接方式、端口和资源消耗"><a href="#4、连接方式、端口和资源消耗" class="headerlink" title="4、连接方式、端口和资源消耗"></a>4、连接方式、端口和资源消耗</h3><ul><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 比 HTTP 更消耗服务器资源</li></ul><h2 id="6-6、GET-和-POST-请求的区别"><a href="#6-6、GET-和-POST-请求的区别" class="headerlink" title="6.6、GET 和 POST 请求的区别"></a>6.6、GET 和 POST 请求的区别</h2><ul><li>GET 请求是幂等的，POST 请求不是幂等的</li><li>GET 请求的刷新是对浏览器无害的，而 POST 请求的刷新会被重新提交</li><li>GET 一般用于获取数据，POST 一般用于将数据发送到后台</li><li>GET 请求也可以传参数到后台，这些参数会在 URL 栏中可见，隐私性和安全性比较差，同时由于参数存放在 URL 中，所以 GET 请求提交的数据会有长度限制（这一般是浏览器或者服务器的原因，与请求方法无关）</li></ul><blockquote><p>GET 请求会被保存在浏览器的历史记录和网站的访问记录中，而 POST 不会。</p></blockquote><ul><li>POST 请求可以将请求参数放在 RequestBody 中，它不会展示在 URL 中</li></ul><blockquote><p>POST 请求其实也是不安全的，这是因为 HTTP 是明文传输</p></blockquote><ul><li>GET 请求会被浏览器主动缓存，而 POST 请求不会被缓存（除非手动设置）</li><li>GET 请求只能进行 URL 编码，而 POST 请求支持多种编码方式</li><li>GET 请求一般通过 URL 地址栏请求，而 POST 通常通过表单发送数据请求</li></ul><h2 id="6-7、误区说明"><a href="#6-7、误区说明" class="headerlink" title="6.7、误区说明"></a>6.7、误区说明</h2><ul><li>GET 请求会产生一个 TCP 数据包，而 POST 会产生两个 TCP 数据包？</li></ul><blockquote><p>网上给出的说法是：</p></blockquote><ul><li>GET 请求会将请求 header 和 data 一起发送出去，服务端响应 200 后，请求成功。</li><li>对于 POST 请求，浏览器会先发送 http header 给服务端，告诉服务端等一下有数据传输过来，而服务端响应 100 continue，告诉浏览器服务端已经准备好接收数据，浏览器再发送请求 data 给服务端，服务端响应 200 请求成功</li></ul><blockquote><p>这种说法实际上不太严谨，<strong>POST 请求中多发的报文是客户端对 http 的 POST 和 GET 的请求策略决定的，其目的是为了避免资源带宽浪费</strong>，客户端会在发送 header 时添加 except 100 去探路，如果失败了，就不再发送 data ，从而减少资源浪费。</p><p>所以是否再发送一个包取决了客户端的实现策略，比如说 <code>firefox</code> 浏览器的 POST 请求只会发送一个包，与 POST 请求本身无关</p></blockquote><h1 id="七、WebSocket-协议"><a href="#七、WebSocket-协议" class="headerlink" title="七、WebSocket 协议"></a>七、WebSocket 协议</h1><h2 id="7-1、HTTP-协议的缺陷"><a href="#7-1、HTTP-协议的缺陷" class="headerlink" title="7.1、HTTP 协议的缺陷"></a>7.1、HTTP 协议的缺陷</h2><blockquote><p>在 Http 协议中，<strong>通信只能由客户端发起</strong>，在一些场景下，这种单项请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。</p><p>对于这个缺陷，我们可以使用 <strong>轮询</strong> 来解决，即每隔一段时间便发出一个请求，了解服务器是否有新的信息，最典型的场景就是聊天室。</p></blockquote><ul><li>轮询的效率低，非常浪费资源</li><li>HTTP 中的轮询又分为长轮询与短轮询</li></ul><ol><li>短轮询指使用 AJAX 定时发送请求，接收服务端响应</li><li>长轮询指浏览器请求到服务器后，连接一直打开，直到服务端有数据可发送，在发送完数据后，关闭连接。</li></ol><h2 id="7-2、WebSocket-协议概述"><a href="#7-2、WebSocket-协议概述" class="headerlink" title="7.2、WebSocket 协议概述"></a>7.2、WebSocket 协议概述</h2><blockquote><p>WebSocket 是 Web 浏览器和服务器之间的一种<strong>全双工通信协议</strong>，一旦 Web 客户端与服务端建立起连接后，之后的全部数据通信都通过这个连接进行，双方可以通过这个连接自由地传递信息，并且这个连接会持续存在直到客户端或者服务端的某一方主动关闭连接。</p><p>WebSocket 本质上是一个基于 TCP 的协议，它是一个应用层协议。</p></blockquote><h2 id="7-3、WebSocket-协议与-Http-协议的区别"><a href="#7-3、WebSocket-协议与-Http-协议的区别" class="headerlink" title="7.3、WebSocket 协议与 Http 协议的区别"></a>7.3、WebSocket 协议与 Http 协议的区别</h2><h3 id="1、相同点"><a href="#1、相同点" class="headerlink" title="1、相同点"></a>1、相同点</h3><ul><li>都是基于 TCP 的应用层协议</li><li>都是用 Request / Response 模型进行连接的建立</li><li>在连接建立过程中对错误的处理方式相同，在这个阶段 WS 可能返回和 HTTP 相同的返回码</li><li>都可以在网络中传输数据</li></ul><h3 id="2、不同之处"><a href="#2、不同之处" class="headerlink" title="2、不同之处"></a>2、不同之处</h3><ul><li><p>WS 使用 HTTP 来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用；</p></li><li><p>WS的连接不能通过中间人来转发，它必须是一个直接连接；</p></li><li><p>WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据；</p></li><li><p>WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息；</p></li><li><p>WS的数据帧有序。</p></li></ul><h3 id="3、通信过程"><a href="#3、通信过程" class="headerlink" title="3、通信过程"></a>3、通信过程</h3><ul><li>HTTP 的通信过程可以表示为下图，Http 的每次通信都以 Request / Response 模型进行</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/image-20210907202028048.png" alt="image-20210907202028048"></p><ul><li>WebSocket 的通信过程如下，除了建立连接时使用 Reqeust / Response 模型外，其余通信时间都是基于帧来传输数据</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/image-20210907202359560.png" alt="image-20210907202359560"></p><h2 id="7-4、WebSocket-的握手"><a href="#7-4、WebSocket-的握手" class="headerlink" title="7.4、WebSocket 的握手"></a>7.4、WebSocket 的握手</h2><blockquote><p>WebSocket 连接的建立需要借助 Http，在进行以此 HTTP 握手后，脱离 HTTP 协议使用 WebSocket 进行通信</p></blockquote><ul><li>客户端发出握手请求，然后服务器进行运算，将运算结果发送给客户端</li><li>客户端接收到运算结果后，讲起与本地的数据进行比对，如果一致，那么说明此时握手成功</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/image-20210907201223669.png" alt="image-20210907201223669"></p><blockquote><p>在握手时，WebSocket 的握手数据会被 HTTP 服务器当成 HTTP 包来处理，这里主要使用 Update Reqeust Http 包建立起连接，之后的通信全部使用 WebSocket 协议。</p></blockquote><ul><li>握手请求的 HTTP 请求报文头如下</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /HTTP/1.1</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: xxx</span><br><span class="line">Origin: xxx</span><br><span class="line">Sec-WebSocket-Key: xxxx</span><br><span class="line">Sec-WebSocket-Version: xxxxx</span><br></pre></td></tr></table></figure><ol><li>Connection 必须设置为 Upgrade ，表示客户端希望连接升级</li><li>Upgrade 必须设置为 websocket ，表示在取得服务器响应后，使用 HTTP 升级将 HTTP 协议升级为 WebSocket 协议</li><li>Sec-WebSocket-Key 为一个随机字符串，用于验证协议是否为WebSocket协议而非HTTP协议，这个字符串由浏览器随机生成，用于防止恶意或者无意的连接。</li><li>Sec-WebSocket-Version 表示使用WebSocket的哪一个版本。</li></ol><ul><li>握手请求的服务器回应如下</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: xxxx</span><br><span class="line">Sec-WebSocket-Version: xxxxx</span><br></pre></td></tr></table></figure><blockquote><p><code>HTTP/1.1 101 Switching Protocols</code> 中， 101 状态码表示协议升级，在返回101状态码后，HTTP协议完成工作，转换为WebSocket协议。此时就可以进行全双工双向通信了。</p></blockquote><ul><li>服务器与 Web 客户端建立连接，如果这个连接建立失败，那么不会执行后面的操作，Web 客户端会收到错误消息通知。</li></ul><h2 id="7-5、WebSocket-的缺点"><a href="#7-5、WebSocket-的缺点" class="headerlink" title="7.5、WebSocket 的缺点"></a>7.5、WebSocket 的缺点</h2><ul><li>服务器长期维护长连接需要一定的成本</li><li>各个浏览器支持程度不一</li><li>WebSocket 是长连接，受网络限制比较大，需要处理好重连</li></ul><h1 id="八、为什么网络需要分层？"><a href="#八、为什么网络需要分层？" class="headerlink" title="八、为什么网络需要分层？"></a>八、为什么网络需要分层？</h1><blockquote><p>复杂的系统需要分层，让每一层都专注做一类事情，网络分层也是为了这样，分层的具体原因如下</p></blockquote><ul><li>让各层之间相互独立</li></ul><blockquote><p>分层之后，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能即可（计算机网络中，下层为上层提供服务）。</p></blockquote><ul><li>提高了整体灵活性</li></ul><blockquote><p>每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。</p></blockquote><ul><li>大事化小</li></ul><blockquote><p>分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。<strong>这样使得复杂的计算机网络系统变得易于设计，实现和标准化</strong>。</p><p>同时，网络分层有助于各个部件的开发、设计及故障排除。</p></blockquote><ul><li>便于扩展</li></ul><blockquote><p><strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</strong></p><p>当我们需要实现一个新功能或者新需求时，可以通过增加中间层来解决，比如说 HTTPS 相比为 HTTP ，它中间添加了会话层的 SSL 协议来完成加密。</p></blockquote><h1 id="九、DNS"><a href="#九、DNS" class="headerlink" title="九、DNS"></a>九、DNS</h1><h2 id="9-1、概念说明"><a href="#9-1、概念说明" class="headerlink" title="9.1、概念说明"></a>9.1、概念说明</h2><h3 id="1、域名"><a href="#1、域名" class="headerlink" title="1、域名"></a>1、域名</h3><blockquote><p><strong>域名</strong>（英语：<strong>Domain Name</strong>），又称<strong>网域</strong>，是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称.</p><p>由于 IP 地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，所以人们设计了域名</p></blockquote><h3 id="2、域名服务器"><a href="#2、域名服务器" class="headerlink" title="2、域名服务器"></a>2、域名服务器</h3><ul><li>本地域名服务器</li></ul><blockquote><p>当一个主机发出 DNS 查询请求时，这个查询请求报文就发给本地域名服务器。</p></blockquote><ul><li>权限域名服务器</li></ul><blockquote><p>管理自己域名下主机的 IP 地址</p></blockquote><ul><li>顶级域名服务器</li></ul><blockquote><p>管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址</p></blockquote><ul><li>根域名服务器</li></ul><blockquote><p>根域名服务器是最核心最大的域名服务器，它管理顶级域名服务器，返回 <code>com</code>、 <code>net</code>、 <code>cn</code> 等顶级域名服务器的 IP 地址</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210920230215.png" alt="image-20210920185755871"></p><h3 id="3、DNS"><a href="#3、DNS" class="headerlink" title="3、DNS"></a>3、DNS</h3><blockquote><p><strong>域名系统</strong>（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为<strong>将域名和IP地址相互映射的一个分布式数据库</strong>，能够使人更方便地访问互联网。</p></blockquote><h3 id="4、DNS-缓存"><a href="#4、DNS-缓存" class="headerlink" title="4、DNS 缓存"></a>4、DNS 缓存</h3><blockquote><p>如果全世界的域名解析都往这个系统里挤，这个系统可能被挤瘫痪了，即使不瘫痪，解析速度也会大打折扣，所以 DNS 采取了一种非常有效的手段来解决这个问题： <strong>缓存</strong>。</p><p>域名缓存有以下两种方式：</p></blockquote><ul><li>非权威域名服务器（本地域名服务器）缓存：</li></ul><blockquote><p>各大运营服务商或大公司都有自己的 DNS 服务器，一般部署在距离用户较近地方，代替用户用户访问核心 DNS 系统，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址</p></blockquote><ul><li>本地计算机缓存</li></ul><ol><li>浏览器缓存</li></ol><blockquote><p>浏览器在获取某一网站域名的实际 IP 地址后，进行缓存，之后遇到同一域名查询之前的缓存结果即可，有效减少网络请求的损耗。</p><p>每种浏览器都有一个固定的 DNS 缓存时间。</p></blockquote><ol start="2"><li>操作系统缓存</li></ol><blockquote><p>操作系统里有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是 <code>/etc/hosts</code> ，在 Windows 里是 <code>C:\WINDOWS\system32\drivers\etc\hosts</code> ，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210920230255.png" alt="image-20210920190047074"></p><h2 id="9-2、DNS-查询方式"><a href="#9-2、DNS-查询方式" class="headerlink" title="9.2、DNS 查询方式"></a>9.2、DNS 查询方式</h2><blockquote><p>DNS 有两种查询方式，即<strong>递归</strong>与<strong>迭代</strong></p></blockquote><h3 id="1、递归查询（委托他人）"><a href="#1、递归查询（委托他人）" class="headerlink" title="1、递归查询（委托他人）"></a>1、递归查询（委托他人）</h3><blockquote><p>递归查询是一种 DNS 服务器的查询模式，<strong>在该模式下 DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机</strong>。<br>如果 DNS 服务器本地没有存储查询 DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210920230323.png" alt="image-20210920194144422"></p><h3 id="2、迭代查询（自力更生）"><a href="#2、迭代查询（自力更生）" class="headerlink" title="2、迭代查询（自力更生）"></a>2、迭代查询（自力更生）</h3><blockquote><p>使用迭代查询时， DNS 服务器会向客户机提供其他能够解析查询请求的 DNS 服务器地址，当客户机发送查询请求时，<strong>DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址</strong>，客户机再向这台 DNS 服务器提交请求，依次循环直到返回查询的结果为止。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20210920230359.png" alt="image-20210920194157290"></p><h2 id="9-3、DNS-使用的传输层协议"><a href="#9-3、DNS-使用的传输层协议" class="headerlink" title="9.3、DNS 使用的传输层协议"></a>9.3、DNS 使用的传输层协议</h2><blockquote><p>DNS 同时占用了 UDP 和 TCP 的 53 号端口，作为单个应用层协议，<strong>DNS 同时使用了两种传输层协议（UDP 和 TCP）</strong>。</p></blockquote><h3 id="1、为什么基于-UDP-协议发起-DNS-查询，而不是-TCP-？"><a href="#1、为什么基于-UDP-协议发起-DNS-查询，而不是-TCP-？" class="headerlink" title="1、为什么基于 UDP 协议发起 DNS 查询，而不是 TCP ？"></a>1、为什么基于 UDP 协议发起 DNS 查询，而不是 TCP ？</h3><blockquote><p>这是为了尽可能地减少 DNS 服务器响应时间（即从用户发出指令开始，到用户看到页面所花费的时间），即 <code>响应时间 = DNS 域名解析时间 + TCP 连接建立时间 + HTTP 交易时间</code> 。</p><p>由于请求中后两者的时间都不可能减少，所以我们只能希望 DNS 域名解析时间越小越好，而 UDP 是无连接的传输层协议，同时额外开销小于 TCP ，所以基于 UDP 发起查询服务可以减少响应时间。</p></blockquote><h3 id="2、什么时候使用-TCP-协议？"><a href="#2、什么时候使用-TCP-协议？" class="headerlink" title="2、什么时候使用 TCP 协议？"></a>2、什么时候使用 TCP 协议？</h3><blockquote><p>由于历史的原因，互联网上物理链路的最小 MTU = 576 ，<strong>基于 UDP 传输的 DNS 为了限制报文不超过 576 ，所以将 DNS 报文限制在 512 字节</strong>。</p><p><strong>这样一旦 DNS 查询应答超过 512 字节，基于 UDP 的 DNS 就只有截短为 512 字节，那么用户得到的 DNS 应答就是不完整的</strong>。</p><p><strong>所以当 DNS 查询被截断时，这个时候我们应该使用 TCP 协议进行重试</strong>，尽管这样花费的时间长，开销大，但起码可以得到一个准确的答案。</p></blockquote><h3 id="3、DNS-如何选择传输层协议？"><a href="#3、DNS-如何选择传输层协议？" class="headerlink" title="3、DNS 如何选择传输层协议？"></a>3、DNS 如何选择传输层协议？</h3><ul><li><p>如果客户端事先知道 DNS 的响应报文的长度大于 512 字节，那么会直接使用 TCP 建立连接</p></li><li><p>如果客户端实现不知道 DNS 的响应报文的长度，那么一般会先基于 UDP 协议发送 DNS 查询报文，如果返回的报文被阶段，那么客户端会基于 TCP 再次发起一次请求，从而获取准确的报文。</p></li></ul><blockquote><p>在域名解析的时候，一般返回的 DNS 响应报文都不会超过 512 字节，用 UDP 传输即可。事实上，很多 DNS 服务器进行配置的时候，也仅支持 UDP 查询包。</p></blockquote><h2 id="9-4、DNS-完整查询过程"><a href="#9-4、DNS-完整查询过程" class="headerlink" title="9.4、DNS 完整查询过程"></a>9.4、DNS 完整查询过程</h2><ul><li><p>首先查询<strong>浏览器的 DNS 缓存</strong>，这个缓存中维护了一张域名与 IP 地址的对应表</p></li><li><p>如果没有命中，则继续查询<strong>操作系统的 DNS 缓存</strong></p></li><li><p>如果依然没有命中，则操作系统将域名发送至本地域名服务器 ，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（主机和本地域名服务器之间的查询方式是 <strong>递归查询</strong> ）</p></li><li><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong></p></li></ul><blockquote><p>本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大</p></blockquote><ol><li>本地域名服务器向根域名服务器发起请求后，根服务器返回该域名对应的顶级域名服务器的地址，就是给它指条路让他自己去找</li><li>本地域名服务器拿到上一步根域名服务器的返回结果后，请求对应的顶级域名服务器，顶级域名服务器向本地域名服务器返回对应权限域名服务器的地址。</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ol><ul><li><strong>本地域名服务器</strong> 将得到的 IP 地址返回给操作系统，同时自己将 IP 地址 <strong>缓存</strong> 起来</li><li><strong>操作系统</strong> 将 IP 地址返回给浏览器，同时自己也将 IP 地址 <strong>缓存</strong> 起来</li><li><strong>浏览器</strong> 就得到了域名对应的 IP 地址，并将 IP 地址 <strong>缓存</strong> 起来</li></ul><h1 id="十、一次-HTTP-请求全过程"><a href="#十、一次-HTTP-请求全过程" class="headerlink" title="十、一次 HTTP 请求全过程"></a>十、一次 HTTP 请求全过程</h1><p><img src="/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200121155126313.png" alt="img"></p><blockquote><p>以 Tomcat 作为 Web 容器， Spring MVC 作为 Web 处理框架</p></blockquote><h2 id="10-1、输入地址"><a href="#10-1、输入地址" class="headerlink" title="10.1、输入地址"></a>10.1、输入地址</h2><blockquote><p>用户浏览器地址栏中输入地址，然后敲击回车发起请求</p></blockquote><h2 id="10-2、域名解析"><a href="#10-2、域名解析" class="headerlink" title="10.2、域名解析"></a>10.2、域名解析</h2><blockquote><p>具体请参考上面提到 DNS 域名解析过程，在这一步中将域名解析为 IP 地址</p></blockquote><h2 id="10-3、与服务器建立连接"><a href="#10-3、与服务器建立连接" class="headerlink" title="10.3、与服务器建立连接"></a>10.3、与服务器建立连接</h2><blockquote><p>此时，客户端与服务端通过三次握手建立 TCP 连接。</p></blockquote><h2 id="10-4、发起-HTTP-请求"><a href="#10-4、发起-HTTP-请求" class="headerlink" title="10.4、发起 HTTP 请求"></a>10.4、发起 HTTP 请求</h2><blockquote><p>客户端是终端用户，服务器端是网站。通过使用 web 浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的 HTTP 协议进行，否则无法连接。</p><p>HTTP 请求报文的结构可以大致分为四个部分：请求头、空行、请求行和请求体</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://img-blog.csdn.net/20170707143243946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGV5dWVfOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><h3 id="1、请求行"><a href="#1、请求行" class="headerlink" title="1、请求行"></a>1、请求行</h3><blockquote><p>请求行由三部分组成</p></blockquote><ol><li>请求方法</li></ol><blockquote><p>在 HTTP/1.1 中定义的请求方法有八种，如果是 RESTful 接口的话一般会用到前四种，PUT 和 PATCH 的区别是前者常用于全量更新，而后者用于局部更新。</p></blockquote><table><thead><tr><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="center">POST</td><td align="center">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td align="center">PUT</td><td align="center">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="center">DELETE</td><td align="center">请求服务器删除指定的页面。</td></tr><tr><td align="center">CONNECT</td><td align="center">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="center">OPTIONS</td><td align="center">允许客户端查看服务器的性能。</td></tr><tr><td align="center">TRACE</td><td align="center">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="center">PATCH</td><td align="center">是对 PUT 方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><ol start="2"><li>请求地址</li></ol><blockquote><p>URL：统一资源定位符，用来唯一表示互联网中一个资源的具体位置，是一种特殊的 URI</p><p>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;（端口和路径有事可以忽略）</p></blockquote><ol start="3"><li>协议版本</li></ol><blockquote><p>包含协议名称及版本号，格式为 HTTP / 主版本号.副版本号 ，如上图中的 HTTP / 1.1</p></blockquote><h3 id="2、请求头"><a href="#2、请求头" class="headerlink" title="2、请求头"></a>2、请求头</h3><blockquote><p>请求头部为请求报文添加了一些附加信息，每行一对，格式为 <code>属性名:属性值</code>，常见属性如下</p></blockquote><table><thead><tr><th align="center">请求头</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Host</td><td align="center">接受请求的服务器地址，可以是 IP:端口号，也可以是域名</td></tr><tr><td align="center">User-Agent</td><td align="center"><strong>用户代理</strong>，发送请求的应用程序名称（一种向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识），可以进行伪装。</td></tr><tr><td align="center">Connection</td><td align="center">指定与连接相关的属性，如 Connection:Keep-Alive</td></tr><tr><td align="center">Accept-Charset</td><td align="center">通知服务端可以发送的编码格式</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">通知服务端可以发送的数据压缩格式</td></tr><tr><td align="center">Accept-Language</td><td align="center">通知服务端可以发送的语言</td></tr><tr><td align="center">Accept</td><td align="center">用于指定客户端可接受哪些类型的信息，比如说 <code>text/plain</code></td></tr><tr><td align="center">Cache-Control</td><td align="center">对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。</td></tr></tbody></table><blockquote><p>请求头部的最后会有一个<strong>空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少</strong></p></blockquote><h3 id="3、请求体"><a href="#3、请求体" class="headerlink" title="3、请求体"></a>3、请求体</h3><blockquote><p>可选部分，如果请求方法为 GET ，则此项为空，没有数据；</p><p>若方法字段是POST，则通常来说此处放置的就是要提交的数据</p></blockquote><h2 id="10-5、Web-服务器接收-HTTP-请求并返回结果"><a href="#10-5、Web-服务器接收-HTTP-请求并返回结果" class="headerlink" title="10.5、Web 服务器接收 HTTP 请求并返回结果"></a>10.5、Web 服务器接收 HTTP 请求并返回结果</h2><ul><li><p>客户端浏览器将发出的请求被封装成为一个 HttpServletRequest 对象转交请求给 Web 服务器</p></li><li><p>Web服务器收到请求转交请求给 Tomcat</p></li><li><p>Tomcat 调用 Servlet 处理请求</p></li><li><p>Servlet 处理请求并返回处理结果</p></li></ul><blockquote><p>这一步就是 Spring MVC 的工作流程</p></blockquote><ul><li>Tomcat 接收到 Servlet 返回的结果，然后将页面返回给 Web 服务器</li><li>客户端浏览器解析响应 HttpServletResponse 对象，然后将结果呈现给用户</li></ul></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Java基础学习（四）-计算机网络</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/89666111.html">https://sutianxin.top/posts/89666111.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-08-13</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-09-24</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%F0%9F%92%BB%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/">💻后端学习</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/blogImage/raw/master/20210813230548.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2007911645.html"><img class="prev-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210813230944.png" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java面试总结（四）</div></div></a></div><div class="next-post pull-right"><a href="/posts/2964295409.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210715214521.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatis源码学习（二）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1128227004.html" title="Java应用学习（七）-回顾Mybatis和Spring MVC"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210430102830.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">Java应用学习（七）-回顾Mybatis和Spring MVC</div></div></a></div><div><a href="/posts/2938255980.html" title="Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210208120213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-12</div><div class="title">Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用</div></div></a></div><div><a href="/posts/2005124203.html" title="Redis学习手册（一）--NoSQL、redis入门及基本数据类型"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210208174445.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-03</div><div class="title">Redis学习手册（一）--NoSQL、redis入门及基本数据类型</div></div></a></div><div><a href="/posts/913123791.html" title="Spring Cloud学习（七）-Spring Cloud Config"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210516192228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="title">Spring Cloud学习（七）-Spring Cloud Config</div></div></a></div><div><a href="/posts/2863462089.html" title="Spring Cloud学习（二）-OpenFeign微服务调用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504192527.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-11</div><div class="title">Spring Cloud学习（二）-OpenFeign微服务调用</div></div></a></div><div><a href="/posts/650479038.html" title="在线教育项目总结（二）-用户认证"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210205204706.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-05</div><div class="title">在线教育项目总结（二）-用户认证</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%88OSI%EF%BC%89"><span class="toc-text">一、七层网络模型（OSI）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-text">1.1、物理层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-text">1.2、数据链路层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">1.3、网络层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E3%80%81%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-text">1.4、传输层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5%E3%80%81%E4%BC%9A%E8%AF%9D%E5%B1%82"><span class="toc-text">1.5、会话层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6%E3%80%81%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-text">1.6、表示层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">1.7、应用层</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81IP-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-text">二、IP 网络协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2.1、网络协议是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81IP-%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF"><span class="toc-text">1、IP 头部信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81IP-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E8%B7%AF%E7%94%B1%E5%92%8C%E8%BD%AC%E5%8F%91"><span class="toc-text">2、IP 数据报的路由和转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81IP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2.2、IP 协议的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-text">1、无状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%97%A0%E8%BF%9E%E6%8E%A5"><span class="toc-text">2、无连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%8D%E5%8F%AF%E9%9D%A0"><span class="toc-text">3、不可靠</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81TCP-%E5%8D%8F%E8%AE%AE"><span class="toc-text">三、TCP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E4%BD%95%E8%B0%93%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">3.1、何谓协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81TCP-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="toc-text">3.2、TCP 协议概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81TCP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">3.3、TCP 如何保证传输可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A3%80%E9%AA%8C%E5%92%8C"><span class="toc-text">1、检验和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-text">2、序列号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6%EF%BC%88ACK%EF%BC%89"><span class="toc-text">3、确认应答机制（ACK）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%B6%85%E6%97%B6%E9%87%8D%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-text">4、超时重发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">5、连接管理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">6、流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">7、拥塞控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81TCP-IP-%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.4、TCP &#x2F; IP 协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E3%80%81TCP-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-text">3.5、TCP 连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B"><span class="toc-text">1、TCP 连接建立过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81TCP-%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E8%BF%87%E7%A8%8B"><span class="toc-text">2、TCP 连接关闭过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6%E3%80%81SYN-%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><span class="toc-text">3.6、SYN 洪泛攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7%E3%80%81TCP-%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">3.7、TCP 的滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81UDP-%E5%8D%8F%E8%AE%AE"><span class="toc-text">四、UDP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.1、介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-text">4.2、特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81UDP-%E4%B8%8E-TCP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.3、UDP 与 TCP 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E"><span class="toc-text">1、概念说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2、优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81TCP-UDP-%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93"><span class="toc-text">3、TCP UDP 比较总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE"><span class="toc-text">五、HTTP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-text">5.1、协议简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="toc-text">5.2、HTTP 协议概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81HTTP-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">5.3、HTTP 工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81HTTP-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%AD%A5%E9%AA%A4"><span class="toc-text">5.4、HTTP 请求 &#x2F; 响应步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E3%80%81HTTP-%E7%89%B9%E7%82%B9"><span class="toc-text">5.5、HTTP 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6%E3%80%81HTTP-%E4%B9%8B-URL"><span class="toc-text">5.6、HTTP 之 URL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81HTTPS-%E5%8D%8F%E8%AE%AE"><span class="toc-text">六、HTTPS 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-text">6.1、协议简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-HTTPS"><span class="toc-text">6.2、为什么要使用 HTTPS ?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE%E5%AD%98%E5%9C%A8%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="toc-text">1、HTTP 协议存在的风险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81HTTPS-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%BB%A5%E4%B8%8A%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">2、HTTPS 如何解决以上问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-text">6.3、加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-text">1、对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-text">2、非对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81HTTPS-%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3、HTTPS 的加密方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4%E3%80%81HTTPS-%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">6.4、HTTPS 连接方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E3%80%81HTTP-%E4%B8%8E-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6.5、HTTP 与 HTTPS 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">1、安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81CA-%E8%AF%81%E4%B9%A6"><span class="toc-text">2、CA 证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%93%8D%E5%BA%94%E6%95%88%E7%8E%87"><span class="toc-text">3、响应效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E3%80%81%E7%AB%AF%E5%8F%A3%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97"><span class="toc-text">4、连接方式、端口和资源消耗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6%E3%80%81GET-%E5%92%8C-POST-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6.6、GET 和 POST 请求的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7%E3%80%81%E8%AF%AF%E5%8C%BA%E8%AF%B4%E6%98%8E"><span class="toc-text">6.7、误区说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81WebSocket-%E5%8D%8F%E8%AE%AE"><span class="toc-text">七、WebSocket 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">7.1、HTTP 协议的缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81WebSocket-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="toc-text">7.2、WebSocket 协议概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81WebSocket-%E5%8D%8F%E8%AE%AE%E4%B8%8E-Http-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.3、WebSocket 协议与 Http 协议的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-text">1、相同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-text">2、不同之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-text">3、通信过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E3%80%81WebSocket-%E7%9A%84%E6%8F%A1%E6%89%8B"><span class="toc-text">7.4、WebSocket 的握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E3%80%81WebSocket-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">7.5、WebSocket 的缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E9%9C%80%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">八、为什么网络需要分层？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81DNS"><span class="toc-text">九、DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E3%80%81%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E"><span class="toc-text">9.1、概念说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%9F%E5%90%8D"><span class="toc-text">1、域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">2、域名服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81DNS"><span class="toc-text">3、DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81DNS-%E7%BC%93%E5%AD%98"><span class="toc-text">4、DNS 缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E3%80%81DNS-%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">9.2、DNS 查询方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%A7%94%E6%89%98%E4%BB%96%E4%BA%BA%EF%BC%89"><span class="toc-text">1、递归查询（委托他人）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2%EF%BC%88%E8%87%AA%E5%8A%9B%E6%9B%B4%E7%94%9F%EF%BC%89"><span class="toc-text">2、迭代查询（自力更生）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3%E3%80%81DNS-%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-text">9.3、DNS 使用的传输层协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E-UDP-%E5%8D%8F%E8%AE%AE%E5%8F%91%E8%B5%B7-DNS-%E6%9F%A5%E8%AF%A2%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF-TCP-%EF%BC%9F"><span class="toc-text">1、为什么基于 UDP 协议发起 DNS 查询，而不是 TCP ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-TCP-%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">2、什么时候使用 TCP 协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81DNS-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">3、DNS 如何选择传输层协议？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4%E3%80%81DNS-%E5%AE%8C%E6%95%B4%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">9.4、DNS 完整查询过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E4%B8%80%E6%AC%A1-HTTP-%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">十、一次 HTTP 请求全过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1%E3%80%81%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80"><span class="toc-text">10.1、输入地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2%E3%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90"><span class="toc-text">10.2、域名解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3%E3%80%81%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-text">10.3、与服务器建立连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4%E3%80%81%E5%8F%91%E8%B5%B7-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-text">10.4、发起 HTTP 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="toc-text">1、请求行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">2、请求头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="toc-text">3、请求体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5%E3%80%81Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6-HTTP-%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-text">10.5、Web 服务器接收 HTTP 请求并返回结果</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init({el:"#twikoo-wrap",envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai"})},e=()=>{twikoo.getCommentsCount({envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then(function(o){t.innerText=o[0].count}).catch(function(o){console.error(o)})};var n;n=!0,"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" data-lrctype="0" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_yegv7kt2bj.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.js"></script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><script src="https://www.luckyclover.top/rain.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"]):not([href="/contact/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>