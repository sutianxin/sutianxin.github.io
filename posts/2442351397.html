<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL高级学习（三）-MySQL锁问题、常用技巧和内存优化 | Arno</title><meta name="keywords" content="🤓数据库"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL学习笔记三-主要介绍MySQL存储引擎的锁"><meta property="og:type" content="article"><meta property="og:title" content="MySQL高级学习（三）-MySQL锁问题、常用技巧和内存优化"><meta property="og:url" content="https://sutianxin.top/posts/2442351397.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="MySQL学习笔记三-主要介绍MySQL存储引擎的锁"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/photo/raw/master/20210311212615.jpg"><meta property="article:published_time" content="2021-03-11T13:22:51.000Z"><meta property="article:modified_time" content="2021-03-13T13:58:19.214Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="🤓数据库"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/photo/raw/master/20210311212615.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/2442351397"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-03-13 21:58:19"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><link rel="stylesheet" href="/css/translucent.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><meta name="generator" content="Hexo 5.3.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw far fa-calendar-alt"></i><span> 归档</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></li><li><a class="site-page" href="/adjust/"><i class="fa-fw fa fa-adjust"></i><span> 更换背景</span></a></li><li><a class="site-page" href="/statistics/"><i class="fa-fw fa fa-cube"></i><span> 文章统计</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><i class="fa-fw fa fa-balance-scale"></i><span> 国内镜像</span></a></li><li><a class="site-page" href="/box/"><i class="fa-fw fa fa-paper-plane"></i><span> 导航栏</span></a></li><li><a class="site-page" href="/bb/"><i class="fa-fw fa fa-mobile"></i><span> 哔哔</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-headphones"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cubes"></i><span> 社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></li><li><a class="site-page" href="/fcircle/"><i class="fa-fw fa fa-puzzle-piece"></i><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-file"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/photo/raw/master/20210311212615.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw far fa-calendar-alt"></i><span> 归档</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></li><li><a class="site-page" href="/adjust/"><i class="fa-fw fa fa-adjust"></i><span> 更换背景</span></a></li><li><a class="site-page" href="/statistics/"><i class="fa-fw fa fa-cube"></i><span> 文章统计</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><i class="fa-fw fa fa-balance-scale"></i><span> 国内镜像</span></a></li><li><a class="site-page" href="/box/"><i class="fa-fw fa fa-paper-plane"></i><span> 导航栏</span></a></li><li><a class="site-page" href="/bb/"><i class="fa-fw fa fa-mobile"></i><span> 哔哔</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-headphones"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cubes"></i><span> 社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></li><li><a class="site-page" href="/fcircle/"><i class="fa-fw fa fa-puzzle-piece"></i><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-file"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL高级学习（三）-MySQL锁问题、常用技巧和内存优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-11T13:22:51.000Z" title="发表于 2021-03-11 21:22:51">2021-03-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-13T13:58:19.214Z" title="更新于 2021-03-13 21:58:19">2021-03-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL%E9%AB%98%E7%BA%A7/">MySQL高级</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.9k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、应用优化"><a href="#一、应用优化" class="headerlink" title="一、应用优化"></a>一、应用优化</h1><blockquote><p>前面章节，我们介绍了很多数据库的优化措施。</p><p>但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。</p></blockquote><h2 id="1-1、使用数据库连接池"><a href="#1-1、使用数据库连接池" class="headerlink" title="1.1、使用数据库连接池"></a>1.1、使用数据库连接池</h2><blockquote><p>对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能。</p><p>Java中常用的数据库如下：</p></blockquote><h3 id="1、C3P0"><a href="#1、C3P0" class="headerlink" title="1、C3P0"></a>1、C3P0</h3><blockquote><p>开源的，成熟的，高并发第三方数据库连接池，作者是 Steve Waldman，相关的文档资料比较完善，大名鼎鼎的hibernate框架就使用了c3p0数据库连接池。</p><p>SSM项目中常集成 <code>C3P0</code> 连接池</p></blockquote><h3 id="2、HiKariCP"><a href="#2、HiKariCP" class="headerlink" title="2、HiKariCP"></a>2、HiKariCP</h3><blockquote><p><code>Spring Boot</code> 默认集成的数据库连接池，速度极快</p></blockquote><h3 id="3、Druid"><a href="#3、Druid" class="headerlink" title="3、Druid"></a>3、Druid</h3><blockquote><p><code>Alibaba</code>开源的数据库连接池，号称是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。</p></blockquote><h2 id="1-2、减少对MySQL的访问"><a href="#1-2、减少对MySQL的访问" class="headerlink" title="1.2、减少对MySQL的访问"></a>1.2、减少对MySQL的访问</h2><h3 id="1、减少对数据进行重复检索"><a href="#1、减少对数据进行重复检索" class="headerlink" title="1、减少对数据进行重复检索"></a>1、减少对数据进行重复检索</h3><blockquote><p>在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。</p></blockquote><ul><li>比如 ，需要获取书籍的id 和name字段 ， 则查询如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id , name from tb_book;</span><br></pre></td></tr></table></figure><ul><li>之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id , status from tb_book;</span><br></pre></td></tr></table></figure><ul><li>这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name , status from tb_book;</span><br></pre></td></tr></table></figure><h3 id="2、增加cache层"><a href="#2、增加cache层" class="headerlink" title="2、增加cache层"></a>2、增加cache层</h3><blockquote><p>在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。</p><p>因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据 。</p></blockquote><h2 id="1-3、负载均衡"><a href="#1-3、负载均衡" class="headerlink" title="1.3、负载均衡"></a>1.3、负载均衡</h2><blockquote><p>负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。</p></blockquote><h3 id="1、利用MySQL复制分流查询"><a href="#1、利用MySQL复制分流查询" class="headerlink" title="1、利用MySQL复制分流查询"></a>1、利用MySQL复制分流查询</h3><blockquote><p>有一台 <code>MySQL</code> 的 <strong>主节点</strong> ，可以将数据同步到 <strong>从节点</strong> 中</p><p>通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310212344.png" alt="image-20210310212344695"></p><blockquote><p>在进行 <strong>写操作（增删改）</strong> 的时候直接对 <code>master</code> 节点进行操作，然后由 <code>master</code> 节点同步到 <code>salve</code> 节点中。</p><p><strong>读操作</strong> 不请求 <code>master</code> ，而是请求 <code>slave</code> 。</p><p><strong>写</strong> 的压力集中在 <code>master</code> ，而 <strong>读</strong> 的压力集中在 <code>salve</code></p></blockquote><h3 id="2、采用分布式数据库架构"><a href="#2、采用分布式数据库架构" class="headerlink" title="2、采用分布式数据库架构"></a>2、采用分布式数据库架构</h3><blockquote><p>分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。</p></blockquote><h1 id="二、MySQL中查询缓存优化"><a href="#二、MySQL中查询缓存优化" class="headerlink" title="二、MySQL中查询缓存优化"></a>二、MySQL中查询缓存优化</h1><blockquote><p>注意，<code>MySQL</code> 8.0之后去掉了查询缓存，我们可以使用其他缓存服务器（例如 <code>Redis</code>）来代替</p></blockquote><h2 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h2><blockquote><p>开启Mysql的查询缓存，<strong>当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果</strong>，当<strong>数据被修改，之前的缓存会失效</strong>，<strong>修改比较频繁的表不适合做查询缓存。</strong></p></blockquote><h2 id="2-2、操作流程"><a href="#2-2、操作流程" class="headerlink" title="2.2、操作流程"></a>2.2、操作流程</h2><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310213045.png" alt="image-20210310213045383"></p><blockquote><p>执行流程大致如下：</p></blockquote><ul><li><p>客户端发送一条查询给服务器；</p></li><li><p>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</p></li><li><p>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</p></li><li><p>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</p></li><li><p>将结果缓存一份放入 <strong>查询缓存</strong>中并返回给客户端。</p></li></ul><h2 id="2-3、查询缓存配置"><a href="#2-3、查询缓存配置" class="headerlink" title="2.3、查询缓存配置"></a>2.3、查询缓存配置</h2><h3 id="1、查看当前数据库是否支持查询缓存"><a href="#1、查看当前数据库是否支持查询缓存" class="headerlink" title="1、查看当前数据库是否支持查询缓存"></a>1、查看当前数据库是否支持查询缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;have_query_cache&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>由于 <code>MySQL</code> 8.0之后已经不支持查询缓存，而我使用用的版本是 <code>8.0.19</code> ，所以这里的结果自然是 <code>NO</code></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310215903.png" alt="image-20210310215902999"></p><h3 id="2、查看当前MySQL是否开启了查询缓存"><a href="#2、查看当前MySQL是否开启了查询缓存" class="headerlink" title="2、查看当前MySQL是否开启了查询缓存"></a>2、查看当前MySQL是否开启了查询缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;query_cache_type&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310220419.png" alt="image-20210310220419476"></p><h3 id="3、查看查询缓存的占用大小"><a href="#3、查看查询缓存的占用大小" class="headerlink" title="3、查看查询缓存的占用大小"></a>3、查看查询缓存的占用大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;query_cache_size&#39;;</span><br></pre></td></tr></table></figure><h3 id="4、查看查询缓存的状态变量"><a href="#4、查看查询缓存的状态变量" class="headerlink" title="4、查看查询缓存的状态变量"></a>4、查看查询缓存的状态变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#39;Qcache%&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>结果中各变量参数说明如下</p></blockquote><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>Qcache_free_blocks</code></td><td>查询缓存中的可用内存块数</td></tr><tr><td><code>Qcache_free_memory</code></td><td>查询缓存的可用内存量</td></tr><tr><td><code>Qcache_hits</code></td><td>查询缓存命中数</td></tr><tr><td><code>Qcache_inserts</code></td><td>添加到查询缓存的查询数</td></tr><tr><td><code>Qcache_lowmen_prunes</code></td><td>由于内存不足而从查询缓存中删除的查询数</td></tr><tr><td><code>Qcache_not_cached</code></td><td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td></tr><tr><td><code>Qcache_queries_in_cache</code></td><td>查询缓存中注册的查询数</td></tr><tr><td><code>Qcache_total_blocks</code></td><td>查询缓存中的块总数</td></tr></tbody></table><h2 id="2-4、开启查询缓存"><a href="#2-4、开启查询缓存" class="headerlink" title="2.4、开启查询缓存"></a>2.4、开启查询缓存</h2><blockquote><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type该参数的可取值有三个：</p></blockquote><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>OFF 或 0</td><td>查询缓存功能关闭</td></tr><tr><td>ON 或 1</td><td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定SQL_NO_CACHE，不予缓存</td></tr><tr><td>DEMAND或 2</td><td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存</td></tr></tbody></table><blockquote><p>在 <code>my.cnf</code> 配置文件中，增加以下配置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启MySQL查询缓存（不适用于8.0及以上版本）</span></span><br><span class="line">query_cache_type = 1;</span><br></pre></td></tr></table></figure><blockquote><p>配置完毕之后，重启服务既可生效 ；</p><p>然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。</p></blockquote><h2 id="2-5、查询缓存Select-选项"><a href="#2-5、查询缓存Select-选项" class="headerlink" title="2.5、查询缓存Select 选项"></a>2.5、查询缓存Select 选项</h2><blockquote><p>可以在SELECT语句中指定两个与查询缓存相关的选项 ：</p><p><code>SQL_CACHE</code> : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。</p><p><code>SQL_NO_CACHE</code> : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。例子：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_CACHE id, name FROM customer;</span><br><span class="line">SELECT SQL_NO_CACHE id, name FROM customer;</span><br></pre></td></tr></table></figure><h1 id="三、MySQL内存管理及优化"><a href="#三、MySQL内存管理及优化" class="headerlink" title="三、MySQL内存管理及优化"></a>三、MySQL内存管理及优化</h1><h2 id="3-1、内存优化原则"><a href="#3-1、内存优化原则" class="headerlink" title="3.1、内存优化原则"></a>3.1、内存优化原则</h2><ul><li><p>将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。</p></li><li><p><code>MyISAM</code> 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有<code>MyISAM</code>表，就要预留更多的内存给操作系统做IO缓存。</p></li><li><p><strong>排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</strong></p></li></ul><h2 id="3-2、MyISAM-内存优化"><a href="#3-2、MyISAM-内存优化" class="headerlink" title="3.2、MyISAM 内存优化"></a>3.2、<code>MyISAM</code> 内存优化</h2><blockquote><p><code>MyISAM</code>存储引擎使用 <code>key_buﬀer</code> 缓存索引块，加速<code>MyISAM</code>索引的读写速度。对于<code>MyISAM</code>表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。</p></blockquote><h3 id="1、key-buﬀer-size"><a href="#1、key-buﬀer-size" class="headerlink" title="1、key_buﬀer_size"></a>1、key_buﬀer_size</h3><blockquote><p>key_buﬀer_size决定 <code>MyISAM</code>索引块缓存区的大小，直接影响到 <code>MyISAM</code> 表的存取效率。</p><p>可以在MySQL参数文件中设置key_buﬀer_size的值，对于一般 <code>MyISAM</code> 数据库，建议至少将1/4可用内存分配给key_buﬀer_size。<br>在 <code>/usr/my.cnf</code> 中做如下配置：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_buffer_size&#x3D;512M</span><br></pre></td></tr></table></figure><h3 id="2、read-buﬀer-size"><a href="#2、read-buﬀer-size" class="headerlink" title="2、read_buﬀer_size"></a>2、read_buﬀer_size</h3><p>如果需要经常顺序扫描 <code>myisam</code> 表，可以通过增大read_buﬀer_size的值来改善性能。但需要注意的是<br><strong>read_buﬀer_size是每个session独占的</strong>，如果默认值设置太大，就会造成内存浪费。</p><h3 id="3、read-rnd-buﬀer-size"><a href="#3、read-rnd-buﬀer-size" class="headerlink" title="3、read_rnd_buﬀer_size"></a>3、read_rnd_buﬀer_size</h3><p>对于需要做排序的 <code>myisam</code> 表的查询，如带有order by子句的sql，适当增加 read_rnd_buﬀer_size 的值，可以改善此类的sql性能。但需要注意的是 <strong>read_rnd_buﬀer_size 是每个session独占的</strong>，如果默认值设置太大，就会造成内存浪费。</p><h2 id="3-3、InnoDB-内存优化"><a href="#3-3、InnoDB-内存优化" class="headerlink" title="3.3、InnoDB 内存优化"></a>3.3、<code>InnoDB</code> 内存优化</h2><blockquote><p>innodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。</p></blockquote><h3 id="1、innodb-buﬀer-pool-size"><a href="#1、innodb-buﬀer-pool-size" class="headerlink" title="1、innodb_buﬀer_pool_size"></a>1、<code>innodb_buﬀer_pool_size</code></h3><blockquote><p>该变量决定了 innodb <strong>存储引擎表数据</strong>和<strong>索引数据</strong>的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buﬀer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size=512M</span><br></pre></td></tr></table></figure><h3 id="2、innodb-log-buﬀer-size"><a href="#2、innodb-log-buﬀer-size" class="headerlink" title="2、innodb_log_buﬀer_size"></a>2、<code>innodb_log_buﬀer_size</code></h3><blockquote><p>决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buﬀer_size的大小，<strong>可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_log_buffer_size=10M</span><br></pre></td></tr></table></figure><h1 id="四、MySQL-并发参数调整"><a href="#四、MySQL-并发参数调整" class="headerlink" title="四、MySQL 并发参数调整"></a>四、MySQL 并发参数调整</h1><blockquote><p>从实现上来说，MySQL Server 是<strong>多线程结构</strong>，包括<strong>后台线程和客户服务线程</strong>。多线程可以有效利用服务器资源，提高数据库的并发性能。</p><p>在Mysql中，控制并发连接和线程的主要参数包括</p></blockquote><ul><li>max_connections</li><li>back_log</li><li>thread_cache_size</li><li>table_open_cache。</li></ul><h2 id="4-1、max-connections"><a href="#4-1、max-connections" class="headerlink" title="4.1、max_connections"></a>4.1、max_connections</h2><blockquote><p>采用max_connections 控制允许连接到MySQL数据库的最大数量，<strong>默认值是 151</strong>。</p><p>如果<strong>状态变量connection_errors_max_connections 不为零</strong>，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这时可以考虑增大max_connections 的值。</p><p><code>Mysql</code> 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。</p><p>在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p></blockquote><h2 id="4-2、back-log"><a href="#4-2、back-log" class="headerlink" title="4.2、back_log"></a>4.2、back_log</h2><blockquote><p>back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。</p><p>如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 <code>50</code> ， 之后的版本默认为 <code>50 +（max_connections / 5）</code>， 但最大不超过 <code>900</code>。</p><p><strong>如果需要数据库在较短的时间内处理大量连接请求</strong>， 可以考虑适当增大 <code>back_log</code> 的值。</p><p>类似线程池的<strong>阻塞队列</strong></p></blockquote><h2 id="4-3、table-open-cache"><a href="#4-3、table-open-cache" class="headerlink" title="4.3、table_open_cache"></a>4.3、table_open_cache</h2><blockquote><p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。</p><p>该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：<code>max_connections x N</code>；</p></blockquote><h2 id="4-4、thread-cache-size"><a href="#4-4、thread-cache-size" class="headerlink" title="4.4、thread_cache_size"></a>4.4、thread_cache_size</h2><blockquote><p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。</p></blockquote><h2 id="4-5、innodb-lock-wait-timeout"><a href="#4-5、innodb-lock-wait-timeout" class="headerlink" title="4.5、innodb_lock_wait_timeout"></a>4.5、innodb_lock_wait_timeout</h2><blockquote><p>该参数是用来设置 <strong>InnoDB 事务等待行锁的时间</strong>，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说，可以将行锁的等待时间调大， 以避免发生大的回滚操作。</p></blockquote><h1 id="五、MySQL锁问题"><a href="#五、MySQL锁问题" class="headerlink" title="五、MySQL锁问题"></a>五、MySQL锁问题</h1><h2 id="5-1、锁概述"><a href="#5-1、锁概述" class="headerlink" title="5.1、锁概述"></a>5.1、锁概述</h2><blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。</p><p>在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p></blockquote><h2 id="5-2、锁分类"><a href="#5-2、锁分类" class="headerlink" title="5.2、锁分类"></a>5.2、锁分类</h2><h3 id="1、从对数据操作的粒度分"><a href="#1、从对数据操作的粒度分" class="headerlink" title="1、从对数据操作的粒度分"></a>1、从对数据操作的粒度分</h3><ul><li>表锁</li></ul><blockquote><p>操作时，会锁定整个表</p></blockquote><ul><li>行锁</li></ul><blockquote><p>操作时，会锁定当前操作行</p></blockquote><h3 id="2、从对数据操作的类型分"><a href="#2、从对数据操作的类型分" class="headerlink" title="2、从对数据操作的类型分"></a>2、从对数据操作的类型分</h3><ul><li>读锁（共享锁）</li></ul><blockquote><p>针对同一份数据，多个读操作可以同时进行而不会相互影响。</p></blockquote><ul><li>写锁（排他锁）</li></ul><blockquote><p>当前操作没有完成之前，它会阻断其他写锁和读锁。</p></blockquote><h2 id="5-3、MySQL-锁"><a href="#5-3、MySQL-锁" class="headerlink" title="5.3、MySQL 锁"></a>5.3、MySQL 锁</h2><blockquote><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：</p></blockquote><table><thead><tr><th>存储引擎</th><th>表级锁</th><th>行级锁</th><th>页面锁</th></tr></thead><tbody><tr><td><code>MyISAM</code></td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td><code>InnoDB</code></td><td>支持</td><td>支持（默认支持）</td><td>不支持</td></tr><tr><td>MEMORY</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>BDB</td><td>支持</td><td>不支持</td><td>支持</td></tr></tbody></table><blockquote><p>MySQL这三种锁的特性大致可以归纳如下</p></blockquote><table><thead><tr><th>锁类型</th><th>特点</th></tr></thead><tbody><tr><td>表级锁</td><td>偏向<code>MyISAM</code> 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td></tr><tr><td>行级锁</td><td>偏向<code>InnoDB</code> 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td></tr><tr><td>页面锁</td><td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td></tr></tbody></table><blockquote><p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</p></blockquote><h2 id="5-4、MyISAM-表锁"><a href="#5-4、MyISAM-表锁" class="headerlink" title="5.4、MyISAM 表锁"></a>5.4、MyISAM 表锁</h2><blockquote><p>MyISAM 存储引擎只支持表锁，这也是 MySQL 开始几个版本中唯一支持的锁类型。</p></blockquote><h3 id="1、如何加表锁"><a href="#1、如何加表锁" class="headerlink" title="1、如何加表锁"></a>1、如何加表锁</h3><blockquote><p>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 <code>LOCK TABLE</code> 命令给 MyISAM 表显式加锁。</p><p>显示加表锁语法：</p></blockquote><ul><li>加读锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock table table_name read;</span><br></pre></td></tr></table></figure><ul><li>加读锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock table table_name write;</span><br></pre></td></tr></table></figure><ul><li>读读共享，读写互斥，写写互斥。</li></ul><h3 id="2、读锁案例"><a href="#2、读锁案例" class="headerlink" title="2、读锁案例"></a>2、读锁案例</h3><ul><li>准备环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tb_book&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;id&#96;           INT(11) auto_increment,</span><br><span class="line">    &#96;name&#96;         VARCHAR(50) DEFAULT NULL,</span><br><span class="line">    &#96;publish_time&#96; DATE        DEFAULT NULL,</span><br><span class="line">    &#96;status&#96;       CHAR(1)     DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE &#x3D; myisam</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_book (id, name, publish_time, status)</span><br><span class="line">VALUES (NULL, &#39;java编程思</span><br><span class="line">想&#39;, &#39;2088-08-01&#39;, &#39;1&#39;);</span><br><span class="line">INSERT INTO tb_book (id, name, publish_time, status)</span><br><span class="line">VALUES (NULL, &#39;solr编程思想&#39;, &#39;2088-08-08&#39;, &#39;0&#39;);</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;tb_user&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;id&#96;   INT(11) auto_increment,</span><br><span class="line">    &#96;name&#96; VARCHAR(50) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE &#x3D; myisam</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_user (id, name) VALUES(NULL,&#39;令狐冲&#39;);</span><br><span class="line">INSERT INTO tb_user (id, name) VALUES(NULL,&#39;田伯光&#39;);</span><br></pre></td></tr></table></figure><blockquote><p>打开两个客户端，在客户端一对 <code>tb_book</code> 加一个读锁，然后执行查询语句</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock table tb_book read;</span><br><span class="line">select * from tb_book;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311142350.png" alt="image-20210311142350179"></p><blockquote><p>此时在第二个客户端中也可以查询出 <code>tb_book</code> 中的数据，这是因为读锁是 <strong>共享锁</strong></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311142638.png" alt="image-20210311142638815"></p><blockquote><p>这个时候在第一个客户端中是无法操作其他表的</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311142730.png" alt="image-20210311142730459"></p><blockquote><p>在第一个客户端中也无法对 <code>tb_book</code> 进行 <strong>增删改</strong> 操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_book set name &#x3D; &#39;wuhu&#39; where id &#x3D; 2;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311143054.png" alt="image-20210311143054009"></p><blockquote><p>这个时候在第二个客户端中进行 增删改 操作时将会阻塞，直到第一个客户端释放读锁。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311143227.png" alt="image-20210311143227420"></p><blockquote><p>在第一个客户端中释放读锁</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311144038.png" alt="image-20210311144038130"></p><blockquote><p>第二个客户端马上执行更新操作</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311144106.png" alt="image-20210311144106554"></p><h3 id="3、写锁案例"><a href="#3、写锁案例" class="headerlink" title="3、写锁案例"></a>3、写锁案例</h3><ul><li>在客户端一中为 <code>tb_book</code> 表加上一个写锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock table tb_book write;</span><br></pre></td></tr></table></figure><blockquote><p>此时在客户端一中仍然可以查询数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_book;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311144838.png" alt="image-20210311144838393"></p><blockquote><p>在客户端一中，可以对表 <code>tb_book</code> 进行写操作（增删改）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_book set name &#x3D; &#39;qifei&#39; where id &#x3D; 2;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311144949.png" alt="image-20210311144949347"></p><ul><li>在客户端二中进行操作</li></ul><blockquote><p>在客户端二中使用 <code>select</code> 进行读操作，发现进入等待状态</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311145440.png" alt="image-20210311145440874"></p><blockquote><p>在客户端一中释放锁后，客户端二中的指令被立即执行。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311145624.png" alt="image-20210311145624833"></p><h3 id="4、结论"><a href="#4、结论" class="headerlink" title="4、结论"></a>4、结论</h3><blockquote><p>锁模式的相互兼容性如表所示：</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311150933.png" alt="image-20210311150933537"></p><blockquote><p>由上表可见：</p></blockquote><ul><li>对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；</li></ul><blockquote><p>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</p><p>此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p></blockquote><ul><li>MyISAM不适合做读表的存储引擎</li></ul><h2 id="5-4、InnoDB行锁"><a href="#5-4、InnoDB行锁" class="headerlink" title="5.4、InnoDB行锁"></a>5.4、InnoDB行锁</h2><h3 id="1、行锁介绍"><a href="#1、行锁介绍" class="headerlink" title="1、行锁介绍"></a>1、行锁介绍</h3><blockquote><p>行锁特点 ：</p></blockquote><ul><li>偏向 <code>InnoDB</code> 存储引擎，开销大，加锁慢；</li><li>会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li></ul><blockquote><p><code>InnoDB</code> 与 <code>MyISAM</code> 的最大不同有两点：一是支持事务；二是 采用了行级锁。</p></blockquote><h3 id="2、背景知识"><a href="#2、背景知识" class="headerlink" title="2、背景知识"></a>2、背景知识</h3><ul><li>事务及其ACID属性</li></ul><blockquote><p>事务是由一组SQL语句组成的逻辑处理单元。</p><p>事务具有以下4个特性，简称为事务ACID属性。</p></blockquote><table><thead><tr><th>ACID属性</th><th>含义</th></tr></thead><tbody><tr><td>原子性（Atomicity）</td><td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。</td></tr><tr><td>一致性（Consistent）</td><td>在事务开始和完成时，数据都必须保持一致状态。</td></tr><tr><td>隔离性（Isolation）</td><td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。</td></tr><tr><td>持久性（Durable）</td><td>事务完成之后，对于数据的修改是永久的。</td></tr></tbody></table><ul><li>并发事务处理带来的问题</li></ul><table><thead><tr><th>问题</th><th>含义</th></tr></thead><tbody><tr><td>丢失更新（Lost Update）</td><td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。</td></tr><tr><td>脏读（Dirty Reads）</td><td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td></tr><tr><td>不可重复读（Non- Repeatable Reads）</td><td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。</td></tr><tr><td>幻读（Phantom Reads）</td><td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td></tr></tbody></table><ul><li>事务的隔离级别</li></ul><blockquote><p>为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。<br>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、 Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。</p></blockquote><table><thead><tr><th>隔离级别</th><th>丢失更新(脏写)</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read（默认）</td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>备注：√ 代表可能出现 ， × 代表不会出现 。</p><ul><li>MySQL 的数据库的默认隔离级别为：<code>Repeatable read</code> ，查看方式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;tx_isolation&#39;;</span><br></pre></td></tr></table></figure><h3 id="3、InnoDB的行锁模式"><a href="#3、InnoDB的行锁模式" class="headerlink" title="3、InnoDB的行锁模式"></a>3、InnoDB的行锁模式</h3><blockquote><p>InnoDB 实现了以下两种类型的行锁。</p></blockquote><ul><li>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li><li>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li></ul><blockquote><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</p><p>对于普通SELECT语句，InnoDB不会加任何锁；</p></blockquote><ul><li>可以通过以下语句显式地给记录集加共享锁或者排他锁</li></ul><blockquote><p>共享锁：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure><blockquote><p>排他锁：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure><h3 id="4、案例环境准备"><a href="#4、案例环境准备" class="headerlink" title="4、案例环境准备"></a>4、案例环境准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">create table test_innodb_lock</span><br><span class="line">(</span><br><span class="line">    id   int(11),</span><br><span class="line">    name varchar(16),</span><br><span class="line">    sex  varchar(1)</span><br><span class="line">) engine &#x3D; innodb</span><br><span class="line">  default charset &#x3D; utf8;</span><br><span class="line">insert into test_innodb_lock</span><br><span class="line">values (1, &#39;100&#39;, &#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock</span><br><span class="line">values (3, &#39;3&#39;, &#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock</span><br><span class="line">values (4, &#39;400&#39;, &#39;0&#39;);</span><br><span class="line">insert into test_innodb_lock</span><br><span class="line">values (5, &#39;500&#39;, &#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock</span><br><span class="line">values (6, &#39;600&#39;, &#39;0&#39;);</span><br><span class="line">insert into test_innodb_lock</span><br><span class="line">values (7, &#39;700&#39;, &#39;0&#39;);</span><br><span class="line">insert into test_innodb_lock</span><br><span class="line">values (8, &#39;800&#39;, &#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock</span><br><span class="line">values (9, &#39;900&#39;, &#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock</span><br><span class="line">values (1, &#39;200&#39;, &#39;0&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create index idx_test_innodb_lock_id on test_innodb_lock (id);</span><br><span class="line">create index idx_test_innodb_lock_name on test_innodb_lock (name);</span><br></pre></td></tr></table></figure><h3 id="5、演示-InnoDB-的行锁"><a href="#5、演示-InnoDB-的行锁" class="headerlink" title="5、演示 InnoDB 的行锁"></a>5、演示 <code>InnoDB</code> 的行锁</h3><ul><li>打开两个命令行窗口，连接MySQL后关闭自动提交</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure><ul><li>在窗口一执行一条 <code>update</code> 语句，然后不提交</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_innodb_lock set name &#x3D; &#39;300&#39; where id &#x3D; 3;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311193546.png" alt="image-20210311193539183"></p><ul><li>在窗口二执行一条 <code>update</code> 语句，查看结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_innodb_lock set name &#x3D; &#39;30&#39; where id &#x3D; 3;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311193747.png" alt="image-20210311193747699"></p><ul><li>此时在窗口一中执行 <code>commit</code> ，提交事务，就可以释放行锁，执行窗口二的操作。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311193943.png" alt="image-20210311193943691"></p><p>注：当无索引或者索引失效时，<code>InnoDB</code>的行锁将升级为表锁</p><h3 id="6、间隙锁危害"><a href="#6、间隙锁危害" class="headerlink" title="6、间隙锁危害"></a>6、间隙锁危害</h3><blockquote><p>当我们<strong>用范围条件，而不是使用相等条件检索数据</strong>，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁；</p><p><strong>对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。</strong></p><p>因为Query执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。</p><p>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311202823.png" alt="image-20210311202823816"></p><ul><li>准备两个客户端，关闭事务的自动提交。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure><ul><li>在窗口一执行一条 <code>update</code> 语句，在这之前我们先查询一下 <code>test_innodb_lock</code> 的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_innodb_lock;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311203317.png" alt="image-20210311203317696"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update &#96;test_innodb_lock&#96; set sex &#x3D; &#39;2&#39; where id &lt; 4;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311203444.png" alt="image-20210311203444361"></p><ul><li>这个时候我们再第二个窗口插入一条 <code>id</code> 为2的数据，查看结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into test_innodb_lock values(2,&#39;2000&#39;,&#39;1&#39;);</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311203717.png" alt="image-20210311203716889"></p><blockquote><p>在第一个窗口提交事务，可以看到第二个窗口被阻塞的<code>insert</code> 执行成功。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311203914.png" alt="image-20210311203914384"></p><blockquote><p>可以使用逻辑删除来代替物理删除</p></blockquote><h3 id="7、查看InnoDB行锁争用情况"><a href="#7、查看InnoDB行锁争用情况" class="headerlink" title="7、查看InnoDB行锁争用情况"></a>7、查看<code>InnoDB</code>行锁争用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#39;innodb_row_lock%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311204125.png" alt="image-20210311204125281"></p><blockquote><p>参数说明</p></blockquote><ul><li><code>Innodb_row_lock_current_waits</code>: 当前正在等待锁定的数量</li><li><code>Innodb_row_lock_time</code>: 从系统启动到现在锁定总时间长度</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时长</li><li><code>Innodb_row_lock_time_max</code>：从系统启动到现在等待最长的一次所花的时间</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数</li></ul><blockquote><p>当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p></blockquote><h3 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h3><blockquote><p><code>InnoDB</code> 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远优于 <code>MyISAM</code> 的表锁的。当系统并发量较高的时候， <code>InnoDB</code> 的整体性能和 <code>MyISAM</code> 相比就会有比较明显的优势。<br>但是，<code>InnoDB</code> 的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让 <code>InnoDB</code> 的整体性能表现不仅不能比 <code>MyISAM</code>高，甚至可能会更差。</p><p>优化建议：</p></blockquote><ul><li><strong>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。</strong></li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少索引条件，及索引范围，避免间隙锁尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可使用低级别事务隔离<strong>（但是需要业务层面满足需求）</strong></li></ul><h1 id="六、常用SQL技巧"><a href="#六、常用SQL技巧" class="headerlink" title="六、常用SQL技巧"></a>六、常用SQL技巧</h1><h2 id="6-1、SQL执行顺序"><a href="#6-1、SQL执行顺序" class="headerlink" title="6.1、SQL执行顺序"></a>6.1、SQL执行顺序</h2><h3 id="1、编写顺序"><a href="#1、编写顺序" class="headerlink" title="1、编写顺序"></a>1、编写顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT </span><br><span class="line">    &lt;select list&gt;</span><br><span class="line">FROM </span><br><span class="line">     &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line">JOIN </span><br><span class="line">     &lt;right_table&gt; ON &lt;join_condition&gt;</span><br><span class="line">WHERE</span><br><span class="line">    &lt;where_condition&gt;</span><br><span class="line">GROUP BY </span><br><span class="line">    &lt;group_by_list&gt;</span><br><span class="line">HAVING</span><br><span class="line">    &lt;having_condition&gt;</span><br><span class="line">ORDER BY </span><br><span class="line">    &lt;order_by_condition&gt;</span><br><span class="line">LIMIT </span><br><span class="line">    &lt;limit_params&gt;</span><br></pre></td></tr></table></figure><p><code>s f j w g h o l</code></p><h3 id="2、执行顺序"><a href="#2、执行顺序" class="headerlink" title="2、执行顺序"></a>2、执行顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM </span><br><span class="line">    &lt;left_table&gt;</span><br><span class="line">ON </span><br><span class="line">    &lt;join_condition&gt;</span><br><span class="line">    &lt;join_type&gt;	JOIN &lt;right_table&gt;</span><br><span class="line">WHERE </span><br><span class="line">    &lt;where_condition&gt;</span><br><span class="line">GROUP BY </span><br><span class="line">    &lt;group_by_list&gt;</span><br><span class="line">HAVING </span><br><span class="line">    &lt;having_condition&gt;</span><br><span class="line">SELECT DISTINCT	</span><br><span class="line">    &lt;select list&gt;</span><br><span class="line">ORDER BY </span><br><span class="line">    &lt;order_by_condition&gt;</span><br><span class="line">LIMIT</span><br><span class="line">    &lt;limit_params&gt;</span><br></pre></td></tr></table></figure><p><code>f j w g h s o l</code></p><ul><li>先指定从哪一张或哪几张表中查询数据（设计联表及联表条件）</li><li>根据什么条件进行查询？（where进行一次过滤）</li><li>根据什么条件进行分组（group by）</li><li>对上面的结果进行二次过滤（having）</li><li>从二次过滤的结果中挑选出要取得的结果列</li><li>最后进行排序和分页。</li></ul><h2 id="6-2、正则表达式的使用"><a href="#6-2、正则表达式的使用" class="headerlink" title="6.2、正则表达式的使用"></a>6.2、正则表达式的使用</h2><blockquote><p>正则表达式是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p></blockquote><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>在字符串开始处进行匹配</td></tr><tr><td>$</td><td>在字符串末尾处进行匹配</td></tr><tr><td>.</td><td>匹配任意单个字符, 包括换行符</td></tr><tr><td>[…]</td><td>匹配出括号内的任意字符</td></tr><tr><td>[^…]</td><td>匹配不出括号内的任意字符</td></tr><tr><td>a*</td><td>匹配零个或者多个a(包括空串)</td></tr><tr><td>a+</td><td>匹配一个或者多个a(不包括空串)</td></tr><tr><td>a?</td><td>匹配零个或者一个a</td></tr><tr><td>a1|a2</td><td>匹配a1或a2</td></tr><tr><td>a(m)</td><td>匹配m个a</td></tr><tr><td>a(m,)</td><td>至少匹配m个a</td></tr><tr><td>a(m,n)</td><td>匹配m个a 到 n个a</td></tr><tr><td>a(,n)</td><td>匹配0到n个a</td></tr><tr><td>(…)</td><td>将模式元素组成单一元素</td></tr></tbody></table><h2 id="6-3、MySQL常用函数"><a href="#6-3、MySQL常用函数" class="headerlink" title="6.3、MySQL常用函数"></a>6.3、MySQL常用函数</h2><h3 id="1、数字函数"><a href="#1、数字函数" class="headerlink" title="1、数字函数"></a>1、数字函数</h3><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>ABS</td><td>求绝对值</td></tr><tr><td>SQRT</td><td>求二次方根</td></tr><tr><td>MOD</td><td>求余数</td></tr><tr><td>CEIL 和 CEILING</td><td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td></tr><tr><td>FLOOR</td><td>向下取整，返回值转化为一个BIGINT</td></tr><tr><td>RAND</td><td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td></tr><tr><td>ROUND</td><td>对所传参数进行四舍五入</td></tr><tr><td>SIGN</td><td>返回参数的符号</td></tr><tr><td>POW 和 POWER</td><td>两个函数的功能相同，都是所传参数的次方的结果值</td></tr><tr><td>SIN</td><td>求正弦值</td></tr><tr><td>ASIN</td><td>求反正弦值，与函数 SIN 互为反函数</td></tr><tr><td>COS</td><td>求余弦值</td></tr><tr><td>ACOS</td><td>求反余弦值，与函数 COS 互为反函数</td></tr><tr><td>TAN</td><td>求正切值</td></tr><tr><td>ATAN</td><td>求反正切值，与函数 TAN 互为反函数</td></tr><tr><td>COT</td><td>求余切值</td></tr></tbody></table><h3 id="2、字符串函数"><a href="#2、字符串函数" class="headerlink" title="2、字符串函数"></a>2、字符串函数</h3><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>LENGTH</td><td>计算字符串长度函数，返回字符串的字节长度</td></tr><tr><td>CONCAT</td><td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td></tr><tr><td>INSERT</td><td>替换字符串函数</td></tr><tr><td>LOWER</td><td>将字符串中的字母转换为小写</td></tr><tr><td>UPPER</td><td>将字符串中的字母转换为大写</td></tr><tr><td>LEFT</td><td>从左侧字截取符串，返回字符串左边的若干个字符</td></tr><tr><td>RIGHT</td><td>从右侧字截取符串，返回字符串右边的若干个字符</td></tr><tr><td>TRIM</td><td>删除字符串左右两侧的空格</td></tr><tr><td>REPLACE</td><td>字符串替换函数，返回替换后的新字符串</td></tr><tr><td>SUBSTRING</td><td>截取字符串，返回从指定位置开始的指定长度的字符换</td></tr><tr><td>REVERSE</td><td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td></tr></tbody></table><h3 id="3、日期函数"><a href="#3、日期函数" class="headerlink" title="3、日期函数"></a>3、日期函数</h3><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>CURDATE 和 CURRENT_DATE</td><td>两个函数作用相同，返回当前系统的日期值</td></tr><tr><td>CURTIME 和 CURRENT_TIME</td><td>两个函数作用相同，返回当前系统的时间值</td></tr><tr><td>NOW 和 SYSDATE</td><td>两个函数作用相同，返回当前系统的日期和时间值</td></tr><tr><td>MONTH</td><td>获取指定日期中的月份</td></tr><tr><td>MONTHNAME</td><td>获取指定日期中的月份英文名称</td></tr><tr><td>DAYNAME</td><td>获取指定曰期对应的星期几的英文名称</td></tr><tr><td>DAYOFWEEK</td><td>获取指定日期对应的一周的索引位置值</td></tr><tr><td>WEEK</td><td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td></tr><tr><td>DAYOFYEAR</td><td>获取指定曰期是一年中的第几天，返回值范围是1~366</td></tr><tr><td>DAYOFMONTH</td><td>获取指定日期是一个月中是第几天，返回值范围是1~31</td></tr><tr><td>YEAR</td><td>获取年份，返回值范围是 1970〜2069</td></tr><tr><td>TIME_TO_SEC</td><td>将时间参数转换为秒数</td></tr><tr><td>SEC_TO_TIME</td><td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td></tr><tr><td>DATE_ADD 和 ADDDATE</td><td>两个函数功能相同，都是向日期添加指定的时间间隔</td></tr><tr><td>DATE_SUB 和 SUBDATE</td><td>两个函数功能相同，都是向日期减去指定的时间间隔</td></tr><tr><td>ADDTIME</td><td>时间加法运算，在原始时间上添加指定的时间</td></tr><tr><td>SUBTIME</td><td>时间减法运算，在原始时间上减去指定的时间</td></tr><tr><td>DATEDIFF</td><td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td></tr><tr><td>DATE_FORMAT</td><td>格式化指定的日期，根据参数返回指定格式的值</td></tr><tr><td>WEEKDAY</td><td>获取指定日期在一周内的对应的工作日索引</td></tr></tbody></table><h3 id="4、聚合函数"><a href="#4、聚合函数" class="headerlink" title="4、聚合函数"></a>4、聚合函数</h3><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>MAX</td><td>查询指定列的最大值</td></tr><tr><td>MIN</td><td>查询指定列的最小值</td></tr><tr><td>COUNT</td><td>统计查询结果的行数</td></tr><tr><td>SUM</td><td>求和，返回指定列的总和</td></tr><tr><td>AVG</td><td>求平均值，返回指定列数据的平均值</td></tr></tbody></table></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>MySQL高级学习（三）-MySQL锁问题、常用技巧和内存优化</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/2442351397.html">https://sutianxin.top/posts/2442351397.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-03-11</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-03-13</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%F0%9F%A4%93%E6%95%B0%E6%8D%AE%E5%BA%93/">🤓数据库</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/photo/raw/master/20210311212615.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3000794297.html"><img class="prev-cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311232028.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java面试总结（二）-hashCode()和equals()详解</div></div></a></div><div class="next-post pull-right"><a href="/posts/996934066.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309230829.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL高级学习（二）-MySQL体系结构、SQL优化、索引使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2904493033.html" title="MySQL高级学习（四）-MySQL日志和主从复制"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210312224658.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-12</div><div class="title">MySQL高级学习（四）-MySQL日志和主从复制</div></div></a></div><div><a href="/posts/1389856525.html" title="MySQL高级学习（一）-初识索引、复习视图、存储过程和函数以及触发器的学习"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307165930.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-07</div><div class="title">MySQL高级学习（一）-初识索引、复习视图、存储过程和函数以及触发器的学习</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-text">一、应用优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">1.1、使用数据库连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81C3P0"><span class="toc-text">1、C3P0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81HiKariCP"><span class="toc-text">2、HiKariCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Druid"><span class="toc-text">3、Druid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E5%87%8F%E5%B0%91%E5%AF%B9MySQL%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">1.2、减少对MySQL的访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%87%8F%E5%B0%91%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%A4%8D%E6%A3%80%E7%B4%A2"><span class="toc-text">1、减少对数据进行重复检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A2%9E%E5%8A%A0cache%E5%B1%82"><span class="toc-text">2、增加cache层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">1.3、负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%A9%E7%94%A8MySQL%E5%A4%8D%E5%88%B6%E5%88%86%E6%B5%81%E6%9F%A5%E8%AF%A2"><span class="toc-text">1、利用MySQL复制分流查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%87%87%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84"><span class="toc-text">2、采用分布式数据库架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81MySQL%E4%B8%AD%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-text">二、MySQL中查询缓存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2、操作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="toc-text">2.3、查询缓存配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">1、查看当前数据库是否支持查询缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8DMySQL%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BA%86%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">2、查看当前MySQL是否开启了查询缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9F%A5%E7%9C%8B%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E7%9A%84%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F"><span class="toc-text">3、查看查询缓存的占用大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%9F%A5%E7%9C%8B%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">4、查看查询缓存的状态变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81%E5%BC%80%E5%90%AF%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">2.4、开启查询缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E3%80%81%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98Select-%E9%80%89%E9%A1%B9"><span class="toc-text">2.5、查询缓存Select 选项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81MySQL%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96"><span class="toc-text">三、MySQL内存管理及优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="toc-text">3.1、内存优化原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81MyISAM-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-text">3.2、MyISAM 内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81key-bu%EF%AC%80er-size"><span class="toc-text">1、key_buﬀer_size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81read-bu%EF%AC%80er-size"><span class="toc-text">2、read_buﬀer_size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81read-rnd-bu%EF%AC%80er-size"><span class="toc-text">3、read_rnd_buﬀer_size</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81InnoDB-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-text">3.3、InnoDB 内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81innodb-bu%EF%AC%80er-pool-size"><span class="toc-text">1、innodb_buﬀer_pool_size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81innodb-log-bu%EF%AC%80er-size"><span class="toc-text">2、innodb_log_buﬀer_size</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MySQL-%E5%B9%B6%E5%8F%91%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4"><span class="toc-text">四、MySQL 并发参数调整</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81max-connections"><span class="toc-text">4.1、max_connections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81back-log"><span class="toc-text">4.2、back_log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81table-open-cache"><span class="toc-text">4.3、table_open_cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81thread-cache-size"><span class="toc-text">4.4、thread_cache_size</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E3%80%81innodb-lock-wait-timeout"><span class="toc-text">4.5、innodb_lock_wait_timeout</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81MySQL%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-text">五、MySQL锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E9%94%81%E6%A6%82%E8%BF%B0"><span class="toc-text">5.1、锁概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E9%94%81%E5%88%86%E7%B1%BB"><span class="toc-text">5.2、锁分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%8E%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86"><span class="toc-text">1、从对数据操作的粒度分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%8E%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%86"><span class="toc-text">2、从对数据操作的类型分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81MySQL-%E9%94%81"><span class="toc-text">5.3、MySQL 锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81MyISAM-%E8%A1%A8%E9%94%81"><span class="toc-text">5.4、MyISAM 表锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%8A%A0%E8%A1%A8%E9%94%81"><span class="toc-text">1、如何加表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AF%BB%E9%94%81%E6%A1%88%E4%BE%8B"><span class="toc-text">2、读锁案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%86%99%E9%94%81%E6%A1%88%E4%BE%8B"><span class="toc-text">3、写锁案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BB%93%E8%AE%BA"><span class="toc-text">4、结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81InnoDB%E8%A1%8C%E9%94%81"><span class="toc-text">5.4、InnoDB行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%A1%8C%E9%94%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、行锁介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-text">2、背景知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81InnoDB%E7%9A%84%E8%A1%8C%E9%94%81%E6%A8%A1%E5%BC%8F"><span class="toc-text">3、InnoDB的行锁模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A1%88%E4%BE%8B%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">4、案例环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%BC%94%E7%A4%BA-InnoDB-%E7%9A%84%E8%A1%8C%E9%94%81"><span class="toc-text">5、演示 InnoDB 的行锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81%E5%8D%B1%E5%AE%B3"><span class="toc-text">6、间隙锁危害</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%9F%A5%E7%9C%8BInnoDB%E8%A1%8C%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">7、查看InnoDB行锁争用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">8、总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8SQL%E6%8A%80%E5%B7%A7"><span class="toc-text">六、常用SQL技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81SQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">6.1、SQL执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F"><span class="toc-text">1、编写顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">2、执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">6.2、正则表达式的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">6.3、MySQL常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E5%AD%97%E5%87%BD%E6%95%B0"><span class="toc-text">1、数字函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">2、字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-text">3、日期函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-text">4、聚合函数</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    let initData = {
      el: '#twikoo-wrap',
      envId: 'blogcomments-2gseqioe1aa55c8c',
      region: 'ap-shanghai'
    }

    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    twikoo.init(initData)
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blogcomments-2gseqioe1aa55c8c',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_1cbsmfleajn.js"></script><script data-pjax src="/js/Lete.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script defer src="https://rmt.dogedoge.com/fetch/~/source/jsdelivr/npm/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/gh/sirxemic/jquery.ripples/dist/jquery.ripples.js"></script><script defer data-pjax src="/js/ripples.js"></script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax], .pjax-reload script').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>