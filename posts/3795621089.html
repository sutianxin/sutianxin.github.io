<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis学习手册（五）--Redis 学习补充 | Arno</title><meta name="keywords" content="☕Java,💻后端学习,👢Spring Boot"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis 学习补充"><meta property="og:type" content="article"><meta property="og:title" content="Redis学习手册（五）--Redis 学习补充"><meta property="og:url" content="https://sutianxin.top/posts/3795621089.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="Redis 学习补充"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217164531.jpg"><meta property="article:published_time" content="2022-02-17T08:41:59.880Z"><meta property="article:modified_time" content="2022-02-17T09:01:12.419Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="☕Java"><meta property="article:tag" content="💻后端学习"><meta property="article:tag" content="👢Spring Boot"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217164531.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/3795621089"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-02-17 17:01:12"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,a={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(a)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/blogImage/raw/master/img/20220217164531.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis学习手册（五）--Redis 学习补充</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-17T08:41:59.880Z" title="发表于 2022-02-17 16:41:59">2022-02-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-17T09:01:12.419Z" title="更新于 2022-02-17 17:01:12">2022-02-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、键和值用什么结构组织？"><a href="#1、键和值用什么结构组织？" class="headerlink" title="1、键和值用什么结构组织？"></a>1、键和值用什么结构组织？</h2><ul><li>为了实现从键到值的快速访问，<strong>Redis 使用了一个哈希表来保存所有的键值对</strong>，在哈希表的每一个桶中都保存了键值对数据。</li><li>在这个哈希表的 entry 结构中，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针，也就是说，不管 value 存放的数据类型是 string ，还是集合类型，哈希桶中的元素其实都只是指向它们的指针。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163348.png" alt="image.png"></p><ul><li><strong>Redis 解决哈希冲突的方法是拉链法</strong></li></ul><h2 id="2、Redis-全局哈希表的-rehash-操作"><a href="#2、Redis-全局哈希表的-rehash-操作" class="headerlink" title="2、Redis 全局哈希表的 rehash 操作"></a>2、Redis 全局哈希表的 rehash 操作</h2><h3 id="2-1、Redis-如何进行-rehash-操作？"><a href="#2-1、Redis-如何进行-rehash-操作？" class="headerlink" title="2.1、Redis 如何进行 rehash 操作？"></a>2.1、Redis 如何进行 rehash 操作？</h3><ul><li>使用拉链法来解决哈希冲突时会存在一个问题，也就是随着哈希表中的数据的写入，某个桶上的链表可能会变得非常长，这样在这个桶上查找元素时需要逐一遍历这个桶上的元素，效率不高，所以 Redis 会对哈希表进行 <strong>rehash</strong> 操作，也就是增加现有哈希桶的数量。</li><li><strong>为了 rehash 操作更加高效，Redis 默认使用了两个全局哈希表</strong>：分别记为哈希表 1 和哈希表 2 ，一开始插入数据时，默认使用哈希表 1 ，此时哈希表 2 并没有被分配空间。随着数据增多，Redis 需要进行 rehash ，这个过程分为三步：<ul><li>为哈希表 2 分配更大的空间，比如说是当前哈希表 1 大小的两倍</li><li>将哈希表 1 中的数据重新映射到哈希表 2 中</li><li>释放哈希表 1 的空间</li></ul></li></ul><blockquote><p>然后将哈希表 2 作为新的操作表，而释放完空间的哈希表 1 就作为下一次 rehash 时扩容的备用表。</p></blockquote><h3 id="2-2、渐进式-rehash"><a href="#2-2、渐进式-rehash" class="headerlink" title="2.2、渐进式 rehash"></a>2.2、渐进式 rehash</h3><blockquote><p>上面的过程看似简单，但是在 rehash 的第二步中涉及了大量的数据拷贝，如果一次性将哈希表 1 的数据全部迁移完，那么势必会造成 Redis 线程的阻塞，从而使其无法服务其他请求。</p></blockquote><ul><li>为了避免这个问题， Redis 使用了渐进式 rehash</li></ul><blockquote><p>在第二步拷贝数据时， Redis 仍然正常处理客户端请求，没处理一个请求，都从哈希表 1 中的第一个索引位置开始，顺带着将这个桶上的所有 entry 拷贝到哈希表 2 中；处理下一个请求时，顺带拷贝哈希表 1 下一个桶的 entry</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163408.png" alt="image.png"></p><h2 id="3、单线程的-Redis-为什么可以那么快？"><a href="#3、单线程的-Redis-为什么可以那么快？" class="headerlink" title="3、单线程的 Redis 为什么可以那么快？"></a>3、单线程的 Redis 为什么可以那么快？</h2><h3 id="3-1、说明"><a href="#3-1、说明" class="headerlink" title="3.1、说明"></a>3.1、说明</h3><blockquote><p><strong>Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的</strong>。而 Redis 的其他功能，比如说持久化，异步删除，集群数据同步等都是由额外的线程来执行。</p></blockquote><h3 id="3-2、Redis-为什么使用单线程？"><a href="#3-2、Redis-为什么使用单线程？" class="headerlink" title="3.2、Redis 为什么使用单线程？"></a>3.2、Redis 为什么使用单线程？</h3><ul><li><p>如果没有良好的系统设计，那么使用多线程反而会使得系统的吞吐量降低。</p></li><li><p>如果使用多线程，那么还需要考虑多线程共享资源的正确性，也就是为资源加锁，这会导致额外的开销</p></li><li><p>线程上下文的切换也可能会导致性能下降</p></li></ul><h3 id="3-3、Redis-为什么那么快？"><a href="#3-3、Redis-为什么那么快？" class="headerlink" title="3.3、Redis 为什么那么快？"></a>3.3、Redis 为什么那么快？</h3><ul><li>Redis 绝大部分操作都是在内存中完成的，同时 Redis 使用了高效的数据结构（例如哈希表和跳表），这是它高性能的一个重要原因。</li><li>Redis 采用了<strong>多路复用</strong>机制，使其在网络 IO 中能并发处理大量的客户端请求，实现高吞吐率。</li></ul><h2 id="4、AOF-重写会阻塞吗？"><a href="#4、AOF-重写会阻塞吗？" class="headerlink" title="4、AOF 重写会阻塞吗？"></a>4、AOF 重写会阻塞吗？</h2><ul><li>与 AOF 日志由主线程写回不同，AOF 的重写过程是由<strong>子进程 bgrewriteaof</strong> 来完成的，这也是为了避免阻塞主线程，导致 Redis 性能下降</li></ul><blockquote><p>AOF 重写的过程可以总结为<strong>一个拷贝，两处日志</strong></p></blockquote><ul><li>一个拷贝指每次执行重写时，主线程会 fork 出一个后台的 <code>bgrewriteaof</code> 子进程，此时，fork 会把主线程的内存拷贝一份给 <code>bgwriteaof</code> 子进程，这里面包含了 Redis 的最新数据。然后子进程在不影响主线程的情况下，将拷贝的数据写成操作，记入重写日志</li><li>第一处日志指正在使用的 AOF 日志，Redis 会将这个操作写到它的缓冲区。这样一来，即使 Redis 宕机，那么这个 AOF 日志中的内容也是齐全的，可以用于恢复数据。</li><li>第二处日志指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会被写入到新的 AOF 文件，以保证 Redis 最新状态的记录。</li></ul><blockquote><p>最后，就可以使用新的 AOF 文件代替原来的旧文件了。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163414.png" alt="image.png"></p><blockquote><p>总的来说，<strong>每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后使用两个日志保证重写过程中，新写入的数据不丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以重写过程不会阻塞主线程。</strong></p></blockquote><h2 id="5、Redis-哨兵"><a href="#5、Redis-哨兵" class="headerlink" title="5、Redis 哨兵"></a>5、Redis 哨兵</h2><ul><li><p>在 Redis 中，如果主库挂了，那么我们就需要运行一个新主库，比如说将一个从库切换为一个主库，把它当成主库，这其中涉及到三个问题：</p><ul><li>主库真的挂了吗？</li><li>该选择哪个从库作为主库？</li><li>怎么把新主库的相关信息通知给从库和客户端？</li></ul></li><li><p>Redis 的哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这三个问题。</p></li></ul><h3 id="5-1、哨兵机制的基本流程"><a href="#5-1、哨兵机制的基本流程" class="headerlink" title="5.1、哨兵机制的基本流程"></a>5.1、哨兵机制的基本流程</h3><ul><li><strong>哨兵其实就是一个运行在特殊模式下的 Redis 进程</strong>，主从库实例运行的同时，它也在运行。哨兵主要负责三个任务，即<strong>监控</strong>、<strong>选主</strong> 和 <strong>通知</strong></li></ul><ol><li>监控：<strong>哨兵在运行过程中，会周期性地给所有的主从库发送 PING 命令，检测它们是否存活</strong>。</li></ol><blockquote><p>如果从库没有在限定时间内响应哨兵的 PING 命令，那么哨兵会将其标记为下线状态；同样，<strong>如果主库没有在规定时间内响应哨兵的 PING 命令，那么哨兵就会判断主库下线，然后开始自动切换主库的流程</strong>。</p></blockquote><ol start="2"><li>选主：<strong>当主库下线后，哨兵需要从很多个从库中，按照一定的规则选择一个从库实例，把它作为新的主库</strong>，在这一步完成后，现有的主从集群里就有了新主库</li><li>通知：在新的主库出现后，哨兵会执行最后一个任务：通知。</li></ol><blockquote><p>在执行通知任务时，<strong>哨兵会把新主库的连接信息发送给其他从库，让它们执行 <code>replicaof</code> 命令，和新主库建立连接，并进行数据复制</strong>。</p><p>同时，<strong>哨兵会把新主库的连接信息发送给客户端，让它们将请求操作发到新主库上</strong>。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163420.png" alt="image.png"></p><ul><li>哨兵的通知任务相对来说比较简单，哨兵只需要将新主库的信息发送给从库和客户端，让它们与新主库建立连接就行，并不涉及决策的逻辑</li><li>在监控和选主两个任务中，哨兵需要做出两个决策：<ul><li>在监控任务中，哨兵需要判断主库是否处于下线状态</li><li>在选主任务中，哨兵需要决定哪个从库实例升级为主库</li></ul></li></ul><h3 id="5-2、主观下线和客观下线"><a href="#5-2、主观下线和客观下线" class="headerlink" title="5.2、主观下线和客观下线"></a>5.2、主观下线和客观下线</h3><blockquote><p>哨兵对主库的下线判断有<strong>主观下线</strong>和<strong>客观下线</strong>两种。</p></blockquote><ul><li>主观下线：</li></ul><blockquote><p><strong>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接状况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么就会先把它标记为主观下线</strong></p></blockquote><ol><li>如果检测的是从库，那么哨兵简单地将其标记为<strong>主观下线</strong>就可以了，因为从库的下线一般影响不大，集群对外服务不会间断。</li><li>如果检测的是主库，那么哨兵还不能简单地将其标记为<strong>主观下线</strong>，开启主从切换，因为可能存在这么一种情况：那就是哨兵误判了，其实主库没有故障。而一旦启动了主从切换，那么后续的选主和通知操作都会带来额外的开销。</li></ol><blockquote><p>哨兵的误判一般会发生在集群网络压力大，网络拥塞等情况。那么应该如何减少误判的发生？</p><p>哨兵一般采用多实例组成的集群模式进行部署，这也被称为<strong>哨兵集群</strong>。引入多个哨兵实例一起来判断，就可以避免因为单个哨兵网络不好，从而误判主库下线的情况。</p></blockquote><ul><li>客观下线：只有当哨兵集群中大多数哨兵实例都认为主库已经下线时，主库才会被标记为<strong>客观下线</strong>，如果走到这一步，那么证明主库的下线已经是客观事实了，此时需要进行主从切换。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163424.png" alt="image.png"></p><blockquote><p>当有 N 个哨兵实例时，最好要有 (N / 2) + 1 个实例判断主库为主观下线，才能最终判定主库为客观下线。</p></blockquote><h3 id="5-3、如何选定新主库？"><a href="#5-3、如何选定新主库？" class="headerlink" title="5.3、如何选定新主库？"></a>5.3、如何选定新主库？</h3><blockquote><p>一般来说，将哨兵选择新主库的过程称为<strong>筛选 + 打分</strong>。简单来说，我们从多个从库中，先按照一定的筛选条件，将不符合条件的从库去掉，然后再从剩下的从库中，按照一定规则打分，最终选择得分最高的从库作为新主库。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163427.png" alt="image.png"></p><ul><li>筛选条件：</li></ul><ol><li>需要是在线的从库才有资格参与选主（选新太子应该从活的皇子里选吧？）</li><li>需要判断从库的网络连接状态，如果某个在线的从库的网络状态差，那么也不能让它进入打分阶段，这是为了避免将其选为新主后，其因为网络连接状态差而挂掉。（身体有残疾或者得了重病的皇子应该不选，避免下一代皇帝也是短命鬼）</li></ol><ul><li>如何判断从库网络连接状况？</li></ul><blockquote><p>通过 Redis 的配置项 <code>down-after-milliseconds</code> ，其中 down-after-milliseconds 是我们认定主从库断连的最大超时时间。如果在 down-after-milliseconds 时间内，主从节点都没有通过网络连接上，那么我们就可以认为主从节点断连。如果断连次数超过十次，那么就说明这个从库的网络状况不好，不适合作为主库。</p></blockquote><ul><li>打分工作：</li></ul><blockquote><p>接下来就是要给剩下的从库进行打分，我们分别按照三个规则进行三轮打分，<strong>这三个规则分别是从库优先级、从库复制进度和从库 ID ，只要在某一轮中，有从库得分最高，那么它就是新主库了，如果没有出现得分最高的从库，那么继续下一轮</strong>。</p></blockquote><ol><li>优先级最高的从库得分高</li></ol><blockquote><p>用户可以通过 <code>slave-priority</code> 配置项，给不同的从库设置不同的优先级。</p><p><strong>如果在众多从库中有一个从库优先级最高，那么直接将其指定为新主库，如果从库的优先级都一样，那么进入第二轮打分</strong>。</p></blockquote><ol start="2"><li>和旧主库同步程度最接近的从库得分高</li></ol><blockquote><p>这个规则的依据是，如果选择和旧主库同步最接近的那个从库作为主库，那么，这个新主库上就有最新的数据。</p><p>这里使用主库记录的 <code>master_repl_offset</code> 和 从库的 <code>slave_repl_offset</code> ，从库的 <code>slave_repl_offset</code> 记录的就是复制进度，应该选择 <code>slave_repl_offset</code> 与主库的 <code>master_repl_offset</code> 最接近的从库作为新主库。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163432.png" alt="image.png"></p><blockquote><p>在上图中，我们应该选择从库 2 作为新主库，如果有多个从库的同步程度相同，那我们需要进行新一轮打分</p></blockquote><ol start="3"><li>ID 小的从库得分高</li></ol><blockquote><p>每一个从库实例都会有一个 ID ，这个 ID 相当于从库的编号，<strong>Redis 在选择主库时有一个默认规定：在优先级和复制进度相同的前提下，选择 ID 较小的从库作为新主库</strong>。</p></blockquote><h2 id="6、为什么主从库之间的复制不使用-AOF-？"><a href="#6、为什么主从库之间的复制不使用-AOF-？" class="headerlink" title="6、为什么主从库之间的复制不使用 AOF ？"></a>6、为什么主从库之间的复制不使用 AOF ？</h2><ul><li>RDB 文件是二进制文件，无论是要数据写入磁盘，还是网络传输，RDB 的 IO 效率都比 AOF 高</li><li>在从库进行文件恢复时，RDB 的恢复效率要远远高于 AOF</li></ul><h2 id="7、在主从切换过程中，客户端能否正常地进行请求操作？"><a href="#7、在主从切换过程中，客户端能否正常地进行请求操作？" class="headerlink" title="7、在主从切换过程中，客户端能否正常地进行请求操作？"></a>7、在主从切换过程中，客户端能否正常地进行请求操作？</h2><blockquote><p>主从集群一般采用读写分离模式，当主库故障后，客户端仍然可以将读请求发送给从库，让从库服务，但是，对于写请求操作，客户端就无法执行了。</p></blockquote><h2 id="8、Redis-什么时候进行-rehash？"><a href="#8、Redis-什么时候进行-rehash？" class="headerlink" title="8、Redis 什么时候进行 rehash？"></a>8、Redis 什么时候进行 rehash？</h2><blockquote><p>和 HashMap 的扩容一样， Redis 使用负载因子（load factor）来判断是否需要进行 rehash ，其中 <strong>load factor = 哈希表中所有的 entry 个数 / 哈希表中的桶数</strong></p></blockquote><ul><li>当 <code>load factor &gt;= 1</code> 时，哈希表允许被进行 rehash</li></ul><blockquote><p>当 load factor 大于 1 时，此时表示至少有一个桶上有两个元素，此时当有数据写入时，会对哈希表中查询较慢的桶进行 rehash</p></blockquote><ul><li>当 <code>load factor &gt;= 5</code> 时</li></ul><blockquote><p>此时表示保存的数据量远大于哈希桶的个数，哈希桶中存在大量哈希冲突的情况，此时要立马开始做 rehash</p></blockquote><ul><li>采用渐进式 rehash 时，即使实例暂时没有收到新请求，那么也会通过定时任务执行渐进式的 rehash 操作。</li></ul><h2 id="9、Redis-缓存的淘汰策略"><a href="#9、Redis-缓存的淘汰策略" class="headerlink" title="9、Redis 缓存的淘汰策略"></a>9、Redis 缓存的淘汰策略</h2><blockquote><p>Redis 一共有 8 种缓存淘汰策略</p></blockquote><ul><li>Redis 4.0 之前一共实现了 6 种缓存淘汰策略<ul><li>noeviction：不进行数据淘汰</li><li>volatile-lru：使用 LRU （最近最少使用）算法对存在过期时间的缓存进行淘汰</li><li>volatile-ttl：淘汰那些即将过期的缓存</li><li>volatile-random：随机淘汰那些即将过期的缓存</li><li>allkeys-random：在所有缓存中随机淘汰那些即将过期的缓存</li><li>allkeys-lru：在所有缓存中使用 LRU 算法进行淘汰</li></ul></li><li>Redis 4.0 后增加了两种缓存淘汰策略<ul><li>volatile-lfu：使用 LFU 算法对存在过期时间的缓存进行淘汰</li><li>allkeys-lfu：使用 LFU 算法对所有缓存进行淘汰</li></ul></li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163438.png" alt="image.png"></p><h2 id="10、Redis-的两种原子操作方法"><a href="#10、Redis-的两种原子操作方法" class="headerlink" title="10、Redis 的两种原子操作方法"></a>10、Redis 的两种原子操作方法</h2><ul><li><p>将多个操作在 Redis 中实现成一个操作，也就是单命令操作。</p></li><li><p>将多个操作写到一个 LUA 脚本中，以原子性的方式执行单个命令</p></li></ul><blockquote><p>当我们要执行的操作不是简单的增减值，而是有更复杂的判断逻辑或者是其他操作，那么，Redis 的单命令操作已经无法保证多个操作的互斥执行了，此时我们需要使用 LUA 脚本。</p><p><strong>Redis 会将整个 LUA 脚本作为一个整体执行，在执行过程中不会被其他命令打断，从而保证了 LUA 脚本中操作的原子性</strong>。</p></blockquote><h3 id="10-1、使用-Redis-LUA-脚本实现限制某个客户端在一定时间内的访问次数"><a href="#10-1、使用-Redis-LUA-脚本实现限制某个客户端在一定时间内的访问次数" class="headerlink" title="10.1、使用 Redis + LUA 脚本实现限制某个客户端在一定时间内的访问次数"></a>10.1、使用 Redis + LUA 脚本实现限制某个客户端在一定时间内的访问次数</h3><ul><li>我们可以将客户端 IP 作为 Key，将客户端的访问次数作为 value ，保存在 Redis 中，客户端每访问一次，就使用 INCR 命令增加访问次数。</li></ul><blockquote><p>由于在这个操作中包含了判断逻辑，我们需要保证这段逻辑的原子性，此时使用 Redis 自带的单命令不能保证原子性，此时我们可以使用 LUA 脚本完成</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 获取 ip 对应的访问次数</span><br><span class="line">currentIP = GET(ip)</span><br><span class="line">// 如果访问次数超过 <span class="number">20</span> 次，那么直接报错</span><br><span class="line">IF currentIP != NULL AND currentIP &gt; <span class="number">20</span> THEN</span><br><span class="line">    ERROR <span class="string">&quot;exceed 20 access per minute&quot;</span></span><br><span class="line">ELSE </span><br><span class="line">    // 如果访问次数不足 <span class="number">20</span> 次，那么增加一次访问次数</span><br><span class="line">    value = INCR(ip)</span><br><span class="line">    // 如果是第一次访问，则将键值对的过期时间设置为 <span class="number">60</span> s </span><br><span class="line">    IF (value == <span class="number">1</span>) THEN </span><br><span class="line">         EXPIRE(ip, <span class="number">60</span>)</span><br><span class="line">    ELSE </span><br><span class="line">	 // 执行操作</span><br><span class="line">END</span><br></pre></td></tr></table></figure><ul><li>在 Redis 中，我们可以使用 Redis 的 EVAL 命令来执行 LUA 脚本</li></ul><h2 id="11、Redis-6-新增的数据类型-–-BitMaps"><a href="#11、Redis-6-新增的数据类型-–-BitMaps" class="headerlink" title="11、Redis 6 新增的数据类型 – BitMaps"></a>11、Redis 6 新增的数据类型 – BitMaps</h2><h3 id="11-1、简介"><a href="#11-1、简介" class="headerlink" title="11.1、简介"></a>11.1、简介</h3><blockquote><p><strong>现代计算机使用二进制（位）作为信息的基础单位</strong>，一个字节等于 8 位，即（1 byte = 8 bit），例如 “abc” 字符串由三个字节组成，但实际在计算机存储时将其使用二进制表示，”abc” 分别对应的 ASCII 码为 97 98 99 ，对应的二进制位为 <code>01100001</code> 、 <code>01100010</code> 和 <code>01100011</code> ，如下图</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163443.png" alt="image.png"></p><blockquote><p><strong>合理使用操作位可以有效地提高内存利用率和开发效率</strong>，Redis 提供了 <code>Bitmaps</code> 这个数据类型，它可以实现对位的操作：</p></blockquote><ul><li><code>Bitmaps</code> 本身不是一种数据类型，<strong>实际上它就是字符串（Key-Value），但它可以对字符串的位进行操作。</strong></li><li><code>Bitmaps</code> 单独提供了一套命令，所以在 Redis 中使用 <code>Bitmaps</code> 和使用字符串的方法不太相同。<strong>可以将 Bitmaps 想象成一个以位为单位的数组，数组中的每个单元只能存储 0 和 1 ，数组的下标在 Bitmaps 中叫做偏移量。</strong></li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163446.png" alt="image.png"></p><h3 id="11-2、setbit-命令"><a href="#11-2、setbit-命令" class="headerlink" title="11.2、setbit 命令"></a>11.2、setbit 命令</h3><ul><li><p>作用：设置 bitmaps 中某个偏移量的值（只能设置为 0 或 1）</p></li><li><p>格式：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set &lt;key&gt; &lt;offset&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>offset （偏移量）从 0 开始</strong></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163452.png" alt="image.png"></p><ul><li>实例：判断用户是否访问过网站</li></ul><blockquote><p><strong>我们将用户 id 作为数组偏移量，如果用户在该天访问过用户，那么将数组对应偏移量的值设置为 1 ，否则设置为 0</strong> ，假设现在有 20 个用户，其中用户 id 为 1 ， 6 ， 11 ， 15 ， 19 的用户对网站进行了访问，那么当前 <code>Bitmaps</code> 初始化结果为：</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163455.png" alt="image.png"></p><blockquote><p>其中键 <code>unique:users:20201106</code> 代表在 2020-11-06 这一天用户访问记录的 <code>Bitmaps</code></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163459.png" alt="image.png"></p><ol><li>很多应用的用户 id 都会以一个指定数字开头，如果直接将用户 id 和 Bitmaps 的偏移量对应势必会造成一定的浪费，通常的做法是每次做 setbit 操作时将用户 id 减去这个数字。</li><li>在第一次初始化 Bitmaps 时，如果偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成 Redis 的阻塞。</li></ol><h3 id="11-3、getbit-命令"><a href="#11-3、getbit-命令" class="headerlink" title="11.3、getbit 命令"></a>11.3、getbit 命令</h3><ul><li>作用：用于获取 <code>Bitmaps</code> 中某个偏移量的值</li><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit &lt;key&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure><blockquote><p>获取键对应 bitmaps 的第 offset 位的值（offset 从 0 开始）</p></blockquote><ul><li>实例：判断用户 id 为 8 的用户在 2020-11-06 这一天是否访问过网站</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit unique:users:<span class="number">20201106</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163503.png" alt="image.png"></p><blockquote><p>结果为 0 ，证明 id 为 8 的用户在 2020-11-06 这一天没有访问过网站</p></blockquote><h3 id="11-4、bitcount-命令"><a href="#11-4、bitcount-命令" class="headerlink" title="11.4、bitcount 命令"></a>11.4、bitcount 命令</h3><ul><li>作用：<strong>这个命令用于统计位图中被设置为 1 的 bit 数</strong>。</li></ul><blockquote><p><strong>一般情况下，给定的整个位图都会被进行计数，通过指定额外的 <code>start</code> 和 <code>end</code> 参数，可以让计数只在特定的位上进行</strong>。</p><p><code>start</code> 和 <code>end</code> 参数都可以使用负数值：比如说 -1 表示最后一个位，而 -2 表示倒数第二个位，**<code>start</code> 和 <code>end</code> 是指位图中 offset 的下标数，二者皆包含，即 [<code>start</code> , <code>end</code> ]**</p></blockquote><ul><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount &lt;key&gt; [start end]</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163507.png" alt="image.png"></p><ul><li>实例：统计 2020-11-06 这天访问网站的用户数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount unique:users:<span class="number">20201106</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163514.png" alt="image.png"></p><h3 id="11-5、bitop-命令"><a href="#11-5、bitop-命令" class="headerlink" title="11.5、bitop 命令"></a>11.5、bitop 命令</h3><ul><li><p>作用：<code>bitop</code> 是一个符合操作，<strong>它可以做多个 Bitmaps 的 and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存到 destkey 中</strong></p></li><li><p>格式</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitop <span class="title">and</span><span class="params">(or/not/xor)</span> &lt;destkey&gt; [key...]</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163519.png" alt="image.png"></p><ul><li>实例：统计 2020-11-06 和 2020-11-07 两天都访问过网站的用户</li></ul><ol><li>假设 2020-11-06 访问网站的 userid = 1，2，5，9</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setbit unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">06</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">setbit unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">06</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">setbit unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">06</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line">setbit unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">06</span> <span class="number">9</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>假设 2020-11-07 访问网站的 userid = 0，1，4，9</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setbit unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">07</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">setbit unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">07</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">setbit unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">07</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">setbit unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">07</span> <span class="number">9</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>我们使用 <code>bitop</code> 命令将两天都访问过网站的用户计算出来，并保存到 key 为 <code>unique:users:2020110620201107</code> 中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop and unique:users:<span class="number">2020110620201107</span> unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">06</span> unique:users:<span class="number">2020</span>-<span class="number">11</span>-<span class="number">07</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 bitcount 统计 key 为 <code>unique:users:2020110620201107</code> 的位图的用户数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount unique:users:<span class="number">2020110620201107</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163522.png" alt="image.png"></p><blockquote><p>示意图如下</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163525.png" alt="image.png"></p><h3 id="11-6、Bitmaps-与-Set-对比"><a href="#11-6、Bitmaps-与-Set-对比" class="headerlink" title="11.6、Bitmaps 与 Set 对比"></a>11.6、Bitmaps 与 Set 对比</h3><blockquote><p>假设网站有一亿用户，每天独立访问的用户有 5 千万，如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表如下</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163530.png" alt="image.png"></p><blockquote><p>很明显，这种情况下使用 Bitmaps 可以节省非常多空间，尤其是随着时间推移节省的内存十分可观</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163533.png" alt="image.png"></p><blockquote><p>但 Bitmaps 不是万金油，假设网站每天访问的独立用户非常少，例如只有 10 万，那么二者的对比如下表所示</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163537.png" alt="image.png"></p><blockquote><p>这个时候使用 Bitmaps 就不太合适了，因为此时基本上大部分位都是 0</p></blockquote><h2 id="12、Redis-Cluster-集群"><a href="#12、Redis-Cluster-集群" class="headerlink" title="12、Redis Cluster 集群"></a>12、Redis Cluster 集群</h2><h3 id="12-1、特点"><a href="#12-1、特点" class="headerlink" title="12.1、特点"></a>12.1、特点</h3><ul><li><strong>多主多从，去中心化</strong>，从节点不提供服务，而只是单纯作为主节点的备用节点</li><li><strong>不支持处理多个 Key</strong>：因为数据分散在多个节点，在数据量高并发情况下会影响性能。</li><li><strong>支持动态扩展节点</strong></li><li><strong>节点之间相互通信，不再依赖哨兵，保证及时故障转移</strong></li><li>Redis 集群不像单机 Redis 那样支持多数据库功能， <strong>集群只使用默认的 <code>0</code> 号数据库</strong></li></ul><h3 id="12-2、Redis-Cluster-集群的键分布模型"><a href="#12-2、Redis-Cluster-集群的键分布模型" class="headerlink" title="12.2、Redis Cluster 集群的键分布模型"></a>12.2、Redis Cluster 集群的键分布模型</h3><ul><li>Redis 集群的键空间被分割为 <code>16384（16 * 1024）</code> 个槽（slot），集群的最大节点数量也是 <code>16384</code> 个，每个键值对会根据它的 key ，然后被映射到一个哈希槽中。</li><li>Redis 会自动把这个槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么每个实例上的槽个数为 <code>16384 / N</code> 个槽</li></ul><blockquote><p>映射过程分为两大步：</p></blockquote><ul><li>首先根据键值对的 key ，按照 <strong>CRC16</strong> 算法计算一个 16 bit 的值</li><li>再用这个 16 bit 的值对 <code>16384</code> 进行取模，得到一个 <code>0 - 16383</code> 之间的值</li></ul><blockquote><p>HASH_SLOT = CRC16(key) mod 16384</p></blockquote><h3 id="12-3、Redis-Cluster-是如何保证高可用的？"><a href="#12-3、Redis-Cluster-是如何保证高可用的？" class="headerlink" title="12.3、Redis Cluster 是如何保证高可用的？"></a>12.3、Redis Cluster 是如何保证高可用的？</h3><blockquote><p>Redis Cluster 保证高可用主要是依靠：<strong>故障检测</strong>和<strong>故障转移</strong>两种策略</p></blockquote><ol><li>故障转移</li></ol><blockquote><p>我们为 Redis Cluster 的实例添加从节点，从节点不提供服务，只复制主节点，当集群中的实例下线时，就可以在下线实例的从节点中选举一个新的主节点。</p><p>比如说现在实例中有 4 个实例，其中实例一存在两个从节点</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163543.png" alt="image.png"></p><blockquote><p>当 <code>ip1:6379</code> 下线时，我们就从它的从节点中选取出一个新的主节点，代替原来下线的实例</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163546.png" alt="image.png"></p><blockquote><p>当 <code>ip1:6379</code> 重新上线时，它会作为 <code>ip5:6379</code> 的新的从节点</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163550.png" alt="image.png"></p><ol start="2"><li>故障检测</li></ol><ul><li>Redis Cluster 采用一种<strong>相互监督</strong>的方式来检测集群中的实例是否健康，每个实例都会定期地向集群中的其他节点发送 PING 消息，以检测对方是否在线；</li></ul><blockquote><p>如果接收 Ping 消息的节点没有在规定的时间内回传 PONG 消息，那么发送 PING 消息的节点就会将该节点标记为疑似下线（PFAIL）</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163553.png" alt="image.png"></p><ul><li>如果在集群中，超过半数以上负责处理槽的主节点都将某个节点 X 标记为疑似下线，那么某个主节点就会将 X 标记为已下线，然后广播这条消息</li></ul><blockquote><p>这样其他所有主节点都会将 X 标记为已下线，此时需要进行故障转移。</p></blockquote><h2 id="13、Redis-有序集合-Zset-（Sorted-Set）"><a href="#13、Redis-有序集合-Zset-（Sorted-Set）" class="headerlink" title="13、Redis 有序集合 Zset （Sorted Set）"></a>13、Redis 有序集合 Zset （Sorted Set）</h2><h3 id="13-1、简介"><a href="#13-1、简介" class="headerlink" title="13.1、简介"></a>13.1、简介</h3><ul><li>有序集合 Zset 与普通集合 set 非常相似，它<strong>是一个没有重复元素的字符串集合</strong></li></ul><blockquote><p>不同之处是有序集合的每个成员都关联了一个评分（score），这个评分被用于从最低分到最高分的方式排序集合中的成员。</p></blockquote><ul><li><p>集合中的成员是唯一的，但是评分可以是重复的。</p></li><li><p>因为集合是有序的，所以我们<strong>可以很快地根据评分或者次序来获取一个范围内的元素</strong></p></li></ul><blockquote><p>访问有序集合的中间元素也是非常快的，因此我们可以使用有序集合作为一个 没有重复成员的只能列表。</p></blockquote><h3 id="13-2、zadd-命令"><a href="#13-2、zadd-命令" class="headerlink" title="13.2、zadd 命令"></a>13.2、zadd 命令</h3><ul><li><p>作用：将一个或者多个 member 元素及其 score 加入到有序集合 key 中</p></li><li><p>格式：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163557.png" alt="image.png"></p><ul><li>实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd topN <span class="number">200</span> java <span class="number">300</span> CPP <span class="number">400</span> C</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163600.png" alt="image.png"></p><h3 id="13-3、zrange-命令"><a href="#13-3、zrange-命令" class="headerlink" title="13.3、zrange 命令"></a>13.3、zrange 命令</h3><ul><li><p>作用：返回有序集合 key 中，下标在 [start, stop] 之间的元素，如果带上 WITHSCORES ，那么可以让分数一起和值返回到结果值。</p></li><li><p>格式：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [WITHSCORES]</span><br></pre></td></tr></table></figure><ul><li>实例：</li></ul><ol><li>取出有序集合中的所有内容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange topN <span class="number">0</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163603.png" alt="image.png"></p><blockquote><p>将值与分数一同返回到结果集中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange topN <span class="number">0</span> -<span class="number">1</span> WITHSCORES</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163605.png" alt="image.png"></p><ol start="2"><li>返回有序集合中下标在 [0,1] 之间的元素，连同分数一起返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange topN <span class="number">0</span> <span class="number">1</span> WITHSCORES</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163608.png" alt="image.png"></p><h3 id="13-4、zrangebyscore-命令"><a href="#13-4、zrangebyscore-命令" class="headerlink" title="13.4、zrangebyscore 命令"></a>13.4、zrangebyscore 命令</h3><ul><li>作用：返回有序集合 key 中，所有 score 值处于 [min , max] 之间的成员，按照 score 从小到大排序</li><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [withscores] [limit offset count]</span><br></pre></td></tr></table></figure><ul><li>实例：返回有序集合 topN 中 score 处于 [300, 500] 之间的成员，连带他们的 score 一起返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore topN <span class="number">300</span> <span class="number">500</span> WITHSCORES</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163611.png" alt="image.png"></p><h3 id="13-5、zrevrangebyscore-命令"><a href="#13-5、zrevrangebyscore-命令" class="headerlink" title="13.5、zrevrangebyscore 命令"></a>13.5、zrevrangebyscore 命令</h3><ul><li>作用：返回有序集合 key 中，所有 score 值处于 [min , max] 之间的成员，按照 score 从大到小排序</li><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrangebyscore key max min [withscores] [limit offset count]</span><br></pre></td></tr></table></figure><ul><li>实例：</li></ul><ol><li>逆序排序所有成员</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrangebyscore topN +inf -inf </span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163614.png" alt="image.png"></p><ol start="2"><li>逆序排序所有成员并取前 2 条</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrangebyscore topN +inf -inf limit <span class="number">0</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163617.png" alt="image.png"></p><h3 id="13-6、zincrby-命令"><a href="#13-6、zincrby-命令" class="headerlink" title="13.6、zincrby 命令"></a>13.6、zincrby 命令</h3><ul><li>作用：为元素的 score 值加上增量</li><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><h3 id="13-7、zrem-命令"><a href="#13-7、zrem-命令" class="headerlink" title="13.7、zrem 命令"></a>13.7、zrem 命令</h3><ul><li>作用：删除该集合下指定元素的集合</li><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><h3 id="13-8、zcount-命令"><a href="#13-8、zcount-命令" class="headerlink" title="13.8、zcount 命令"></a>13.8、zcount 命令</h3><ul><li>作用：统计该集合中，分数处于 [min, max] 区间的元素个数</li><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</span><br></pre></td></tr></table></figure><h3 id="13-9、zrank-命令"><a href="#13-9、zrank-命令" class="headerlink" title="13.9、zrank 命令"></a>13.9、zrank 命令</h3><ul><li>作用：返回该值在集合中的排名，从 0 开始</li><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrank &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><h2 id="14、Zset-的底层实现"><a href="#14、Zset-的底层实现" class="headerlink" title="14、Zset 的底层实现"></a>14、Zset 的底层实现</h2><h3 id="14-1、概述"><a href="#14-1、概述" class="headerlink" title="14.1、概述"></a>14.1、概述</h3><blockquote><p>ZSet 底层的存储结构包括<strong>压缩列表 <code>ziplist</code></strong> 和**跳表 <code>skiplist</code>**。</p></blockquote><ul><li>Redis 如何决定使用 ziplist 还是 skiplist？</li></ul><blockquote><p>在 Redis 配置文件中存在两个属性，分别是 <code>zset-max-ziplist-entries 128</code> 和 <code>zset-max-ziplist-value 64（字节）</code>，<strong>当集合内元素个数小于 128 个且集合内保存的所有元素的长度小于 64 字节时使用 ziplist，否则使用 skiplist</strong></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217163625.png" alt="image.png"></p><blockquote><p>从上面的源码可以看到，只要两个条件（集合内元素个数 大于 128 或集合内元素长度有一个大于 64 字节）有一个满足时，就会执行 <code>zsetConvert</code> 方法，这个方法会将底层数据结构由 ziplist 变为 skiplist</p></blockquote><ul><li>集合内存储的元素分值相同时，Redis 会如何进行处理</li></ul><blockquote><p>所有节点的分值是按从小到大的方式进行排序的，当有序集合中成员分值相同时，节点会按照成员的字典序进行排序。</p></blockquote><h3 id="14-2、有序集合的结构体"><a href="#14-2、有序集合的结构体" class="headerlink" title="14.2、有序集合的结构体"></a>14.2、有序集合的结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有序集合结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Redis 会将跳跃表中所有的元素和分值组成 </span></span><br><span class="line"><span class="comment">     * key-value 的形式保存在字典中</span></span><br><span class="line"><span class="comment">     * todo：注意：该字典并不是 Redis DB 中的字典，只属于有序集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 底层指向的跳跃表的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><ul><li>当使用 ziplist 作为底层存储结构时，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。</li><li>当使用 skiplist 作为底层存储结构时，使用 skiplist 保存元素及分值，使用一个字典来保存元素和分值的映射关系。</li></ul><blockquote><p>跳跃表的查找复杂度为平均 O(logN)，最坏 O(N)，效率堪比红黑树，却远比红黑树实现简单。跳跃表是在链表的基础上，通过增加索引来提高查找效率的。</p><p><strong>字典和跳表会通过指针来共享相同元素的成员和分值，所以不会产生重复的成员和分支，也就不会造成空间浪费。</strong></p></blockquote><h3 id="14-3、为什么有序集合需要引入字典？"><a href="#14-3、为什么有序集合需要引入字典？" class="headerlink" title="14.3、为什么有序集合需要引入字典？"></a>14.3、为什么有序集合需要引入字典？</h3><blockquote><p>其实有序集合单独使用字典或者跳跃表其中一种元素都可以实现，但是 Redis 将两种数据结构组合起来实现 Zset 。</p></blockquote><ul><li>如果单独使用字典，那么我们虽然可以以 O(1) 的时间复杂度查找成员的分值，但是由于字典是以无需的方式来保存集合元素的，所以每次进行范围操作时我们都需要对无序的数据进行排序。</li><li>如果单独使用跳跃表来实现，那么我们虽然可以很方便地进行范围操作，但是查找操作的时间复杂度变为了 O(logN)，所以 Redis 使用了两个数据结构来共同实现有序集合。</li></ul><h3 id="14-4、为什么跳表不使用树形结构？"><a href="#14-4、为什么跳表不使用树形结构？" class="headerlink" title="14.4、为什么跳表不使用树形结构？"></a>14.4、为什么跳表不使用树形结构？</h3><ul><li><strong>Zset 有一个核心操作：范围查找，而跳表效率比红黑树高</strong>，跳表可以做到在 O(logN) 时间复杂度内快速查找，我们只需要找到范围数据的起点，然后向后遍历即可。</li><li>跳表的实现比红黑树简单易懂，且没有红黑树的 rebalance 操作</li></ul></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Redis学习手册（五）--Redis 学习补充</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/3795621089.html">https://sutianxin.top/posts/3795621089.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2022-02-17</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2022-02-17</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%98%95Java/">☕Java</a><a class="post-meta__tags" href="/tags/%F0%9F%92%BB%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/">💻后端学习</a><a class="post-meta__tags" href="/tags/%F0%9F%91%A2Spring-Boot/">👢Spring Boot</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217164531.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1528548504.html"><img class="prev-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165848.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL高级学习（五）-MySQL学习补充</div></div></a></div><div class="next-post pull-right"><a href="/posts/3573133955.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211214204014.png" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM学习笔记（五）-JVM 学习补充</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2938255980.html" title="Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210208120213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-12</div><div class="title">Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用</div></div></a></div><div><a href="/posts/913123791.html" title="Spring Cloud学习（七）-Spring Cloud Config"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210516192228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="title">Spring Cloud学习（七）-Spring Cloud Config</div></div></a></div><div><a href="/posts/2863462089.html" title="Spring Cloud学习（二）-OpenFeign微服务调用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504192527.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-11</div><div class="title">Spring Cloud学习（二）-OpenFeign微服务调用</div></div></a></div><div><a href="/posts/995752607.html" title="Spring Cloud学习（四）-Eureka服务注册中心"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210214225250.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-14</div><div class="title">Spring Cloud学习（四）-Eureka服务注册中心</div></div></a></div><div><a href="/posts/650479038.html" title="在线教育项目总结（二）-用户认证"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210205204706.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-05</div><div class="title">在线教育项目总结（二）-用户认证</div></div></a></div><div><a href="/posts/4109687940.html" title="在线教育项目总结（四）-使用递归查询嵌套列表和删除嵌套列表"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210210223743.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-10</div><div class="title">在线教育项目总结（四）-使用递归查询嵌套列表和删除嵌套列表</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%94%AE%E5%92%8C%E5%80%BC%E7%94%A8%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%EF%BC%9F"><span class="toc-text">1、键和值用什么结构组织？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Redis-%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84-rehash-%E6%93%8D%E4%BD%9C"><span class="toc-text">2、Redis 全局哈希表的 rehash 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81Redis-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C-rehash-%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-text">2.1、Redis 如何进行 rehash 操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E6%B8%90%E8%BF%9B%E5%BC%8F-rehash"><span class="toc-text">2.2、渐进式 rehash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-text">3、单线程的 Redis 为什么可以那么快？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E8%AF%B4%E6%98%8E"><span class="toc-text">3.1、说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">3.2、Redis 为什么使用单线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-text">3.3、Redis 为什么那么快？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81AOF-%E9%87%8D%E5%86%99%E4%BC%9A%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F"><span class="toc-text">4、AOF 重写会阻塞吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Redis-%E5%93%A8%E5%85%B5"><span class="toc-text">5、Redis 哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-text">5.1、哨兵机制的基本流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF%E5%92%8C%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF"><span class="toc-text">5.2、主观下线和客观下线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E5%A6%82%E4%BD%95%E9%80%89%E5%AE%9A%E6%96%B0%E4%B8%BB%E5%BA%93%EF%BC%9F"><span class="toc-text">5.3、如何选定新主库？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E4%BB%8E%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8D%E4%BD%BF%E7%94%A8-AOF-%EF%BC%9F"><span class="toc-text">6、为什么主从库之间的复制不使用 AOF ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%9C%A8%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%83%BD%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%9C%B0%E8%BF%9B%E8%A1%8C%E8%AF%B7%E6%B1%82%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-text">7、在主从切换过程中，客户端能否正常地进行请求操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Redis-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C-rehash%EF%BC%9F"><span class="toc-text">8、Redis 什么时候进行 rehash？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Redis-%E7%BC%93%E5%AD%98%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">9、Redis 缓存的淘汰策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81Redis-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-text">10、Redis 的两种原子操作方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81%E4%BD%BF%E7%94%A8-Redis-LUA-%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E4%B8%80%E5%AE%9A%E6%97%B6%E9%97%B4%E5%86%85%E7%9A%84%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0"><span class="toc-text">10.1、使用 Redis + LUA 脚本实现限制某个客户端在一定时间内的访问次数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81Redis-6-%E6%96%B0%E5%A2%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E2%80%93-BitMaps"><span class="toc-text">11、Redis 6 新增的数据类型 – BitMaps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">11.1、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2%E3%80%81setbit-%E5%91%BD%E4%BB%A4"><span class="toc-text">11.2、setbit 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3%E3%80%81getbit-%E5%91%BD%E4%BB%A4"><span class="toc-text">11.3、getbit 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4%E3%80%81bitcount-%E5%91%BD%E4%BB%A4"><span class="toc-text">11.4、bitcount 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5%E3%80%81bitop-%E5%91%BD%E4%BB%A4"><span class="toc-text">11.5、bitop 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6%E3%80%81Bitmaps-%E4%B8%8E-Set-%E5%AF%B9%E6%AF%94"><span class="toc-text">11.6、Bitmaps 与 Set 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81Redis-Cluster-%E9%9B%86%E7%BE%A4"><span class="toc-text">12、Redis Cluster 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-text">12.1、特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2%E3%80%81Redis-Cluster-%E9%9B%86%E7%BE%A4%E7%9A%84%E9%94%AE%E5%88%86%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-text">12.2、Redis Cluster 集群的键分布模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3%E3%80%81Redis-Cluster-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">12.3、Redis Cluster 是如何保证高可用的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-Zset-%EF%BC%88Sorted-Set%EF%BC%89"><span class="toc-text">13、Redis 有序集合 Zset （Sorted Set）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">13.1、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2%E3%80%81zadd-%E5%91%BD%E4%BB%A4"><span class="toc-text">13.2、zadd 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3%E3%80%81zrange-%E5%91%BD%E4%BB%A4"><span class="toc-text">13.3、zrange 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4%E3%80%81zrangebyscore-%E5%91%BD%E4%BB%A4"><span class="toc-text">13.4、zrangebyscore 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5%E3%80%81zrevrangebyscore-%E5%91%BD%E4%BB%A4"><span class="toc-text">13.5、zrevrangebyscore 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6%E3%80%81zincrby-%E5%91%BD%E4%BB%A4"><span class="toc-text">13.6、zincrby 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7%E3%80%81zrem-%E5%91%BD%E4%BB%A4"><span class="toc-text">13.7、zrem 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8%E3%80%81zcount-%E5%91%BD%E4%BB%A4"><span class="toc-text">13.8、zcount 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9%E3%80%81zrank-%E5%91%BD%E4%BB%A4"><span class="toc-text">13.9、zrank 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81Zset-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">14、Zset 的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">14.1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2%E3%80%81%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">14.2、有序集合的结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5%E5%AD%97%E5%85%B8%EF%BC%9F"><span class="toc-text">14.3、为什么有序集合需要引入字典？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B7%B3%E8%A1%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">14.4、为什么跳表不使用树形结构？</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init({el:"#twikoo-wrap",envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai"})},e=()=>{twikoo.getCommentsCount({envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then(function(o){t.innerText=o[0].count}).catch(function(o){console.error(o)})};var n;n=!0,"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" data-lrctype="0" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_yegv7kt2bj.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.js"></script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><script src="https://www.luckyclover.top/rain.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"]):not([href="/contact/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>