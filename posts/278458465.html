<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构与算法学习（二十一）-动态规划 | Arno</title><meta name="keywords" content="☕Java,💻后端学习"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="二、动态规划2.1、概念说明 动态规划，即 Dynamic Programming ，简称 DP ，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 动态规划中每一个状态一定是由上一个状态推导出来的 遍历顺序的确定   对于遍历顺序，我们只需要确定两点   遍历的过程中，所需的状态必须是已经计算出来的 遍历的终点必须是存储结果的那个位置。  2.2、使用最小花费爬楼梯1、题目描述 数组的每个"><meta property="og:type" content="article"><meta property="og:title" content="数据结构与算法学习（二十一）-动态规划"><meta property="og:url" content="https://sutianxin.top/posts/278458465.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="二、动态规划2.1、概念说明 动态规划，即 Dynamic Programming ，简称 DP ，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 动态规划中每一个状态一定是由上一个状态推导出来的 遍历顺序的确定   对于遍历顺序，我们只需要确定两点   遍历的过程中，所需的状态必须是已经计算出来的 遍历的终点必须是存储结果的那个位置。  2.2、使用最小花费爬楼梯1、题目描述 数组的每个"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20211202163900.jpg"><meta property="article:published_time" content="2021-12-02T08:36:03.000Z"><meta property="article:modified_time" content="2021-12-16T16:17:13.609Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="☕Java"><meta property="article:tag" content="💻后端学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20211202163900.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/278458465"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-12-17 00:17:13"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,a={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(a)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/blogImage/raw/master/img/20211202163900.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法学习（二十一）-动态规划</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-02T08:36:03.000Z" title="发表于 2021-12-02 16:36:03">2021-12-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-16T16:17:13.609Z" title="更新于 2021-12-17 00:17:13">2021-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.5k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h1><h2 id="2-1、概念说明"><a href="#2-1、概念说明" class="headerlink" title="2.1、概念说明"></a>2.1、概念说明</h2><ul><li>动态规划，即 <code>Dynamic Programming</code> ，简称 DP ，如果某一问题有很多<strong>重叠子问题</strong>，使用动态规划是最有效的。</li><li>动态规划中<strong>每一个状态一定是由上一个状态推导出来的</strong></li><li>遍历顺序的确定</li></ul><blockquote><p>对于遍历顺序，我们只需要确定两点</p></blockquote><ol><li>遍历的过程中，所需的状态必须是已经计算出来的</li><li>遍历的终点必须是存储结果的那个位置。</li></ol><h2 id="2-2、使用最小花费爬楼梯"><a href="#2-2、使用最小花费爬楼梯" class="headerlink" title="2.2、使用最小花费爬楼梯"></a>2.2、使用最小花费爬楼梯</h2><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>]</span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：最低花费是从 cost[<span class="number">1</span>] 开始，然后走两步即可到阶梯顶，一共花费 <span class="number">15</span> </span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最低花费方式是从 cost[<span class="number">0</span>] 开始，逐个经过那些 <span class="number">1</span> ，跳过 cost[<span class="number">3</span>] ，一共花费 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>我们首先需要确定 dp 数组中元素的含义，在这道题中 <code>dp[i]</code> 表示到第 i 个台阶需要花费的最少的体力数，且 <code>dp[i]</code> 由 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> 决定，我们由示例二可以推导出递推公式，即</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i]</span><br></pre></td></tr></table></figure><blockquote><p>为什么递推公式中需要加的值为 <code>dp[i]</code> ，这是因为由题意可知，当我们爬上第 i 个楼梯时，就要花费对应的体力值，所以，到达第 i 个体力值需要支付的体力为 <code>cost[i]</code></p><p>同时我们需要注意，<strong>最后到达终点的那一步是不需要花费体力的</strong>。</p></blockquote><h3 id="3、解题代码"><a href="#3、解题代码" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><ul><li>未进行优化前</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cost == <span class="keyword">null</span> || cost.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length];</span><br><span class="line">    <span class="comment">// 对 dp 数组中的元素进行初始化，到达第一个台阶所花费的体力为 cost[0] ，到达第二个台阶所花费的最小体力为 cost[1]</span></span><br><span class="line">    <span class="comment">// dp[1] &lt; dp[0] + dp[1]</span></span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 进行状态转移， dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; cost.length;i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，由于最后一步，即从倒数第二部到重点的过程中是不用花费体力的，所以我们要进行选择</span></span><br><span class="line">    <span class="comment">// 看是从 cost.length - 2 步一下走两步到达终点花费的体力少，还是从 cost.length - 1 步一步到位花费的体力少</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[cost.length - <span class="number">1</span>], dp[cost.length - <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这道题中，由于 dp[i] 只由前面两个状态的值与所给的 <code>cost[i]</code> 决定，所以我们可以不用使用一整个数组，而是使用两个变量进行滚动更新。</p></blockquote><ul><li>使用两个变量进行滚动优化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cost == <span class="keyword">null</span> || cost.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用两个变量进行滚动，其中 one 表示 i - 2 ，second 表示 i - 1</span></span><br><span class="line">    <span class="keyword">int</span> one = cost[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> two = cost[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 在这个循环中，进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; cost.length;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = Math.min(one, two) + cost[i];</span><br><span class="line">        <span class="comment">// 将原本为 i - 1 位置的值赋给 one</span></span><br><span class="line">        one = two;</span><br><span class="line">        <span class="comment">// 将当前位置的值赋值给 two</span></span><br><span class="line">        two = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理，这里最后也不能返回 result ，而是需要在 one 和 two 之间做出选择</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(one, two);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3、不同路径"><a href="#2-3、不同路径" class="headerlink" title="2.3、不同路径"></a>2.3、不同路径</h2><h3 id="1、题目描述-1"><a href="#1、题目描述-1" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p></blockquote><ol><li>示例一</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154525.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><ol start="2"><li>示例二</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-1"><a href="#2、解题思路-1" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ol><li>确定 dp 数组</li></ol><blockquote><p>在这个问题中，我们需要一个二维的 dp 数组，<strong>其中 <code>dp[i][j]</code> 表示到达网格第 i 行第 j 列的方法数</strong></p></blockquote><ol start="2"><li>确定状态转移方程</li></ol><blockquote><p>由于<strong>机器人只能向右走或者向下走</strong>，所以到达网格第 i 行第 j 列的方法数 <code>dp[i][j]</code> 应该为<strong>到达它左边的方格的方法数</strong>与<strong>到达它上边的方格的方法数之和</strong></p><p>所以，我们可以得到它的状态转移方程为</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i - 1][j] 为 dp[i][j] 的上边方格</span></span><br><span class="line"><span class="comment">// dp[i][j - 1] 为 dp[i][j] 的左边方格</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3"><li>确定 <code>base case</code></li></ol><blockquote><p><strong>对于第一行第一列上的网格而言，机器人只有一种方法到达该网格</strong>，即一直向右走 / 往下走，这种网格我们需要对其进行初始化</p></blockquote><h3 id="3、解题代码-1"><a href="#3、解题代码-1" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 进行参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组，其中 dp[i][j] 表示到达网格第 i 行第 j 列处可以使用的方法数</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当 i == 0 或者 j == 0 时，代表在网格的第一行或者第一列，这种情况下，机器人只有一种方法到达</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当 i 与 j 均不为 0 时，此时要进行状态转移</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 dp 数组中终点位置的值，由于这里的 i 和 j 从 0 开始，所以需要 -1 </span></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4、不同路径-II"><a href="#2-4、不同路径-II" class="headerlink" title="2.4、不同路径 II"></a>2.4、不同路径 II</h2><h3 id="1、题目描述-2"><a href="#1、题目描述-2" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有<strong>障碍物</strong>。那么从左上角到右下角将会有多少条不同的路径？</p></blockquote><ol><li>示例一</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154526.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><ol start="2"><li>示例二</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154527.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-2"><a href="#2、解题思路-2" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>这道题与上一道题的解题思路相似，唯一有区别的就是，对于是障碍物的网格，它在 dp 数组中的值为 0 ，转移方程依然与上题相同，但<strong>只有对应方格不为障碍物时，才能将值累加到 dp[i][j] 中</strong></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154528.png" alt="image.png"></p><ul><li>如上图所示，对于第一行中存在障碍及障碍之后的那些网格，我们需要在 dp 数组中初始化为 0 ，对于第一列的网格同理</li><li>对于其他网格，只有当该网格上没有障碍物时，我们才去计算该网格对应的 dp 值</li><li>当我们求一个不是障碍物网格的 dp 值时，不需要考虑它的左边和上边是否为障碍物，因为有障碍物的网格直接被初始化为 0 了</li></ul><h3 id="3、解题代码-2"><a href="#3、解题代码-2" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rowSize = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">int</span> columnSize = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rowSize][columnSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rowSize;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; columnSize;j++) &#123;</span><br><span class="line">            <span class="comment">// 保证起点位置没有障碍物</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有当该网格位置没有障碍物时，才进行运算</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 保证当前网格的上一行（上边网格）不越界</span></span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保证当前网格的前一列（左边网格）不越界</span></span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[rowSize - <span class="number">1</span>][columnSize - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5、整数拆分"><a href="#2-5、整数拆分" class="headerlink" title="2.5、整数拆分"></a>2.5、整数拆分</h2><h3 id="1、题目描述-3"><a href="#1、题目描述-3" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个正整数 <em>n</em> ，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p></blockquote><ol><li>示例一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> = <span class="number">1</span> + <span class="number">1</span>, <span class="number">1</span> × <span class="number">1</span> = <span class="number">1</span>。</span><br></pre></td></tr></table></figure><ol start="2"><li>示例二</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">36</span></span><br><span class="line">解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span>。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-3"><a href="#2、解题思路-3" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ol><li>确定 dp 数组的含义，其中 <code>dp[i]</code> 表示划分整数 i ，可以得到的最大乘积为 <code>dp[i]</code></li></ol><blockquote><p>对于一个数 i 而言，当我们对它进行第一次划分后，对 i 这个数划分的问题就变成了两个子问题的集合，我们假设它划分后的两个数分别为 <code>i - j</code> 和 <code>j</code> ，假设此时我们要划分的数为 5 ，则 我们只需要将 dp[5] 的所有划分求出来，然后再求这些划分的结果的最大值即可</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154529.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">5</span>] = Math.max(dp[<span class="number">1</span>] * dp[<span class="number">4</span>], dp[<span class="number">2</span>] * dp[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><ol start="2"><li>对于一个整数 N ，它的整数划分能得到的最大乘积 dp[N] 的值为：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[N] = dp[i] * dp[N - i]</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里的 <code>dp[i]</code> 和 <code>dp[N - i]</code> 也是划分后得到的最大乘积，也就是说，两个子问题会继续划分</p></blockquote><ol start="3"><li>对于上面 <code>dp[N]</code> 的划分， <code>dp[i]</code> 和 <code>dp[N - i]</code> 既可以进行划分，同时可以不进行划分</li></ol><blockquote><p>以 <code>dp[5]</code> 来说，当 <code>i = 2</code> 时，<code>dp[5] = dp[2] * dp[3]</code> ，2 如果进行划分，那么得到的值即为 1 + 1 = 2 ，得到的值是 1 ；3 如果进行划分，那么得到的最大划分值为 1 + 2 = 3，得到的最大划分值为 2；</p><p>此时 dp[5] 的子问题在不划分时得到的乘积比划分时得到的乘积大。</p></blockquote><ol start="4"><li>状态转移方程</li></ol><blockquote><p>为什么后面的数是 <code>j * dp[i - j]</code> ? 这是因为由于 j 的范围是 [1, i - 1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i] , Math.max(j * (i - j) , dp[i - j] * j));</span><br></pre></td></tr></table></figure><ol start="5"><li>初始化 dp 数组的值</li></ol><blockquote><p>由于题目给的 n 的范围大于等于 2 ，所以我们可以算出 dp[2] = 1;dp[3] = 2;这就是 dp 数组的初始值</p></blockquote><h3 id="3、解题代码-3"><a href="#3、解题代码-3" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 初始化一个长度为 n + 1 的数组，我们最后要返回 dp[n]</span></span><br><span class="line">    <span class="comment">// 这个值表示值 n 的整数划分的最大乘积</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line"></span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里的 i 从 3 开始，且到 n 结束，因为我们要计算 n 的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="comment">// 这里的 j 从 1 开始划分，到达 i - 1 结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i - <span class="number">1</span>;j++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max((i - j) * j, j * dp[i - j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6、不同的二叉搜索树"><a href="#2-6、不同的二叉搜索树" class="headerlink" title="2.6、不同的二叉搜索树"></a>2.6、不同的二叉搜索树</h2><h3 id="1、题目描述-4"><a href="#1、题目描述-4" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个整数 <code>n</code> ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数</p></blockquote><ul><li>示例一</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154530.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-4"><a href="#2、解题思路-4" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>除了动态规划外，这道题还可以使用递归来解决，在递归时，我们的思路是这样的</p></blockquote><ul><li>当 n == 0 时，此时只有一种结构，即空树</li><li>当 n == 1 时，只有一种树结构；当 n == 2 时，此时有两种树结构</li><li>当有 n 个节点时，此时我们分情况进行讨论，我们记一棵有 n 个节点的二叉树有 F(n) 种结构</li></ul><ol><li>如果此时根节点的左子树为空，除 root 节点以外的所有节点都分布在右子树上，那么这种情况下有 F(n - 1) 种二叉树结构</li><li>如果此时根节点的左子树只有一个节点，那么除 root 节点和左子树节点以外的所有节点都会分布在右子树上，这种情况下有 1 * F(n - 2) 种结构，其中 1 为左子树的情况</li><li>同理，如果根节点的左子树有 a 个节点，而右子树有 n - a - 1 个节点，那么这种情况下将会有 <code>F(a) * F(n - a - 1)</code> 种结构</li></ol><blockquote><p>将上面的 1，2，3 种情况加起来，就是我们最终要求的答案，接下来，我们使用动态规划来解决这道题</p></blockquote><ul><li><p>明确 dp 数组的含义，dp[i] 表示有 i 个结点的二叉树结构种数，即有 i 个结点的二叉搜索树有 dp[i] 种结构</p></li><li><p>初始化 dp 数组，当 n == 0 或 n == 1 时， dp[i] = 1</p></li><li><p>递推公式</p></li></ul><blockquote><p>我们假设左子树的结点有 <code>j - 1</code> 个，右子树的结点有 <code>i - j</code> 个，那么我们可以得到如下的递推公式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] += dp[j - <span class="number">1</span>] * dp[i - j]</span><br></pre></td></tr></table></figure><blockquote><p>为什么使用 <code>+=</code> ？ 这是因为 <code>dp[i]</code> 的值应该是左子树结点个数从 [0 , n - 1] 与右子树结点个数从 [n - 1, 0] 的乘积总和</p></blockquote><h3 id="3、解题代码-4"><a href="#3、解题代码-4" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case ，当 n == 0 || n == 1 时，结果为 1 ，当 n == 2 时，结果为 2</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组，长度为 n + 1 ，我们要返回 dp[n] 的值</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组的值，由于我们的 i 从 1 开始，所以只需要初始化 dp[0] 即可</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 外层循环，表示结点个数从 1 - n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="comment">// 内层循环，表示左子树结点个数从 [0, n - 1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移，当前 dp[i] 的值为左子树所有可能出现的情况与右子树所有可能出现情况的乘积累加</span></span><br><span class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7、分割等和子集"><a href="#2-7、分割等和子集" class="headerlink" title="2.7、分割等和子集"></a>2.7、分割等和子集</h2><h3 id="1、题目描述-5"><a href="#1、题目描述-5" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个 <strong>只包含正整数</strong> 的<strong>非空</strong>数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>] 。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-5"><a href="#2、解题思路-5" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li><p>如果数组元素的总和 <code>sum</code> 不是偶数，那么证明所给数组无法进行等和分割，直接返回 false</p></li><li><p>获取数组中的最大元素 <code>max</code> ，如果 <code>max &gt; sum / 2</code> ，那么直接返回 false ，因为此时无法将数组分割为两个元素和相等的子集。</p></li><li><p>这道题可以转换为一种 <strong>01 背包问题</strong>，不过，与普通 01 背包问题不同的是，前者要求选取的物品的重量之和不能超过背包总容量，而这道题要求选取的数字刚好等于整个数组的元素和的一半，即 <code>sum / 2</code></p></li><li><p>dp 数组的含义</p></li></ul><blockquote><p>与 01 背包问题相似，我们需要创建一个二维的 dp 数组，其中 <code>dp[i][j]</code> 表示从数组 <code>nums</code> 的下标 <code>[0,i]</code> 范围内选取若干个正整数（可以是 0 个），是否存在着一种选取方案使得被选取的正整数的和等于 <code>j</code> 。</p><p>初始时， dp 中的全部元素都为 false</p></blockquote><ul><li>dp 数组初始化</li></ul><ol><li>当要寻找的正整数的和为 0 时，那么无论此时 <code>nums</code> 中所给的元素下标范围如何变化，都可以找到选取方案，即 <code>dp[i][0]</code> 应该初始化为 true</li><li>当 i 为 0 ，即 <code>nums</code> 数组仅有第一个元素 nums[0] 可供选择时，此时只有当 <code>j == nums[0]</code> 时，才有选择方案，即 <code>dp[0][nums[0]]</code> 应该初始化为 true</li></ol><ul><li>状态转移方程，当 <code>i &gt; 0</code> 且 <code>j &gt; 0</code> 时，我们需要考虑以下两种情况<ul><li>如果 <code>j &gt;= nums[i]</code> ，则对于当前的数字 <code>nums[i]</code> ，我们可以做出选择，既可以选取也可以不选取，只要两种选择有一种为 true ，那么 <code>dp[i][j]</code> 就为 <code>true</code><ul><li>如果不选取 <code>nums[i]</code> ，则 <code>dp[i][j] = dp[i - 1][j]</code></li><li>如果选取 <code>nums[i]</code> ，则 <code>dp[i][j] = dp[i - 1][j - nums[i]]</code></li></ul></li><li>如果 <code>j &lt; nums[i]</code> ，则在选取的数字的和为 j 的情况下无法选取当前的数字 <code>nums[i]</code> ，因此有 <code>dp[i][j] = dp[i - 1][j]</code></li></ul></li></ul><blockquote><p>所以我们可以得到状态转移方程如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">       <span class="comment">// 如果要分割的数大于当前数组正在遍历的数，那么我们可以进行选择</span></span><br><span class="line"><span class="comment">// 只要有一个选择的结果为 true ，那么当前的 dp[i][j] 就为 true</span></span><br><span class="line">       dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i]];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 否则无法进行选择，直接用上一次遍历的情况代替</span></span><br><span class="line">       dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3、解题代码-5"><a href="#3、解题代码-5" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="comment">// 获取数组中的最大值</span></span><br><span class="line">        max = Math.max(max, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 sum 不是偶数，那么直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将 sum 除以 2 ，如果可以进行等和分割，那么数组中一定有几个元素的和等于 sum 除以 2 后的数</span></span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 如果数组中的最大值大于数组总和的一半，那么直接返回 false </span></span><br><span class="line">    <span class="keyword">if</span> (max &gt; sum) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 创建一个二维的 boolean 类型数组 dp ，这个 dp 数组有 nums.length 行 target + 1 列，其中 target = sum / 2;</span></span><br><span class="line">    <span class="comment">// dp[i][j] 表示在 nums 数组下标 [0,i] 范围内，是否可以找到一种选取方式，使得选取出来的数组值之和等于 j</span></span><br><span class="line">    <span class="comment">// 我们要求的就是 dp[nums.length - 1][target]</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组中的值，其中，当 j == 0 时，此时无论 nums 下标范围为多少，都可以找到一种分配方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 i == 0 时，dp[0][nums[0]] = true</span></span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 为什么外层从 1 开始？因为当 i 等于 0 时，只有 dp[0][nums[0]] 才为 true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line">        <span class="comment">// 内层循环为何从 1 开始，从 sum 结束</span></span><br><span class="line">        <span class="comment">// 因为当 j == 0 时，无论如何都有选取方案，这种情况我们已经在初始化过程中进行排除，所以从 1 开始</span></span><br><span class="line">        <span class="comment">// 同时由于我们循环判断待选取的值为结果的情况，所以需要循环到 sum </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= sum;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= num) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-8、最后一块石头的重量-II"><a href="#2-8、最后一块石头的重量-II" class="headerlink" title="2.8、最后一块石头的重量 II"></a>2.8、最后一块石头的重量 II</h2><h3 id="1、题目描述-6"><a href="#1、题目描述-6" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。<br>每一回合，从中选出 <strong>任意两块石头</strong> ，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p></blockquote><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><blockquote><p>最后，<strong>最多只会剩下一块</strong>石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p></blockquote><ol><li>示例一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">组合 <span class="number">2</span> 和 <span class="number">4</span>，得到 <span class="number">2</span>，所以数组转化为 [<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span>]，</span><br><span class="line">组合 <span class="number">7</span> 和 <span class="number">8</span>，得到 <span class="number">1</span>，所以数组转化为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">组合 <span class="number">2</span> 和 <span class="number">1</span>，得到 <span class="number">1</span>，所以数组转化为 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">组合 <span class="number">1</span> 和 <span class="number">1</span>，得到 <span class="number">0</span>，所以数组转化为 [<span class="number">1</span>]，这就是最优值。</span><br></pre></td></tr></table></figure><ol start="2"><li>示例二</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">31</span>,<span class="number">26</span>,<span class="number">33</span>,<span class="number">21</span>,<span class="number">40</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-6"><a href="#2、解题思路-6" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li><p>这道题和<strong>分割等和子集</strong>的思路相似，也可以转换为 01 背包问题，我们需要从数组中选择一些石头为负数，从而使得整个数组的和最小</p></li><li><p>在数组中，我们记整个数组元素的和为 <code>sum</code> ，负数元素的和为 <code>neg</code> ，则正数元素和为 <code>sum - neg</code> ，当 <code>neg</code> 与 <code>sum - neg</code> 最接近时，碰撞后剩下的石头最小</p></li><li><p>也就是说， <code>neg</code> 越接近 <code>sum / 2</code> ，碰撞后的石头越小</p></li><li><p>所以问题转换为能否从 <code>nums[0:i]</code> 从取出某些石头，让这些石头的质量接近 j</p></li><li><p>确定 dp 数组的含义</p></li></ul><blockquote><p>和上题相似，<code>dp[i][j]</code> 的值表示在石头数组下标为 [0, i] 的哪些石头中，是否存在一种选取方案，使得这些石头的重量为 j</p></blockquote><ul><li>状态转移方程和上题的一样</li><li>dp 数组的初始化</li></ul><blockquote><p>只有 dp[0][0] 可以初始化为 true</p></blockquote><h3 id="3、解题代码-6"><a href="#3、解题代码-6" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stones == <span class="keyword">null</span> || stones.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, size = stones.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : stones) sum += num;</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[size + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= size;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; size + <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> curNum = stones[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= target;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= curNum) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - curNum];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = target;;--j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[size][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum - <span class="number">2</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-9、最长递增子序列"><a href="#2-9、最长递增子序列" class="headerlink" title="2.9、最长递增子序列"></a>2.9、最长递增子序列</h2><h3 id="1、题目描述-7"><a href="#1、题目描述-7" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，因此长度为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-7"><a href="#2、解题思路-7" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li><p>使用动态规划来解决这道题，首先我们需要确定 dp 数组的含义，在这道题中 ，<code>dp[i]</code> 表示以数组 <code>nums[i]</code> 为结尾的最长递增子序列的长度。</p></li><li><p>我们可以这样思考，对于数组中的元素 <code>nums[i]</code> ，只要我们在 <code>[0,i - 1]</code> 的位置中找到一个小于 <code>nums[i]</code> 的元素 <code>nums[j]</code> ，然后将 <code>num[i]</code> 拼接在 <code>nums[j]</code> 后，就可以得到一个以 <code>nums[i]</code> 为结尾的最长递增子序列，所以我们可以得到以下的递推公式</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);<span class="comment">// 当 nums[j] &lt; nums[i] 且 j &lt; i 时</span></span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组，对于数组中的每一个元素来说，其都可以单独地作为一个子序列存在，故 <code>dp[i] = 1</code></li></ul><h3 id="3、解题代码-7"><a href="#3、解题代码-7" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 初始化 dp ，为每个位置填充上数值 1 </span></span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 遍历数组，为每个数组填充合适的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="comment">// 内层循环是为外层循环服务的，目的是遍历当前数组 [0, i - 1] 的位置，然后计算出 dp[i] 的真正值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                <span class="comment">// 不断更新 dp[i] 的值，如果 nums[j] &lt; nums[i] ，那么证明找到一个以 nums[i] 为结尾的递增子序列</span></span><br><span class="line">                <span class="comment">// 我们需要查看这个新的子序列的长度与之前找到了最长递增子序列长度的差别，然后决定是否更新最长递增子序列的值</span></span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-10、打家劫舍"><a href="#2-10、打家劫舍" class="headerlink" title="2.10、打家劫舍"></a>2.10、打家劫舍</h2><h3 id="1、题目描述-8"><a href="#1、题目描述-8" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-8"><a href="#2、解题思路-8" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>确定 dp 数组的含义</li></ul><blockquote><p><strong><code>dp[i]</code> 表示在考虑下标 i （包括 i ）以内的房屋，最多可以偷窃的金额为 <code>dp[i]</code></strong></p></blockquote><ul><li>确定状态转移方程</li></ul><ol><li>如果选择偷取第 i 间屋子，那么我们就不能偷取第 i - 1 间屋子</li><li>如果选择不偷取第 i 间屋子，那么此时最多能偷窃的金额即为考虑第 i - 1 间屋子时能获取的金额，即此时 <code>dp[i] = dp[i - 1]</code></li></ol><blockquote><p>我们应该在这两个选择中选取一个比较大的数，将其作为 dp[i] 的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i - <span class="number">2</span>] + value[i], dp[i - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><ol><li><strong>当我们只考虑第 0 间屋子时，我们能得到的最大收益是第 0 间屋子中存放的钱</strong></li><li><strong>当我们只考虑第 0 间屋子与第 1 间屋子时，我们能得到的最大收益为 <code>Math.max(value[0], value[1])</code></strong></li></ol><h3 id="3、解题代码-8"><a href="#3、解题代码-8" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果长度为 1 ，那么直接返回 nums[0] 即可</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组，长度为 nums.length </span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="comment">// 进行状态转移，此时我们有两种选择</span></span><br><span class="line">        <span class="comment">//1 选择不偷第 i 间房子，那么 dp[i] 的值即为 dp[i - 1] 的值</span></span><br><span class="line">        <span class="comment">//2 选择偷第 i 间房子，那么我们就不能偷第 i - 1 间房子，此时我们在考虑第 i 间房子时最获取的最大收益即为 dp[i - 2] + 第 i 间屋子中的钱</span></span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 dp[nums.length - 1] ，这个值代表在考虑 nums.length - 1 间房子时，能获取的最大收益</span></span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-11、打家劫舍-II"><a href="#2-11、打家劫舍-II" class="headerlink" title="2.11、打家劫舍 II"></a>2.11、打家劫舍 II</h2><h3 id="1、题目描述-9"><a href="#1、题目描述-9" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-9"><a href="#2、解题思路-9" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>这道题也是基于 <strong>打家劫舍 I</strong> 的，与<strong>打家劫舍 I</strong> 不同的是，第一间房屋和最后一间房屋不能同时偷窃，那么需要如何保证第一间房屋和最后一间房屋不同时偷窃呢？</p></blockquote><ol><li>如果我们偷窃了第 0 间房屋，那么我们就不能偷窃最后一间房屋，所以选择偷窃第 0 间房屋时，我们能偷窃的房屋下标范围为 <code>[0, nums.length - 2]</code> （偷窃第一间到倒数第二间房子）</li><li>如果我们偷窃了最后一间房屋，那么我们就不能偷窃第一间房屋，所以选择偷窃最后一间房屋时，我们能偷窃的房屋下标范围为 <code>[1, nums.length - 1]</code></li></ol><blockquote><p>所以我们可以进行两次动态规划，动态规划的逻辑与<strong>打家劫舍 I</strong> 相同，然后取两次动态规划得到结果的最大值即可。</p></blockquote><h3 id="3、解题代码-9"><a href="#3、解题代码-9" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 对 nums 中 [0, nums.length - 2] 范围的子集进行动态规划，得到结果 1 </span></span><br><span class="line">    <span class="keyword">int</span> firstResult = getMoneyByRange(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 对 nums 中 [1, nums.length - 1] 范围的子集进行动态规划，得到结果 2 </span></span><br><span class="line">    <span class="keyword">int</span> secondResult = getMoneyByRange(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 返回两个结果的最大值</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(firstResult, secondResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对 nums 数组中下标为 [begin, end] 范围内打家劫舍，得到利益最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMoneyByRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((end - begin + <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (end == begin) <span class="keyword">return</span> nums[begin];</span><br><span class="line">    <span class="keyword">if</span> (end - begin == <span class="number">1</span>) <span class="keyword">return</span> Math.max(nums[begin], nums[end]);</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组，长度为 nums.length </span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    dp[begin] = nums[begin];</span><br><span class="line">    dp[begin + <span class="number">1</span>] = Math.max(nums[begin], nums[begin + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin + <span class="number">2</span>;i &lt;= end;i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-12、买卖股票的最佳时机"><a href="#2-12、买卖股票的最佳时机" class="headerlink" title="2.12、买卖股票的最佳时机"></a>2.12、买卖股票的最佳时机</h2><h3 id="1、题目描述-10"><a href="#1、题目描述-10" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span>-<span class="number">1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span>-<span class="number">1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-10"><a href="#2、解题思路-10" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>使用<strong>动态规划</strong>求解这道题</p></blockquote><ul><li>明确 dp 数组的含义</li></ul><blockquote><p>对于第 i 天的用户来说，他可以持有股票，也可以不持有股票，<strong>我们 使用 0 表示这个用户持有股票，使用 1 表示这个用户未持有股票</strong>，所以这里我们需要使用一个二维的 dp 数组来进行求解，其中**<code>dp[i][j]</code> 表示在第 i 天，用户持股状态为 j 时，所获取的最大收益**</p></blockquote><ul><li>明确状态转移方程</li></ul><ol><li>如果第 i 天持有股票，那么可以由两个状态推导出来</li></ol><blockquote><p>第 i - 1 天就持有股票，那么就保持现状，所得利润就是昨天持有股票的所得利润，即此时 <code>dp[i][0] = dp[i - 1][0]</code></p><p>第 i 天买入股票，所得利润应该为负数，此时 <code>dp[i][0] = -prices[i]</code></p><p>需要在上面两个值中选择最大值，即</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br></pre></td></tr></table></figure><ol start="2"><li>如果第 i 天没有持有股票，也可以从两个状态推导出来</li></ol><blockquote><p>第 i - 1 天就已经不持有股票，那么保持现状，此时 <code>dp[i][1] = dp[i - 1][1]</code></p><p>第 i - 1 天持有股票，那么所得利润就是前一天持有股票时拥有的利润 <code>dp[i - 1][0]</code> 与今天卖出股票所得利润的总和 <code>prices[i]</code> ，即 <code>dp[i][1] = dp[i - 1][0] + prices[i]</code></p><p>同样需要在以上两个值中选择最大值，即</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>根据方程可知，后面 dp 数组的值都有 <code>dp[0][0]</code> 与 <code>dp[0][1]</code> 推导而来，所以我们需要初始化以上两个值，即</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>最终我们要返回的结果为 <code>dp[nums.length - 1][1]</code> ，即最后一天，用户手中没有持有股票时，能获取的最大利润</li></ul><h3 id="3、解题代码-10"><a href="#3、解题代码-10" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><ul><li>未进行空间优化前</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个二维的 dp 数组，其中列数为 2 ，行数为 prices.length</span></span><br><span class="line">    <span class="comment">// 其中 dp[i][0] 表示在第 i 天，用户手中持有股票时，所能获取的最大收益，dp[i][1] 表示在第 i 天，用户手中没有持有股票时，所能获取的最大收益 </span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，在第 0 天持有股票，那么收益为 -prices[0]，在第 0 天没有持有股票时，那么收益为 0 </span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最终返回的结果为 dp[]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">        <span class="comment">// 进行状态转移</span></span><br><span class="line">        <span class="comment">//1 第 i 天手中持有股票的状态可以由两个状态得来</span></span><br><span class="line">        <span class="comment">//1.1 第一个状态，即第 i - 1 天就已经持有股票，这种状态下则保持原样</span></span><br><span class="line">        <span class="comment">//1.2 第二个状态，即第 i - 1 天没有持有股票，股票是在第 i 天买入的，此时应该减去价格</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">        <span class="comment">//2 同理，第 i 天手中没有持有股票的状态也由两个状态得来</span></span><br><span class="line">        <span class="comment">//2.1 第一个状态，即第 i - 1 天就已经卖掉股票了，这种状态下保持原样</span></span><br><span class="line">        <span class="comment">//2.2 第二个状态，即在第 i 天才卖掉股票，此时结果应该为在第 i - 1 天持有股票的利润 + 第 i 天卖出去的利润</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进行空间优化</li></ul><blockquote><p>由于第 i 天的状态只有第 i - 1 天的状态推导而来，所以我们可以缩减 dp 数组的行数，将 dp 数组改造为一个 2 * 2 的二维数组</p></blockquote><ol><li>使用 dp[1][0] 表示第 i 天持有股票时获取的最大利润</li><li>使用 dp[0][0] 表示第 i - 1 天持有股票时能获取的最大利润</li><li>使用 dp[1][1] 表示第 i 天没有持有股票时获取的最大利润</li><li>使用 dp[0][1] 表示第 i - 1 天没有持有股票时能获取的最大利润</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        <span class="comment">// 更新滚动数组的值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回在最后一天没有持有股票的最大利润</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-13、最长连续递增序列"><a href="#2-13、最长连续递增序列" class="headerlink" title="2.13、最长连续递增序列"></a>2.13、最长连续递增序列</h2><h3 id="1、题目描述-11"><a href="#1、题目描述-11" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong> ，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长连续递增序列是 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], 长度为<span class="number">3</span>。</span><br><span class="line">尽管 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>] 也是升序的子序列, 但它不是连续的，因为 <span class="number">5</span> 和 <span class="number">7</span> 在原数组里被 <span class="number">4</span> 隔开。 </span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最长连续递增序列是 [<span class="number">2</span>], 长度为<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-11"><a href="#2、解题思路-11" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>与最长递增子序列不同的是，最长连续递增序列要求<strong>连续</strong>，我们仍然可以延续之前的思路，对于下标为 i 的数组元素来说，如果它的前一个元素是一个最长连续递增序列的末尾且 <code>nums[i - 1] &lt; nums[i]</code>，那么我们就可以将 <code>nums[i]</code> 拼接到 <code>nums[i - 1]</code> 的末尾，形成一个更长的连续序列</li><li>确定 dp 数组中的含义</li></ul><blockquote><p><strong><code>dp[i]</code> 表示以下标为 i 的数组元素为结尾的最长递增序列的长度</strong></p></blockquote><ul><li>确定状态转移方程</li></ul><blockquote><p>对于 <code>nums[i]</code> 来说，如果 <code>nums[i - 1] &lt; nums[i]</code> ，那么证明此时 nums[i] 可以拼接到以 nums[i - 1] 为结尾的最长连续递增序列中，此时递推公式应该为</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">	dp[i] = Math.max(dp[i], dp[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>对于数组中的任何一个元素，我们都可以将其单独看为一个最长连续递增序列，所以我们需要将 dp 数组全部初始化为 1</p></blockquote><h3 id="3、解题代码-11"><a href="#3、解题代码-11" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], dp[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(dp[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-14、最长重复子数组"><a href="#2-14、最长重复子数组" class="headerlink" title="2.14、最长重复子数组"></a>2.14、最长重复子数组</h2><h3 id="1、题目描述-12"><a href="#1、题目描述-12" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">A: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">B: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：长度最长的公共子数组是 [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-12"><a href="#2、解题思路-12" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>确定 dp 数组的含义</li></ul><blockquote><p><strong><code>dp[i][j]</code> 表示数组 <code>nums1</code> 下标范围为 <code>[0, i - 1]</code> 的子数组与 <code>nums2</code> 下标为 <code>[0, j - 1]</code> 的子数组的最长公共数组的长度</strong></p></blockquote><ul><li>确定状态转移方程</li></ul><blockquote><p>对于上面提到的两个子数组，如果此时存在 <code>nums1[i - 1] == nums2[j - 1]</code> ，那么此时这两个子数组的最长公共长度就为 nums1[0: i - 2] 、 nums2[0: j - 2] 两个子数组的最长公共数组长度 + 1，即</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">	dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>根据上面 dp 数组的定义，我们知道在 dp 数组中，<code>dp[i][0]</code> 和 <code>dp[0][j]</code> 是没有意义的，所以我们直接初始化为 0</p></blockquote><h3 id="3、解题代码-12"><a href="#3、解题代码-12" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组，其中 dp[i]][j] 表示 nums1 中以 i - 1 下标为结尾的子数组 a ，nums2 中以 j - 1 下标为结尾的子数组 b ，ab 数组中最长公共子数组的长度</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 使用一个全局变量保存最长公共子数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里的循环必须从 1 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums1.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= nums2.length;j++) &#123;</span><br><span class="line">            <span class="comment">// 将两个子数组的结尾字符进行比较，如果结尾字符相等，那么进行状态转移</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新 max</span></span><br><span class="line">            max = Math.max(max, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-15、最长公共子序列"><a href="#2-15、最长公共子序列" class="headerlink" title="2.15、最长公共子序列"></a>2.15、最长公共子序列</h2><h3 id="1、题目描述-13"><a href="#1、题目描述-13" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p></blockquote><ol><li><strong>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列</strong>。</li><li>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</li></ol><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span>, text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span>, text2 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-13"><a href="#2、解题思路-13" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>确定 dp 数组的含义</li></ul><blockquote><p>和上一题一样，我们使用一个二维数组来解决这道题，其中 <code>dp[i][j]</code> 表示字符串 <code>text1</code> 以 <code>i - 1</code> 为结尾的子串与字符串 <code>text2</code> 以 <code>j - 1</code> 为结尾的子串之间最长公共子序列的长度。</p></blockquote><ul><li>确定状态转移方程</li></ul><blockquote><p>在 LCS 问题中，我们设 <code>text1</code> 字符串的子串为 X = &lt;x1,x2…xm&gt;，<code>text2</code> 字符串的子串为 Y = &lt;y1,y2…yn&gt; ，Z = &lt;z1,z2…zk&gt; 为它们的一个公共子序列，经过分析，有</p></blockquote><ol><li>如果 xm == yn ，则 <code>zk = xm = yn</code> 且 Zk - 1 是 Xm - 1 与 Yn - 1 的一个 LCS （最长公共子序列）</li><li>如果 xm != yn 且 zk != xm ，则 Zk 是 Xm - 1 与 Yn 的一个 LCS</li><li>如果 xm != yn 且 zk != yn ，则 Zk 是 Yn - 1 与 Xm 的一个 LCS</li></ol><blockquote><p>所以我们可以得到以下的状态转移方程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xi == yj) &#123;</span><br><span class="line">	dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>当 i == 0 或者 j == 0 时，<code>dp[i][j]</code> 没有意义，此时让 <code>dp[i][j]</code> 为 0 即可</p></blockquote><h3 id="3、解题代码-13"><a href="#3、解题代码-13" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text1 == <span class="keyword">null</span> || text2 == <span class="keyword">null</span> || text1.length() == <span class="number">0</span> || text2.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个二维的 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 进行循环，注意，循环应该从下标 1 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= text1.length();i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= text2.length();j++) &#123;</span><br><span class="line">            <span class="comment">// 同时这里比较的应该是 i - 1 与 j - 1 的字符，因为循环从 1 开始</span></span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123; <span class="comment">// 如果 i - 1 下标与 j - 1 下标的字符相同</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 i - 1 下标与 j - 1 下标的字符不相同</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 dp[text1.length()][text2.length()] 即可，这个值代表 text1 字符串与 text2 字符串之阿的最长公共子序列的长度</span></span><br><span class="line">    <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-16、-不相交的线"><a href="#2-16、-不相交的线" class="headerlink" title="2.16、 不相交的线"></a>2.16、 不相交的线</h2><h3 id="1、题目描述-14"><a href="#1、题目描述-14" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p></blockquote><ol><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ol><blockquote><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p></blockquote><ul><li><strong>示例 1：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 nums1[<span class="number">1</span>]=<span class="number">4</span> 到 nums2[<span class="number">2</span>]=<span class="number">4</span> 的直线将与从 nums1[<span class="number">2</span>]=<span class="number">2</span> 到 nums2[<span class="number">1</span>]=<span class="number">2</span> 的直线相交。</span><br></pre></td></tr></table></figure><ul><li><strong>示例 2：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>], nums2 = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-14"><a href="#2、解题思路-14" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>如果我们将数组看为一个字符串，那么<strong>这道题其实就是求两个数组的 LCS 问题</strong></li></ul><blockquote><p>直线不能相交，也就是说在数组 A 中找到一个与数组 B 相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，那么链接相同数字的直线就不会相交。</p></blockquote><h3 id="3、解题代码-14"><a href="#3、解题代码-14" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len1 = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = nums2.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len1;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len2;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-17、最大子序和"><a href="#2-17、最大子序和" class="headerlink" title="2.17、最大子序和"></a>2.17、最大子序和</h2><h3 id="1、题目描述-15"><a href="#1、题目描述-15" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-15"><a href="#2、解题思路-15" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>确定 dp 数组含义</li></ul><blockquote><p>其中 <code>dp[i]</code> 表示<strong>包括下标 i 之间的最大连续子序列和</strong></p></blockquote><ul><li>确定递推公式</li></ul><blockquote><p>对于 <code>dp[i]</code> ，有两个方向可以将其推导出来</p></blockquote><ol><li><code>dp[i - 1] + nums[i]</code></li></ol><blockquote><p>这表示将当前元素加入到以 i - 1 为下标的连续子序列和中，此时 <code>dp[i - 1]</code> 大于等于 0</p></blockquote><ol start="2"><li><code>nums[i]</code></li></ol><blockquote><p>这表示重新计算连续子序列和，以 i - 1 为结尾下标的连续子序列和的值小于 0 ，此时 <code>dp[i - 1] + nums[i]</code> 的值反倒小于 <code>nums[i]</code></p></blockquote><ul><li>初始化 dp 数组</li></ul><blockquote><p>由于 <code>dp[i]</code> 表示<strong>包括下标 i 之间的最大连续子序列和</strong>，所以对于 dp[0] ，我们可以将其初始化为 <code>nums[0]</code></p></blockquote><h3 id="3、解题代码-15"><a href="#3、解题代码-15" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用一个变量来表示我们要返回的最大结果，初始化为 nums[0]</span></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 创建一个长度为 nums.length 的 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，dp[i] 表示以 i 下标为结尾的最大子序和的值，所以我们直接初始化 dp[0] 为 nums[0]</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="comment">// 进行选择</span></span><br><span class="line">        <span class="comment">//1 选择一，将 nums[i] 加入到以 i - 1 为结尾的子序列和中</span></span><br><span class="line">        <span class="comment">//2 选择二，直接将 nums[i] 看为一次新的开始</span></span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        <span class="comment">// 更新最大结果</span></span><br><span class="line">        max = Math.max(dp[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-18、判断子序列"><a href="#2-18、判断子序列" class="headerlink" title="2.18、判断子序列"></a>2.18、判断子序列</h2><h3 id="1、题目描述-16"><a href="#1、题目描述-16" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;chm&quot;</span>, t = <span class="string">&quot;hialchemist&quot;</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-16"><a href="#2、解题思路-16" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>方法一：使用双指针解决这道题</p></blockquote><ul><li>初始化两个指针，其中 sub 指针指向 s 的第一个字符，main 指针指向 t 的第一个字符</li><li>如果 sub 与 main 指向的字符相等，那么 sub 与 main 同时后移</li><li>如果不相等，那么此时 sub 保持不动，而 main 后移</li></ul><blockquote><p>方法二：使用动态规划求解这道题，我们可以求解出两个字符串的最长公共子序列长度 len ，然后判断 len 是否等于 s 的长度，所以问题又变为了求两个字符串最长公共子序列的问题。</p></blockquote><ul><li><p>dp 数组的含义，其中， <code>dp[i][j]</code> 表示字符串 s 以 i - 1 下标为结尾的子串与字符串 t 以 j - 1 下标为结尾的子串，它们的最长公共子序列长度</p></li><li><p>状态转移方程</p></li></ul><ol><li>如果 <code>s.charAt(i - 1) == t.charAt(j - 1)</code> ，那么 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li><li>如果 <code>s.charAt(i - 1) != t.charAt(j - 1)</code> ，那么 <code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])</code></li></ol><ul><li>dp 数组的初始化，由于 dp[i][0] 、 dp[0][j] 无意义，所以初始化为 0</li></ul><blockquote><p>方法三：使用动态规划解决这道题，我们以示例中所给的两个字符串进行打表</p></blockquote><table><thead><tr><th align="right"><br></th><th><br></th><th>H</th><th>I</th><th>A</th><th>L</th><th align="center">C</th><th>H</th><th>E</th><th>M</th><th>L</th><th>S</th><th align="center">T</th></tr></thead><tbody><tr><td align="right"></td><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td><td align="center">true</td><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td><td align="center">true</td></tr><tr><td align="right">C</td><td>false</td><td>false<br></td><td>false</td><td>false</td><td>false</td><td align="center"><strong>true</strong></td><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td><td align="center">true</td></tr><tr><td align="right">H</td><td>false</td><td>false<br></td><td>false<br></td><td>false<br></td><td>false<br></td><td align="center">false<br></td><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td><td align="center">true</td></tr><tr><td align="right">M</td><td>false</td><td>false<br></td><td>false<br></td><td>false<br></td><td>false<br></td><td align="center">false<br></td><td>false<br></td><td>false<br></td><td>true</td><td>true</td><td>true</td><td align="center">true</td></tr></tbody></table><ol><li>在上面的表格中，横向的行上分布着字符串 t ，而纵向的列上分布着字符串 s ，对于第一行，我们全将内容置为 true ，这表示当 s 为空字符串时，无论 t 为什么， s 都是 t 的子序列；对于第一列，我们将除（1，1）以外内容全部置为 false ，这表示当 t 为空字符串时，除了 s 为空串的情况外，s 都不是 t 的子串。</li><li>当 <code>s == &quot;c&quot;</code> 且 <code>t == &quot;hialc&quot;</code> 时，此时我们查看这个格子的左上角，发现这个格子的左上角也为 true ，这表示当 s 与 t 的最后一个字符相等时，此时我们只需要判断 s 去掉最后一个字符的子串 <code>s[0, s.length() - 2]</code> 是不是 t 去掉最后一个字符的子串 <code>t[0, t.length() - 2]</code> 的子序列即可，如果是，则结果为 true ，否则为 false</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 dp[i][j] 表示 s[0, i - 1] 是否为 t[0, j - 1] 的子序列</span></span><br><span class="line"><span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">	dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果有一个元素 dp[i][j] = true ，那么对于该行中该元素后的所有元素，应该全部为 true ，比如说 s = “c” 是 t = “abc” 的子序列，那么 s 就应该是 t = “abcd” 、 “abcde” 的子序列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != t.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">	dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、解题代码-16"><a href="#3、解题代码-16" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><blockquote><p>双指针法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length() == <span class="number">0</span> &amp;&amp; s.length() != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sub = <span class="number">0</span>, main = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sub &lt; s.length() &amp;&amp; main &lt; t.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(sub) == t.charAt(main)) &#123;</span><br><span class="line">            sub++;</span><br><span class="line">        &#125;</span><br><span class="line">        main++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sub &gt;= s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>动态规划一，解法二</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length() == <span class="number">0</span> &amp;&amp; s.length() != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> length1 = s.length(), length2 = t.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= length1;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= length2;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2] == s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>动态规划二，解法三</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length() == <span class="number">0</span> &amp;&amp; s.length() != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> length1 = s.length(), length2 = t.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case ，由于这里行数是 s 长度，所以我们应该将第一列置为 true </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= length2;j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= length1;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= length2;j++) &#123;</span><br><span class="line">            <span class="comment">// 如果 i - 1 与 j - 1 指针指向的字符相等，那么判断 s[0, i - 2] 是否为 t[0, j - 2] 的子串（取左上角的元素）</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则直接取它左边的元素即可</span></span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-19、不同的子序列"><a href="#2-19、不同的子序列" class="headerlink" title="2.19、不同的子序列"></a>2.19、不同的子序列</h2><h3 id="1、题目描述-17"><a href="#1、题目描述-17" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p><p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p></blockquote><ul><li>示例一</li></ul><blockquote><p>输入：s = “rabbbit”, t = “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br><code>rabb</code> b <code>it</code><br><code>ra</code> b <code>bbit</code><br><code>rab</code> b <code>bit</code></p></blockquote><ul><li>示例二</li></ul><blockquote><p>输入：s = “babgbag”, t = “bag”<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 “bag” 的方案。<br><code>ba</code> b <code>g</code> bag<br><code>ba</code> bgba <code>g</code><br><code>b</code> abgb <code>ag</code><br>ba <code>b</code> gb <code>ag</code><br>babg <code>bag</code></p></blockquote><h3 id="2、解题思路-17"><a href="#2、解题思路-17" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>使用动态规划求解这道题</p></blockquote><ul><li>定义 dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i][j]</code> 表示字符串 s 中下标范围为 <code>[0, i - 1]</code> 的子串，它的子序列中出现字符串 t 中下标范围为 <code>[0, j - 1]</code> 的子串的个数</p></blockquote><ul><li><p>确定状态转移方程</p><ul><li>当 <code>s[i - 1] != t[j - 1]</code> 时，此时我们只能让 s 字符串中下标为 [0, i - 2] 位置的子串与 t 字符串中下标为 [0, j - 1] 的子串进行匹配，因为此时 s[i - 1] 不能用来匹配，所以有 <code>dp[i][j] = dp[i - 1][j]</code></li><li>当 <code>s[i - 1] == t[j - 1]</code> 时，此时我们有两种选择</li></ul><ol><li>使用 <code>s[i - 1]</code> 来与 <code>t[j - 1]</code> 进行匹配，这种情况下， <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>不使用 <code>s[i - 1]</code> 来与 <code>t[j - 1]</code> 进行匹配，这种情况下，<code>dp[i][j] = dp[i - 1][j]</code></li></ol></li></ul><blockquote><p>这里借用 LeetCode <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distinct-subsequences/solution/115-bu-tong-de-zi-xu-lie-by-chen-wei-f-mpbc/">题解</a>中一位老哥的图进行理解</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154531.png" alt="image.png"></p><ul><li>初始化 dp 数组</li></ul><ol><li>当 j == 0 时，此时 t 字符串所给的子串 y 为空串，那么对于 s 中的任意一个子串 x ，x 都可以包含 y ，故 <code>dp[i][0] = 1</code></li><li>当 i == 0 时，此时 s 字符串所给的子串 x 为空串，那么对于 t 中除空串外的任意一个字符串 y ，x 都不可能包含 y ，所以 <code>dp[0][j] = 0</code> （这里的 j &gt;= 1）</li></ol><h3 id="3、解题代码-17"><a href="#3、解题代码-17" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length() &gt; s.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个二维的 dp 数组，其中 dp[i][j] 表示 s 字符串中下标范围为 [0, i - 1] 的子串 a 中，含有 t 字符串中下标范围为 [0,j - 1] 的子串 b 的个数</span></span><br><span class="line">    <span class="keyword">int</span> length1 = s.length(), length2 = t.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，当 j == 0时，dp[0][j] = 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length1;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= length1;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= length2;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果 s[i - 1] == t[j - 1]，那么此时我们有两种选择</span></span><br><span class="line">                <span class="comment">// 选择 1 ，让 s[i - 1] 与 t[j - 1] 进行匹配，此时得到的结果为 dp[i - 1][j - 1] </span></span><br><span class="line">                <span class="comment">// 选择 2 ，让 s[i - 1] 不与 t[j - 1] 进行匹配，此时得到的结果为 dp[i - 1][j]</span></span><br><span class="line">                <span class="comment">// 需要将这两个结果综合起来</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 s[i - 1] != t[j - 1]，那么此时 s[i - 2] 与 t[j - 1] 进行匹配，因为 s[i - 1] 不能匹配</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-20、两个字符串的删除操作"><a href="#2-20、两个字符串的删除操作" class="headerlink" title="2.20、两个字符串的删除操作"></a>2.20、两个字符串的删除操作</h2><h3 id="1、题目描述-18"><a href="#1、题目描述-18" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定两个单词 <strong>word1</strong> 和 <strong>word2</strong> ，找到使得 <strong>word1</strong> 和 <strong>word2</strong> 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;sea&quot;</span>, <span class="string">&quot;eat&quot;</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 第一步将<span class="string">&quot;sea&quot;</span>变为<span class="string">&quot;ea&quot;</span>，第二步将<span class="string">&quot;eat&quot;</span>变为<span class="string">&quot;ea&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-18"><a href="#2、解题思路-18" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>动态规划解法一</p></blockquote><ul><li><p>确定 dp 数组的含义，<code>dp[i][j]</code> 表示以 <code>i - 1</code> 为结尾的字符串 <code>word1</code> 和以 <code>j - 1</code> 为结尾的字符串 <code>word2</code> ，想要达到相等，所需要删除的元素的最少次数</p></li><li><p>确定递推公式</p></li></ul><ol><li>当 <code>word1[i - 1] == word2[j - 1]</code> 时，此时我们称 <code>word1[i - 1]</code> 和 <code>word2[j - 1]</code> 为公共字符，增加公共字符后不会使最少删除次数发生改变，比如 <code>site</code> 与 <code>hae</code> 的最少删除次数和 <code>sit</code> 与 <code>ha</code> 的最少删除次数一致，所以有</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">	dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当 <code>word1[i - 1] != word2[j - 1]</code> 时，我们需要考虑三种情况<ol><li>删除 <code>word1[i - 1]</code> ，此时最少操作数为 <code>dp[i - 1][j]</code> + 1，这里的 1 就是删除 <code>word1[i - 1]</code> 这次操作</li><li>删除 <code>word2[j - 1]</code> ，此时最少操作数为 <code>dp[i][j - 1]</code> + 1</li><li>同时删除 <code>word1[i - 1]</code> 和 <code>word2[j - 1]</code> ，此时最少操作数为 <code>dp[i - 1][j - 1]</code> + 2，其中 2 为删除 <code>word1[i - 1]</code> 和 <code>word2[j - 1]</code> 两次操作，从三者之间取最小值，就是这种情况下的最小删除次数</li></ol></li></ol><ul><li>初始化 dp 数组</li></ul><ol><li>当 j == 0 时， word2 为空串，此时最小删除数等于 word1 的长度，即 <code>dp[i][0] = i</code></li><li>同理，当 i == 0 时， word1 为空串，此时最小删除数等于 word2 的长度，即 <code>dp[0][j] = j</code></li></ol><blockquote><p>动态规划解法二</p></blockquote><ul><li>由题意得 <code>word1</code> 与 <code>word2</code> 长度，分别记为 <code>len1</code> 和 <code>len2</code> ，然后使用动态规划求解 <code>word1</code> 与 <code>word2</code> 的最长公共子序列长度，记为 <code>maxLength</code> ，我们要求的结果为 <code>len1 + len2 - 2 * maxLength</code></li></ul><h3 id="3、解题代码-18"><a href="#3、解题代码-18" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><blockquote><p>解法一代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = word1.length(), length2 = word2.length();</span><br><span class="line">    <span class="keyword">if</span> (length1 == <span class="number">0</span>) <span class="keyword">return</span> length2;</span><br><span class="line">    <span class="keyword">if</span> (length2 == <span class="number">0</span>) <span class="keyword">return</span> length1;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp </span></span><br><span class="line">    <span class="comment">// 当 j == 0 时，word1 和 word2 的最小删除数为 word1 子串的长度，即 i </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length1;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理初始化 dp[0][j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= length2;j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= length1;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= length2;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 此时 word1[i - 1] 与 word2[i - 2] 相等，所以它是公共字符</span></span><br><span class="line">                <span class="comment">// 当前两个子串的最小删除数与去掉公共字符的最小删除数相等</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此时有三种情况进行考虑，分别是</span></span><br><span class="line">                dp[i][j] = Math.min(</span><br><span class="line">                    Math.min(</span><br><span class="line">                        <span class="comment">//1 删去 word1[i - 1]</span></span><br><span class="line">                        dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                        <span class="comment">//2 删去 word2[j - 1]</span></span><br><span class="line">                        dp[i][j - <span class="number">1</span>] + <span class="number">1</span>),</span><br><span class="line">                    <span class="comment">//3 同时删去 word1[i - 1] 和 word2[j - 1]</span></span><br><span class="line">                    dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 我们需要取上面三种情况的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解法二</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = word1.length(), length2 = word2.length();</span><br><span class="line">    <span class="keyword">if</span> (length1 == <span class="number">0</span>) <span class="keyword">return</span> length2;</span><br><span class="line">    <span class="keyword">if</span> (length2 == <span class="number">0</span>) <span class="keyword">return</span> length1;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= length1;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= length2;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length1 + length2 - <span class="number">2</span> * dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-21、编辑距离"><a href="#2-21、编辑距离" class="headerlink" title="2.21、编辑距离"></a>2.21、编辑距离</h2><h3 id="1、题目描述-19"><a href="#1、题目描述-19" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p></blockquote><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;intention&quot;</span>, word2 = <span class="string">&quot;execution&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">inention -&gt; enention (将 <span class="string">&#x27;i&#x27;</span> 替换为 <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">enention -&gt; exention (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">exention -&gt; exection (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">exection -&gt; execution (插入 <span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-19"><a href="#2、解题思路-19" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>我们以一个例子，通过打表的方式来观察编辑次数与所给字符串的关系</li></ul><blockquote><p>以 <strong>CTGCG</strong> 与 <strong>GATAG</strong> 为例</p></blockquote><table><thead><tr><th><br></th><th><br></th><th>C</th><th>T</th><th>G</th><th>C</th><th>G</th></tr></thead><tbody><tr><td></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>G</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>4</td></tr><tr><td>A</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td></tr><tr><td>T</td><td>3</td><td>3</td><td>2</td><td>3</td><td>4</td><td>4</td></tr><tr><td>A</td><td>4</td><td>4</td><td>3</td><td>3</td><td>4</td><td>5</td></tr><tr><td>G</td><td>5</td><td>5</td><td>4</td><td>3</td><td>4</td><td>4</td></tr></tbody></table><ol><li>当所给的字符串均为空串时，此时二者的编辑距离为 0</li><li>当 s1 为空串，s2 不为空串时，此时二者之间的最短编辑距离为 <code>s2.lengt()</code>，反之亦然，所以我们可以将表格中的第一行第一列进行初始化</li><li>当 s1 为 “G” 且 s2 为 “C” 时，二者的最小编辑距离为 1 ，此时只需要将 G 修改为 1 即可，我们根据 s1 与 s2 的情况填充表格</li></ol><ul><li>定义 dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i][j]</code> 表示 <code>word1</code> 中下标范围为 <code>[0, i - 1]</code> 的子串 a 与 <code>word2</code> 中下标范围为 <code>[0, j - 1]</code> 的子串 b ，它们二者之间的最短编辑距离。</p></blockquote><ul><li>状态转移方程</li></ul><ol><li>当 <code>word1[i - 1] == word2[j - 1]</code> 时，我们可以将这个相等的字符看为一个公共字符， <code>word1[0. i - 1]</code> 子串与 <code>word2[0, j - 1]</code> 子串的最短编辑距离与二者去掉公共字符后留下来的子串的最短编辑距离相等，比如说 <code>hat</code> 与 <code>het</code> 最短编辑距离和 <code>ha</code> 与 <code>he</code> 的最短编辑距离相等</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li>当 <code>word1[i - 1] != word2[j - 1]</code> 时，此时我们有多个操作可供选择<ol><li>word1 删除一个元素，那么就是以下标 <code>word1[0, i - 2]</code> 与 <code>word2[0, j - 1]</code> 的最短编辑距离，再加上一个删除操作，此时得到的式子应该为 <code>dp[i - 1][j] + 1</code></li><li>word2 删除一个元素，那么就是以下标 <code>word1[0, i - 1]</code> 与 <code>word2[0. j - 2]</code> 的最短编辑距离，再加上一个删除操作，此时得到的式子应该为 <code>dp[i][j - 1] + 1</code></li><li>替换元素，此时 word1 替换 <code>word1[i - 1]</code> ，使其等于 <code>word2[j - 1]</code> ，此时我们又可以将 <code>word1[i - 1]</code> 看为一个公共元素，只不过我们需要原来的基础上加上一次编辑，此时得到的式子为 <code>dp[i - 1][j - 1] + 1</code></li><li>对于添加操作来说， <code>word1</code> 添加一个字符，就相当于 <code>word2</code> 删除一个字符，比如说，当 <code>word1</code> 为 <code>abce</code> ，<code>word2</code> 为 <code>abc</code> 时，<code>word1</code> 删去 <code>e</code> 与 <code>word2</code> 加上 <code>e</code> 的结果都相同，所以我们只需要考虑删除的情况即可</li></ol></li></ol><ul><li>初始化 dp 数组</li></ul><blockquote><p>当两个字符串有一个为空串时，此时二者的最短编辑距离即为另外一个字符串的长度，我们假设 dp[i][j] 中，i 为 word1 字符串下标的变化情况，而 j 为 word2 字符串下标的变化情况，此时有</p></blockquote><ol><li>当 j == 0 时，此时我们初始化 <code>dp[i][0] = i</code></li><li>当 i == 0 时，此时我们初始化 <code>dp[0][j] = j</code></li></ol><h3 id="3、解题代码-19"><a href="#3、解题代码-19" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = word1.length(), length2 = word2.length();</span><br><span class="line">    <span class="keyword">if</span> (length1 == <span class="number">0</span> &amp;&amp; length2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length1 == <span class="number">0</span> &amp;&amp; length2 != <span class="number">0</span>) <span class="keyword">return</span> length2;</span><br><span class="line">    <span class="keyword">if</span> (length2 == <span class="number">0</span> &amp;&amp; length1 != <span class="number">0</span>) <span class="keyword">return</span> length1;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length1;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= length2;j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= length1;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= length2;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 对于公共字符，直接取去掉公共字符后的最短编辑距离即可</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 对于不是公共字符的情况，我们需要进行选择</span></span><br><span class="line">                dp[i][j] = Math.min(</span><br><span class="line">                    Math.min(</span><br><span class="line">                        <span class="comment">// 选择一：删除 word1[i - 1]</span></span><br><span class="line">                        dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                        <span class="comment">// 选择二：删除 word2[j - 1]</span></span><br><span class="line">                        dp[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                    ),</span><br><span class="line">                    <span class="comment">// 选择三：替换 word1[i - 1]</span></span><br><span class="line">                    dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-22、最长回文子序列"><a href="#2-22、最长回文子序列" class="headerlink" title="2.22、最长回文子序列"></a>2.22、最长回文子序列</h2><h3 id="1、题目描述-20"><a href="#1、题目描述-20" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;bbbab&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一个可能的最长回文子序列为 <span class="string">&quot;bbbb&quot;</span> 。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：一个可能的最长回文子序列为 <span class="string">&quot;bb&quot;</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-20"><a href="#2、解题思路-20" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>确定 dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i][j]</code> 表示字符串 s 中下标范围为 [i ,j] 的子串 a 中最长回文子序列的长度</p></blockquote><ul><li>确定递推公式</li></ul><ol><li>如果 s[i] == s[j] ，那么 <code>dp[i][j] = dp[i + 1][j - 1] + 2</code></li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154532.png" alt="image.png"></p><ol start="2"><li>如果 s[i] != s[j] ，那么此时 s[i] 与 s[j] 同时加入并不能增加 [i, j] 区间回文子序列的长度，那么我们分别加入 s[i] ，s[j] ，查看哪一个可以组成最长的最文子序列</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154533.png" alt="image.png"></p><blockquote><p>所以我们可以得出递推公式为</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">	dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>对于 dp[i][j] ，当 <code>i == j</code> 时，子串 s[i] 就 i 是一个回文子序列，长度为 1 ，所以我们初始化 <code>dp[i][i] = 1</code></p></blockquote><ul><li>确定遍历顺序</li></ul><blockquote><p>根据递推公式，dp[i][j] 需要根据 <code>dp[i + 1][j - 1]</code> 、 <code>dp[i + 1][j]</code> 和 <code>dp[i][j - 1]</code> 退出，如果我们希望得出 <code>dp[i][j]</code> ，那么我们就先有当前行下一行的数据，所以对于外层行遍历，我们需要从尾到头进行遍历，而对于内层列遍历，我们需要从头到尾进行遍历</p></blockquote><h3 id="3、解题代码-20"><a href="#3、解题代码-20" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; len;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-23、让字符串成为回文串的最少插入次数"><a href="#2-23、让字符串成为回文串的最少插入次数" class="headerlink" title="2.23、让字符串成为回文串的最少插入次数"></a>2.23、让字符串成为回文串的最少插入次数</h2><h3 id="1、题目描述-21"><a href="#1、题目描述-21" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p><p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;zzazz&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串 <span class="string">&quot;zzazz&quot;</span> 已经是回文串了，所以不需要做任何插入操作。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;mbadm&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：字符串可变为 <span class="string">&quot;mbdadbm&quot;</span> 或者 <span class="string">&quot;mdbabdm&quot;</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-21"><a href="#2、解题思路-21" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>确定 dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i][j]</code> 表示字符串 s 中下标范围为 <code>[i,j]</code> 的子串，要变为回文串所需要的最少插入次数。</p></blockquote><ul><li>确定状态转移方程</li></ul><ol><li>当 <code>s[i] == s[j]</code> 时，此时对于子串 <code>s[i. j]</code> 而言，左右两边的字符不用修改，我们只需要求让下标范围为 <code>[i + 1,j - 1]</code> 的子串变为回文串的最少插入次数即可，此时有 <code>dp[i][j] = dp[i + 1][j - 1]</code></li></ol><blockquote><p>比如说，对于字符串 <strong>abcda</strong> ，由于它左右两边的字符相等，所以我们只需要求出让 <strong>bcd</strong> 变为回文串的最少插入次数，即可求出让整个字符串变为回文串的最少插入次数</p></blockquote><ol start="2"><li>当 <code>s[i] != s[j]</code> 时，此时我们需要选择最优的插入方案，即在下面的结果中选择最小值<ol><li>将 <code>s[i]</code> 插入 <code>j - 1</code> 的位置，同时将 <code>s[j]</code> 插入到 <code>i - 1</code> 的位置，此时插入后的字符串中存在以下关系，即 <code>s[i - 1] == s[j]</code> 且 <code>s[i] == s[j - 1]</code> ，比如说对于字符串 <strong>abcde</strong> ，我们将 <code>s[i]</code> 插入到 e 的左边，将 <code>s[j]</code> 插入到 a 的左边，字符串变为 <strong>eabcdae</strong> ，此时情况又转为了 <code>s[i] == s[j]</code> 的情况，我们只需要考虑 <strong>bcd</strong> 变为回文串所需要的最小插入次数即可，即 <code>dp[i][j] = dp[i + 1][j - 1] + 2</code> ，这种做法可能不是最优解，比如说，对于字符串 <strong>aaax</strong> ，我们只需要在左边插入一个 x 就可以将其变为回文串。</li><li><strong>我们先将 <code>s[i + 1,j]</code> 或者 <code>s[i, j - 1]</code> 变为回文串</strong>。假设将 <code>s[i + 1, j]</code> 变为回文串的代价 a 和将 <code>s[i, j - 1]</code> 变为回文串的代价 b ，此时我们比较两个代价的大小，取代价小的那个子串进行修改，最后将结果 + 1 即得到将字符串 <code>s[i,j]</code> 变为回文串的最小插入次数，这种情况下，式子为 <code>dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1</code> ；比如说对于字符串 <strong>aaax</strong> ，我们可以看出，将子串 <strong>aaa</strong> 变为回文串的代价较小，所以将 <strong>aaax</strong> 变为回文串的代价即为将 aaa 变为回文串的代价 + 1，即 1 .</li></ol></li><li>所以，本题的状态转移方程如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">	dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	dp[i][j] = Math.min(Math.min(dp[i + <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>), dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>当 <code>i == j</code> 时，此时子串中只有一个字符，所以该子串可以自成一个回文串，所以使其称为回文串的最少插入次数为 0 ，即 <code>dp[i][i] == 0</code></p></blockquote><ul><li>确定遍历顺序</li></ul><blockquote><p>这道题的遍历顺序与最长回文子序列一般，由于 <code>dp[i][j]</code> 依赖于下一行的数据，所以对于外层行遍历来说，我们需要从尾到头遍历，保证我们需要的结果（i + 1 行的数据）都是已经计算出来的。</p></blockquote><h3 id="3、解题代码-21"><a href="#3、解题代码-21" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外层循环从尾到头遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="comment">// 内层循环从头到尾遍历，j 需要严格大于 i，因为 i == j 的情况我们在初始化时已经考虑过了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; len;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这种情况下，我们需要进行选择</span></span><br><span class="line">                dp[i][j] = Math.min(</span><br><span class="line">                    Math.min(</span><br><span class="line">                        <span class="comment">// 选择一：先将子串 s[i + 1,j] 变为回文串，然后在该基础上 + 1</span></span><br><span class="line">                        dp[i + <span class="number">1</span>][j] + <span class="number">1</span>, </span><br><span class="line">                        <span class="comment">// 选择二：先将子串 s[i, j - 1] 变为回文串，然后在基础上  +1</span></span><br><span class="line">                        dp[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                    ),</span><br><span class="line">                    dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-24、俄罗斯套娃信封问题"><a href="#2-24、俄罗斯套娃信封问题" class="headerlink" title="2.24、俄罗斯套娃信封问题"></a>2.24、俄罗斯套娃信封问题</h2><h3 id="1、题目描述-22"><a href="#1、题目描述-22" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [wi, hi]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes = [[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最多信封的个数为 <span class="number">3</span>, 组合为: [<span class="number">2</span>,<span class="number">3</span>] =&gt; [<span class="number">5</span>,<span class="number">4</span>] =&gt; [<span class="number">6</span>,<span class="number">7</span>]。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-22"><a href="#2、解题思路-22" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>对于这道题来说，我们可以将所给数组的元素进行排序，先将这些信封根据宽度进行从小到大排序，对于宽度相等的信封，根据高度从大到小排序，比如说，对于示例一给的例子，在经过排序后，得到的顺序如下</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154534.png" alt="image.png"></p><ul><li>求 h 数组的最长递增子序列长度 <code>maxLength</code>，得到的结果就是本题的结果</li></ul><blockquote><p>因为两个 w 相同的信封不能相互包含，所以在 w 相同时，我们将这些信封按照 h 从大到小排序，确保最多只有一个信封被选入到最长递增子序列中，这保证了最终的信封序列中不会出现多个 w 相同的信封</p></blockquote><h3 id="3、解题代码-22"><a href="#3、解题代码-22" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><ul><li>将传入的信封数组按照 w 从小到大进行排序，对于 w 相同的信封，根据 h 从大到小排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (envelopes.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对传入的信封数组进行排序，先根据 w 进行升序排序，对于 w 相等的元素，根据 h 进行降序排序</span></span><br><span class="line">    Arrays.sort(envelopes, (envelopes1, envelopes2) -&gt; envelopes1[<span class="number">0</span>] == envelopes2[<span class="number">0</span>] ? envelopes2[<span class="number">1</span>] - envelopes1[<span class="number">1</span>] : envelopes1[<span class="number">0</span>] - envelopes2[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 将所有信封的 h 看为一个数组，求这个数组的最长递增子序列长度</span></span><br><span class="line">    <span class="comment">// 创建一个 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; envelopes.length;i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用一个变量来保存最长递增子序列长度，初始化为 1 </span></span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; envelopes.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envelopes[j][<span class="number">1</span>] &lt; envelopes[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = Math.max(dp[i], maxLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-25、正则表达式匹配"><a href="#2-25、正则表达式匹配" class="headerlink" title="2.25、正则表达式匹配"></a>2.25、正则表达式匹配</h2><h3 id="1、题目描述-23"><a href="#1、题目描述-23" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p></blockquote><ol><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ol><blockquote><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code> 的，而不是部分字符串。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aa&quot;</span> p = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：<span class="string">&quot;a&quot;</span> 无法匹配 <span class="string">&quot;aa&quot;</span> 整个字符串。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aa&quot;</span> p = <span class="string">&quot;a*&quot;</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：因为 <span class="string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">&#x27;a&#x27;</span>。因此，字符串 <span class="string">&quot;aa&quot;</span> 可被视为 <span class="string">&#x27;a&#x27;</span> 重复了一次。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-23"><a href="#2、解题思路-23" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>对于 * ，我们需要将它与 * 号的前一个字符 x 看为一个整体，它表示可以匹配零个或者多个 x ，比如说 a* 可以匹配 0 个或者多个 a</li></ul><blockquote><p>使用递归解决这道题</p></blockquote><ul><li>编写一个递归函数 <code>boolean process(char[] str, int si, char[] pattern, int pi)</code> ，这个函数表示的含义为：字符串 <code>str[si, str.length - 1]</code> 能否被字符串 <code>pattern[pi, pattern.length - 1]</code> 完全匹配</li><li>编写 process 函数，我们需要保证传入的 pi 下标对应的字符不是 *</li></ul><ol><li>base case 1，当 <code>si == str.length</code> 时，此时 str 表示的字符串为空串 “” ，这种情况下，如果 <code>pi == length</code> 或者 <code>pattern</code> 字符串剩下的子串可以与 “” 进行匹配，那么返回 true</li></ol><blockquote><p>如何表示 <code>pattern</code> 字符串剩下的子串可以与 “” 进行匹配呢，即 <strong>pattern[pi] != “<code>*</code>“ &amp;&amp; pattern[pi + 1] == “<code>*</code>“ &amp;&amp; process(str, str.length, pattern, pi + 2)</strong></p><p>比如说，如果此时 <code>pattern</code> 剩下的字符串为 <strong><code>a*b*c*</code></strong> 时，就可以与空串进行匹配</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 si == str.length ，那么证明此时进行完全匹配的字符串 str 已经变为一个空串</span></span><br><span class="line"><span class="keyword">if</span> (si == str.length) &#123;</span><br><span class="line">    <span class="comment">// 此时有两种情况可以返回 true</span></span><br><span class="line">    <span class="comment">// 第一种，此时 pattern 也为一个空串</span></span><br><span class="line">    <span class="keyword">if</span> (pi == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二种，pattern[pi] 不为 * 且 pattern[pi + 1] 为 *</span></span><br><span class="line">    <span class="comment">// 同时 pattern [pi + 2,...] 可以与空串进行匹配</span></span><br><span class="line">    <span class="keyword">if</span> (pi + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[pi + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> process(str, si, pattern, pi  +<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果无法满足上面的条件，那么直接返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>base case 2 ，当 <code>pi == pattern.length</code> 时，此时 pattern 已经为空串，那么此刻只有 s 为空串时，二者才能进行匹配</li><li>当 si 与 pi 都没有到达最终位置时，此时又可以分为多种情况进行讨论<ol><li>如果 pi + 1 位置对应的字符不是 * ，那么有两种情况可以完全匹配成功，第一种就是 <code>str[si] == pattern[pi]</code> 且 后面的字符串可以完全匹配；第二种就是 <code>pattern[pi] == &#39;.&#39;</code> 且后面的字符串可以完全匹配</li><li>如果 pi + 1 位置对应的字符是 * 且 <code>str[si] != pattern[pi]</code> ，那么此时只能让 pattern[pi]* 变为 0 个 pattern[pi]，且需要满足 str[si] 及之后的字符串可以与 pattern[pi + 2] 及之后的字符串完全匹配</li><li>当 pi + 1 位置对应的字符是 * 且 <code>str[si] == pattern[pi]</code> 时 ，此时就算 str[si] == pattern[pi] ，pattern[pi] * 也可能变为 0 个 pattern[pi]</li><li>接下来我们就要判断 <code>pattern[pi]*</code> 变为一个 pattern[pi]、多个 pattern[pi] 的情况了</li></ol></li></ol><blockquote><p>使用动态规划解决这道题</p></blockquote><ul><li>对于上面的 <code>process</code> 函数中，只有两个可变参数，即 si 与 pi ，当这两个参数确定后，得到的值（返回值）也就确定了，所以我们可以以 pi 为行， si 为列，以结果为值，将三者映射到一张二维表中</li><li>确定 dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i][j]</code> 表示字符串 <code>str[i, ...]</code> 与 <code>pattern[j, ...]</code> 是否可以进行完全匹配</p></blockquote><ol><li><code>dp[i][j] == -1</code> ，表示 <code>str[i, ...]</code> 与 <code>pattern[j, ...]</code> 的匹配结果没有计算过</li><li><code>dp[i][j] == 0</code> ，表示 <code>str[i, ...]</code> 与 <code>pattern[j, ...]</code> 的匹配结果已经计算过了，且返回值为 false</li><li><code>dp[i][j] == 1</code> ，表示 <code>str[i, ...]</code> 与 <code>pattern[j, ...]</code> 的匹配结果已经计算过了，且返回值为 true</li></ol><ul><li>初始化 dp 数组，根据上面我们提到的 dp 数组的含义，我们需要将 dp 数组中所有的元素都初始化为 -1</li><li>在进行递归的过程中，我们需要将这张缓存表一起放入到递归函数中，然后对这张表进行存取</li></ul><ol><li>在进行递归时，如果发现当前参数对应的值已经在缓存中出现（<code>dp[i][j] != -1</code>），那么不用计算，直接返回表中的值</li></ol><h3 id="3、解题代码-23"><a href="#3、解题代码-23" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><blockquote><p>递归</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] pattern = p.toCharArray();</span><br><span class="line">    <span class="keyword">return</span> process(str, <span class="number">0</span>, pattern, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断 str[si, str.length - 1] 的子串能否被 pattern[pi, pattern.length - 1] 完全匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> si, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> pi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 si == str.length ，那么证明此时进行完全匹配的字符串 str 已经变为一个空串</span></span><br><span class="line">    <span class="keyword">if</span> (si == str.length) &#123;</span><br><span class="line">        <span class="comment">// 此时有两种情况可以返回 true</span></span><br><span class="line">        <span class="comment">// 第一种，此时 pattern 也为一个空串</span></span><br><span class="line">        <span class="keyword">if</span> (pi == pattern.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二种，pattern[pi] 不为 * 且 pattern[pi + 1] 为 *</span></span><br><span class="line">        <span class="comment">// 同时 pattern [pi + 2,...] 可以与空串进行匹配</span></span><br><span class="line">        <span class="keyword">if</span> (pi + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[pi + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> process(str, si, pattern, pi  +<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果无法满足上面的条件，那么直接返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 2 ，当 pi == pattern.length 时，此时 pattern 已经为空串，那么此刻只有 s 为空串时，二者才能进行匹配</span></span><br><span class="line">    <span class="keyword">if</span> (pi == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> si == str.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// si 没有终止，pi 也没有终止</span></span><br><span class="line">    <span class="comment">//1 当 pi + 1 位置对应的字符不是 * 时</span></span><br><span class="line">    <span class="keyword">if</span> (pi + <span class="number">1</span> &gt;= pattern.length || pattern[pi + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 si 对应的字符和 pi 对应的字符相等，或者 pi 对应的字符为 . ，且 si + 1 后的字符串可以与 pi + 1 后的字符串进行匹配，那么返回 true ，否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> ((str[si] == pattern[pi]) || (pattern[pi] == <span class="string">&#x27;.&#x27;</span>)) &amp;&amp; process(str, si + <span class="number">1</span>, pattern, pi + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 当 pi + 1 位置对应的字符是 * 且 str[si] != pattern[pi] 时，此时只能让 pattern[pi]* 变为 0 个 pattern[pi]</span></span><br><span class="line">    <span class="keyword">if</span> (pattern[pi] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; str[si] != pattern[pi]) &#123;</span><br><span class="line">        <span class="keyword">return</span> process(str, si, pattern, pi + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 当 pi + 1 位置对应的字符是 * 且 str[si] == pattern[pi] 时，</span></span><br><span class="line">    <span class="comment">// 此时就算 str[si] == pattern[pi] ，pattern[pi] * 也可能变为 0 个 pattern[pi]</span></span><br><span class="line">    <span class="keyword">if</span> (process(str, si, pattern, pi + <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下，我们判断 pattern[pi]* 变为一个或者多个 pattern[pi] 的情况</span></span><br><span class="line">    <span class="keyword">while</span> (si &lt; str.length &amp;&amp; (str[si] == pattern[pi] || pattern[pi] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process(str, si + <span class="number">1</span>, pattern, pi + <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则直接返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>动态规划</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] pattern = p.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length + <span class="number">1</span>][pattern.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= str.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= pattern.length;j++) &#123;</span><br><span class="line">            dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(str, <span class="number">0</span>, pattern, <span class="number">0</span>, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断 str[si, str.length - 1] 的子串能否被 pattern[pi, pattern.length - 1] 完全匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> si, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> pi, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先查找缓存是否已经计算过，如果不等于 -1 ，那么证明计算过</span></span><br><span class="line">    <span class="keyword">if</span> (dp[si][pi] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[si][pi] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面，在我们进行返回前，需要将值存入缓存中然后再返回</span></span><br><span class="line">    <span class="comment">// 如果 si == str.length ，那么证明此时进行完全匹配的字符串 str 已经变为一个空串</span></span><br><span class="line">    <span class="keyword">if</span> (si == str.length) &#123;</span><br><span class="line">        <span class="comment">// 此时有两种情况可以返回 true</span></span><br><span class="line">        <span class="comment">// 第一种，此时 pattern 也为一个空串</span></span><br><span class="line">        <span class="keyword">if</span> (pi == pattern.length) &#123;</span><br><span class="line">            dp[si][pi] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二种，pattern[pi] 不为 * 且 pattern[pi + 1] 为 *</span></span><br><span class="line">        <span class="comment">// 同时 pattern [pi + 2,...] 可以与空串进行匹配</span></span><br><span class="line">        <span class="keyword">if</span> (pi + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[pi + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> result = process(str, si, pattern, pi  +<span class="number">2</span>, dp);</span><br><span class="line">            dp[si][pi] = result ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果无法满足上面的条件，那么直接返回 false</span></span><br><span class="line">        dp[si][pi] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 2 ，当 pi == pattern.length 时，此时 pattern 已经为空串，那么此刻只有 s 为空串时，二者才能进行匹配</span></span><br><span class="line">    <span class="keyword">if</span> (pi == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = si == str.length;</span><br><span class="line">        dp[si][pi] = result ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// si 没有终止，pi 也没有终止</span></span><br><span class="line">    <span class="comment">//1 当 pi + 1 位置对应的字符不是 * 时</span></span><br><span class="line">    <span class="keyword">if</span> (pi + <span class="number">1</span> &gt;= pattern.length || pattern[pi + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 si 对应的字符和 pi 对应的字符相等，或者 pi 对应的字符为 . ，且 si + 1 后的字符串可以与 pi + 1 后的字符串进行匹配，那么返回 true ，否则返回false</span></span><br><span class="line">        <span class="keyword">boolean</span> result = ((str[si] == pattern[pi]) || (pattern[pi] == <span class="string">&#x27;.&#x27;</span>)) &amp;&amp; process(str, si + <span class="number">1</span>, pattern, pi + <span class="number">1</span>, dp);</span><br><span class="line">        dp[si][pi] = result ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 当 pi + 1 位置对应的字符是 * 且 str[si] != pattern[pi] 时，此时只能让 pattern[pi]* 变为 0 个 pattern[pi]</span></span><br><span class="line">    <span class="keyword">if</span> (pattern[pi] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; str[si] != pattern[pi]) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = process(str, si, pattern, pi + <span class="number">2</span>, dp);</span><br><span class="line">        dp[si][pi] = result ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 当 pi + 1 位置对应的字符是 * 且 str[si] == pattern[pi] 时，</span></span><br><span class="line">    <span class="comment">// 此时就算 str[si] == pattern[pi] ，pattern[pi] * 也可能变为 0 个 pattern[pi]</span></span><br><span class="line">    <span class="keyword">if</span> (process(str, si, pattern, pi + <span class="number">2</span>, dp)) &#123;</span><br><span class="line">        dp[si][pi] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下，我们判断 pattern[pi]* 变为一个或者多个 pattern[pi] 的情况</span></span><br><span class="line">    <span class="keyword">while</span> (si &lt; str.length &amp;&amp; (str[si] == pattern[pi] || pattern[pi] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process(str, si + <span class="number">1</span>, pattern, pi + <span class="number">2</span>, dp)) &#123;</span><br><span class="line">            dp[si][pi] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则直接返回 false</span></span><br><span class="line">    dp[si][pi] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-26、礼物的最大价值"><a href="#2-26、礼物的最大价值" class="headerlink" title="2.26、礼物的最大价值"></a>2.26、礼物的最大价值</h2><h3 id="1、题目描述-24"><a href="#1、题目描述-24" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次<strong>向右</strong>或者<strong>向下</strong>移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">5</span>→<span class="number">2</span>→<span class="number">1</span> 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-24"><a href="#2、解题思路-24" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>确定 dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i][j]</code> 表示到达棋盘上的 <code>[i , j]</code> 位置时，所能拿到的礼物的总价值</p></blockquote><ul><li>状态转移方程</li></ul><blockquote><p>对于棋盘上的某个位置 <code>(i, j)</code> 来说 ，它的状态可以由两个状态得来，即它的上方元素 <code>（i - 1,j）</code> 和左边元素 <code>（i, j - 1）</code> 得到，同时还需要加上当前位置礼物的价值 <code>nums[i][j]</code> ，我们需要在上面的选择中取较大值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + nums[i][j];</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>我们需要初始化第一行和第一列的元素</p></blockquote><ol><li>其中第一行的元素为 nums[0,i] 上的元素累加值，比如说，在例子中， dp[0][0] 应该初始化为 <code>nums[0][0]</code> ，dp[0][1] 应该初始化为 <code>nums[0][0] + nums[0][1]</code> ，<code>dp[0][2] = nums[0][0] + nums[0][1] + nums[0][2]</code></li><li>同理，第一列的元素也应该按照上面的规则初始化，只不过变为向下累加。</li></ol><ul><li>遍历顺序</li></ul><blockquote><p>这道题是最常规的动态规划问题，我们只需要按照从头到尾的顺序进行遍历即可，可以看到 dp[i][j] 是由上一行、前一列的元素推导出来的。</p></blockquote><h3 id="3、解题代码-24"><a href="#3、解题代码-24" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> row = grid.length;</span><br><span class="line">       <span class="keyword">int</span> column = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][column];</span><br><span class="line">       <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 初始化 dp 数组</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++) &#123;</span><br><span class="line">           value += grid[i][<span class="number">0</span>];</span><br><span class="line">           dp[i][<span class="number">0</span>] = value;</span><br><span class="line">       &#125;</span><br><span class="line">       value = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; column;j++) &#123;</span><br><span class="line">           value += grid[<span class="number">0</span>][j];</span><br><span class="line">           dp[<span class="number">0</span>][j] = value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; row;i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; column;j++) &#123;</span><br><span class="line">               dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[row - <span class="number">1</span>][column - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="2-27、最长不含重复字符的子字符串"><a href="#2-27、最长不含重复字符的子字符串" class="headerlink" title="2.27、最长不含重复字符的子字符串"></a>2.27、最长不含重复字符的子字符串</h2><h3 id="1、题目描述-25"><a href="#1、题目描述-25" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-25"><a href="#2、解题思路-25" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>明确 dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i]</code> 表示<strong>以字符 <code>s.charAt(i)</code> 结尾的最长不含重复字符的子字符串的长度</strong>。</p></blockquote><ul><li>明确状态转移方程</li></ul><blockquote><p>对于 i 位置的字符 <code>x</code> 来说，我们需要找到 x 在 s 中的上一个位置 index ，然后根据 index 来判断下一步该如何选择</p></blockquote><ol><li>如果 <code>index == -1</code> ，此时代表 x 字符串在 <code>[0, i - 1]</code> 位置内不曾出现，那么 x 字符可以加入到以 <code>i - 1</code> 字符为结尾的最长不含重复字符的子字符串中，即此时有 <code>dp[i] = dp[i - 1] + 1</code> ，比如说当前字符串为 <strong>abcde</strong> ，此时 e 为 x ，e 未曾在之前的字符串中出现，那么将其加入到以 d 结尾的子字符串中，不会打破原来的不重复规则。</li><li>如果找到了一个不为 -1 的 index ，那么证明 x 字符在 <code>[0, i - 1]</code> 位置内出现过，如果<ol><li><code>dp[i - 1] &lt; i - index</code> ，此时说明字符 <code>s[index]</code> 在子字符串 <code>dp[i - 1]</code> 区间之外，此时将 <code>s[i]</code> 加入到以 <code>s[i - 1]</code> 为结尾的最长不重复子串中，不会破坏规则，此时 <code>dp[i] = dp[i - 1] + 1</code> ，比如说对于字符串 <strong>axxbcda</strong> 中，<code>s[i] = &#39;a&#39;</code> ，而前一个 <code>&#39;a&#39;</code> 出现在 <code>dp[i - 1]</code> 的最长不重复子串之外，所以将 <code>s[i]</code> 加入到 <code>s[i - 1]</code> 结尾的最长不重复子串中不会破坏规则</li><li><code>dp[i - 1] &gt;= i - index</code> ，说明字符串 <code>s[index]</code> 在子字符串 <code>dp[i - 1]</code> 的区间之内，所以此时以 <code>s[i]</code> 为结尾的最长不重复子串的长度由 <code>s[index]</code> 中 index 的位置决定，即 <code>dp[i] = i - index</code></li></ol></li></ol><ul><li>我们使用一个 Map 来保存字符 <code>s[i]</code> 的上一个出现位置，如果不存在，那么返回 -1 ，在循环过程中，需要更新这个 Map</li></ul><h3 id="3、解题代码-25"><a href="#3、解题代码-25" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 由于 dp[i] 只与前一个状态 dp[i - 1] 有关，所以使用一个变量进行滚动</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        <span class="comment">// 如果没有对应的 key ，那么返回 -1</span></span><br><span class="line">        <span class="keyword">int</span> index = memo.getOrDefault(s.charAt(i), -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新 map </span></span><br><span class="line">        memo.put(s.charAt(i), i);</span><br><span class="line">        temp = temp &lt; i - index ? temp + <span class="number">1</span> : i - index;</span><br><span class="line">        result = Math.max(temp, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-28、把数字翻译成字符串"><a href="#2-28、把数字翻译成字符串" class="headerlink" title="2.28、把数字翻译成字符串"></a>2.28、把数字翻译成字符串</h2><h3 id="1、题目描述-26"><a href="#1、题目描述-26" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p><strong>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</strong></p></blockquote><ul><li><strong>示例一</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-26"><a href="#2、解题思路-26" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li><strong>使用动态规划解决这道题</strong></li><li><strong>明确 dp 数组的含义</strong></li></ul><blockquote><p>**我们设 **<code>dp[i]</code> 的含义为：下标范围为 <code>[0, i]</code> 的那部分数字有 <code>dp[i]</code> 种翻译方法</p></blockquote><ul><li><strong>明确状态转移方程</strong></li></ul><blockquote><p>**对于 **<code>dp[i]</code> 而言，我们需要进行分类讨论</p></blockquote><ol><li>** 当数字中的最后两个数字，即 **<code>[i - 1, i]</code> 范围的数字可以被翻译为一个数时，<code>0 =&lt; (i - 1) * 10 + i &lt;= 25</code> 时，那么我们有两种选择，我们即可以直接将最后一个数字翻译为一个字母，此时存在等式 <code>dp[i] = dp[i - 1]</code> ；又可以将最后两个数字直接翻译成一个字母，此时存在等式 <code>dp[i] = dp[i - 2]</code></li></ol><blockquote><p>**情况 1 需要综合两个选择进行考虑，所以这种情况下 **<code>dp[i] = dp[i - 1] + dp[i - 2]</code></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211207133429.png" alt="image-20211207133422850"></p><ol start="2"><li>**当数字中的最后两个数字无法直接被翻译为一个数时，此时我们别无选择，只有将最后一个数直接翻译成一个字母，此时存在等式 **<code>dp[i] = dp[i - 1]</code></li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211207133456.png" alt="image-20211207133456609"></p><blockquote><p><strong>故我们可以得到以下的状态转移方程</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (最后两个数可以翻译为一个字母) &#123;</span><br><span class="line">    dp[i] &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    dp[i] &#x3D; dp[i - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>数组初始化，对于第一个数字，我们只有将它直接转换为一个字母，此时 dp[0] = 1</strong></li></ul><h3 id="3、解题代码-26"><a href="#3、解题代码-26" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    public int translateNum(int num) &#123;</span><br><span class="line">        &#x2F;&#x2F;1 先将 num 转换为字符串</span><br><span class="line">        String str &#x3D; String.valueOf(num);</span><br><span class="line">        &#x2F;&#x2F; 创建一个 dp 数组，长度为 str.length()</span><br><span class="line">        int[] dp &#x3D; new int[str.length()];</span><br><span class="line">        &#x2F;&#x2F; 初始化 dp 数组</span><br><span class="line">        dp[0] &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 从 1 开始</span><br><span class="line">        for (int i &#x3D; 1;i &lt; str.length();i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果前一个数等于 1 ，或者前一个数等于 2 且当前数小于等于 5 </span><br><span class="line">            if (str.charAt(i - 1) &#x3D;&#x3D; &#39;1&#39; || (str.charAt(i - 1) &#x3D;&#x3D; &#39;2&#39; &amp;&amp; str.charAt(i) &lt;&#x3D; &#39;5&#39;)) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果 i &#x3D;&#x3D; 1，那么直接初始化为 2 </span><br><span class="line">                    dp[i] &#x3D; 2;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i] &#x3D; dp[i - 2] + dp[i - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] &#x3D; dp[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[str.length() - 1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-29、删除并获得点数"><a href="#2-29、删除并获得点数" class="headerlink" title="2.29、删除并获得点数"></a>2.29、删除并获得点数</h2><h3 id="1、题目描述-27"><a href="#1、题目描述-27" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 所有 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p><p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,2]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">删除 4 获得 4 个点数，因此 3 也被删除。之后，删除 2 获得 2 个点数。总共获得 6 个点数。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,3,3,3,4]</span><br><span class="line">输出：9</span><br><span class="line">解释：</span><br><span class="line">删除 3 获得 3 个点数，接着要删除两个 2 和 4 。之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。总共获得 9 个点数。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-27"><a href="#2、解题思路-27" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>这道题与打家劫舍的思路差不多，如果我们在原来数组的基础上构造一个新数组，这个数组以 元素的值为下标，<code>nums[i]</code> 表示 i 出现的次数，以示例二的数组为例，构造出来的新数组为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums &#x3D; &#123;2,2,3,3,3,4&#125;</span><br><span class="line">temp &#x3D; &#123;0,0,2,3,1&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代表原来的数组中有 0 个 0 ，0 个 1 ，2 个 2 ，3 个 3 ，一个 4</p><p>这样就变成了打家劫舍问题。</p></blockquote><ul><li>dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i]</code> 表示面对值为 i 的数时，能获得的最大点数为 dp[i]</p></blockquote><ul><li>状态转移方程</li></ul><blockquote><p>和打家劫舍一样，我们在选择值为 i 的数时，不需要考虑 i + 1 的数，只需要考虑 i - 1 的情况，此时 <code>dp[i]</code> 有两个选择</p></blockquote><ol><li>第一个选择就是选择获取 <code>i - 1</code> 的点数，此时 <code>i</code> 的点数已经不能选择（因为 i 的值），所以此时有式子为 <code>dp[i] = dp[i - 1]</code></li><li>第二个选择就是选择获取 <code>i - 2</code> 的点数，此时可以选择 <code>i</code> 的点数，此时存在式子 <code>dp[i] = dp[i - 2] + i * temp[i]</code></li></ol><blockquote><p>所以状态转移方程如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; Math.max(dp[i - 1], dp[i - 2] + i * temp[i]);</span><br></pre></td></tr></table></figure><ul><li>数组初始化</li></ul><blockquote><p>和打家劫舍的 dp 数组初始化一样，但注意这里需要对构造出来的新数组进行初始化</p></blockquote><h3 id="3、解题代码-27"><a href="#3、解题代码-27" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1 先找出数组中的最大数，用于构造新数组</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须是最大值 + 1 长度</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        temp[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来，就按照打家劫舍的方法做</span></span><br><span class="line">    <span class="keyword">if</span> (temp.length == <span class="number">1</span>) <span class="keyword">return</span> temp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (temp.length == <span class="number">2</span>) <span class="keyword">return</span> Math.max(temp[<span class="number">0</span>], temp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> one = temp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> two = Math.max(temp[<span class="number">0</span>], temp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; temp.length;i++) &#123;</span><br><span class="line">        cur = Math.max(two, one + i * temp[i]);</span><br><span class="line">        one = two;</span><br><span class="line">        two = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-30、接雨水"><a href="#2-30、接雨水" class="headerlink" title="2.30、接雨水"></a>2.30、接雨水</h2><h3 id="1、题目描述-28"><a href="#1、题目描述-28" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><h3 id="2、解题思路-28"><a href="#2、解题思路-28" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>dp 数组的含义，其中 dp[i] 表示在下标为 i 的柱子上可以装的水</li></ul><blockquote><p>我们设第 i 根柱子左边最高的柱子高度为 maxLeft， 同时记第 i 根柱子右边最高的柱子高度为 maxRight ，则第 i 根柱子上能承载的水量为</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(<span class="number">0</span>, Math.min(maxLeft, maxRight) - height[i])</span><br></pre></td></tr></table></figure><blockquote><p>如果我们每次都需要向左右两边遍历找寻最大值，那么时间复杂度就会非常高。</p><p>创建两个长度为 n 的数组 leftMax 和 rightMax ， 对于 0 &lt;= i &lt; n ，leftMax[i] 表示下标 i 及其左边的位置中，height 的最大高度；而 rightMax[i] 表示下标 i 及其右边的位置中，height 的最大高度。</p></blockquote><ol><li><p><code>leftMax[0] = height[0] ， rightMax[n - 1] = height[n - 1]</code></p></li><li><p>当 1 &lt;= i &lt;= n - 1 时，<code>leftMax[i] = Math.max(leftMax[i - 1], height[i])</code></p></li><li><p>当 0 &lt;= i &lt;= n - 2 时，<code>rightMax[i] = Math.max(rightMax[i - 1], height[i])</code></p></li></ol><blockquote><p>因此可以正向遍历数组 height 得到数组 leftMax 的每个元素值，反向遍历数组 height 得到数组 rightMax 的每个元素值。</p><p><strong>这道题中，我们不需要使用到 dp 数组，只需要使用一个变量进行保存同时累加即可</strong>。</p></blockquote><ul><li>状态转移方程</li></ul><blockquote><p>我们设在第 i 根柱子上能存的水为 count ，则</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = Math.max(<span class="number">0</span>, Math.min(leftMax[i], rightMax[i]) - height[i])</span><br></pre></td></tr></table></figure><h3 id="3、解题代码-28"><a href="#3、解题代码-28" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 正向遍历，获取每根柱子左边的最大高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; height.length;i++) &#123;</span><br><span class="line">        leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="comment">// 反向遍历，获取每根柱子右边的最大高度</span></span><br><span class="line">    rightMax[height.length - <span class="number">1</span>] = height[height.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用一个变量来计算总水量</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第一根和最后一根柱子没有结果，直接跳过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; height.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = Math.max(<span class="number">0</span>, Math.min(leftMax[i], rightMax[i]) - height[i]);</span><br><span class="line">        sum += count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-31、丑数-II"><a href="#2-31、丑数-II" class="headerlink" title="2.31、丑数 II"></a>2.31、丑数 II</h2><h3 id="1、题目描述-29"><a href="#1、题目描述-29" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。<strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。（1 也可以看为一个丑数）</p></blockquote><ul><li>示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br></pre></td></tr></table></figure><ul><li>丑数计算思路</li></ul><blockquote><p>由于 1 也是丑数，那么我们可以将 1 作为基础乘以 2,3,5 ，得到的结果也是丑数，再将这些得到的结果分别乘以 2,3,5 ，得到的结果也都是丑数，然后按照从小到大取到第 n 个结果，就是第 n 个丑数</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211211214935.png" alt="image-20211211214928486"></p><h3 id="2、解题思路-29"><a href="#2、解题思路-29" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用最小堆</li></ul><blockquote><p>在这个解决思路中，我们需要创建一个小顶堆和一个集合，其中集合用于取出重复的丑数，比如说上图中生成的丑数存在相同的情况，我们需要进行去重。</p></blockquote><ol><li>初始化时，最小堆中只存在丑数 1</li><li>循环遍历，将 1 从最小堆中取出，然后将 1 乘以三个质因子，然后将结果放入最小堆中（需要先到集合中看一下有没有这个元素，如果有那么就不加入到最小堆中）</li></ol><blockquote><p>不断从堆中取出元素，然后乘以质因子，再将没出现过的结果放入到最小堆中，循环 n 次，拿到的就是第 n 个丑数。</p></blockquote><ul><li>动态规划</li></ul><ol><li>dp 数组的含义</li></ol><blockquote><p>其中 <code>dp[i]</code> 表示第 i 个丑数的值，则第 n 个丑数即为 <code>dp[n]</code></p></blockquote><ol start="2"><li>状态转移方程</li></ol><blockquote><p>定义三个指针 p2,p3,p5 ，表示下一个丑数是当前指针指向的丑数乘以对应的质因子。初始化时，三个指针的值均为 1 ，当 <code>2 &lt;= i &lt;= n</code> 时，有</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.min(Math.min(dp[p2] * <span class="number">2</span>, dp[p3] * <span class="number">3</span>),dp[p5] * <span class="number">5</span>);</span><br></pre></td></tr></table></figure><blockquote><p>然后我们需要比较 dp[i] 与 dp[p2] * 2 ，dp[p3] * 3 ，dp[p5] * 5 是否相等，如果相等则将对应的指针 + 1</p><p>从上面的图中，当求第二个丑数时，结果从 {2,3,5} 中 诞生，我们得到第二个丑数为 2 ，求第三个丑数时，我们在{3,5,4} 中求结果，可以看到 {3,5} 是上次求丑数留下来的结果，而 4 正是 2 * 2 ，即 1 后移（ + 1）后 * 2 的结果</p></blockquote><ol start="3"><li>dp 数组初始化</li></ol><blockquote><p><code>dp[1]</code> 表示第一个丑数，初始化为 1</p></blockquote><h3 id="3、解题代码-29"><a href="#3、解题代码-29" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><ul><li>最小堆</li></ul><blockquote><p>这里为了防止溢出，使用的是 Long 型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建一个最小堆，用于存放丑数</span></span><br><span class="line">    PriorityQueue&lt;Long&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// 创建一个数组，用于存放质因子。</span></span><br><span class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Set&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化，我们需要将 1 放入最小堆中</span></span><br><span class="line">    minHeap.add(<span class="number">1L</span>);</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        result = minHeap.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">long</span> uglyNum = num * result;</span><br><span class="line">            <span class="comment">// 只有集合中不存在时，才将结果加入到最小堆中</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(uglyNum)) &#123;</span><br><span class="line">                minHeap.add(uglyNum);</span><br><span class="line">                set.add(uglyNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        dp[i] = Math.min(Math.min(dp[p2] * <span class="number">2</span>, dp[p3] * <span class="number">3</span>), dp[p5] * <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == dp[p2] * <span class="number">2</span>) &#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == dp[p3] * <span class="number">3</span>) &#123;</span><br><span class="line">            p3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == dp[p5] * <span class="number">5</span>) &#123;</span><br><span class="line">            p5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-32、跳跃游戏-I"><a href="#2-32、跳跃游戏-I" class="headerlink" title="2.32、跳跃游戏 I"></a>2.32、跳跃游戏 I</h2><h3 id="1、题目描述-30"><a href="#1、题目描述-30" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p></blockquote><h3 id="2、解题思路-30"><a href="#2、解题思路-30" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i]</code> 表示能否到达下标为 i 的位置，所以 dp 应该是一个 boolean 类型的数组</p></blockquote><ul><li>状态转移方程</li></ul><blockquote><p>遍历 <code>[0, i - 1]</code> ，我们需要找到一个位置 j ，如果小人能到达 j 位置且满足条件 <code>j + nums[j] &gt;= i</code>，那么证明 i 是可以到达的，此时我们可以使 dp[i] = true ，然后我们需要跳出循环</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(dp[j] &amp;&amp; j + nums[j] &gt; i) &#123;</span><br><span class="line">	dp[i] &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dp 数组的初始化</li></ul><blockquote><p>我们需要初始化 dp[0] = true，因为小人从 0 位置开始，同时需要返回 dp[nums.length - 1]</p></blockquote><h3 id="3、解题代码-30"><a href="#3、解题代码-30" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; nums[j] + j &gt;= i) &#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-33、跳跃游戏-II"><a href="#2-33、跳跃游戏-II" class="headerlink" title="2.33、跳跃游戏 II"></a>2.33、跳跃游戏 II</h2><h3 id="1、题目描述-31"><a href="#1、题目描述-31" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p></blockquote><ul><li>示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-31"><a href="#2、解题思路-31" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i]</code> 表示到达 i 位置所用的最小步数，我们需要返回 <code>dp[nums.length - 1]</code></p></blockquote><ul><li>状态转移方程</li></ul><blockquote><p>当我们处于第 i 个位置时，我们遍历 <code>[0. i - 1]</code> 位置，然后寻找在哪个位置可以直接用一步到达 i 位置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j + nums[j] &gt;= i) &#123;</span><br><span class="line">    <span class="comment">// 如果在 j 位置可以直接到达 i 位置，那么直接在到达 j 所需要的最少步数 dp[j] 的基础上 + 1即可，但我们需要和 dp[i] 做比较，取最小值</span></span><br><span class="line">    dp[i] = Math.min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>由于在状体转移方程中，我们需要使用 min 函数来选择最小值，那么我们给数组的初始化值就不能是简单的 0 ，为了方便，我们先将数组中的所有元素全部置为 <code>Integer,MAX_VALUE</code></p></blockquote><ol><li>当 i 为 0 时，我们只需要 0 步就可以到达，所以 <code>dp[0] = 0</code></li><li>当 i 为 1 时，我们只需要一步就可以到达，所以 <code>dp[1] = 1</code></li></ol><h3 id="3、解题代码-31"><a href="#3、解题代码-31" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个大小为 len 的数组，并对它的值进行初始化</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// 初始化数组的值为 Integer.MAX_VALUE ，因为我们需要与 0 作比较取最小值，所以要初始化一个值</span></span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// 初始化 dp[0] 和 dp[1] ，当 i 等于 0 时，至少花 0 步就可以到达，当 i 等于 1 时，只需要一步就可以到达 1 </span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="comment">// 如果在 [0, i - 1] 范围内有位置可以一步到达 i ，那么我们需要进行选择，</span></span><br><span class="line">            <span class="keyword">if</span> (j + nums[j] &gt;= i) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-34、环形子数组的最大和"><a href="#2-34、环形子数组的最大和" class="headerlink" title="2.34、环形子数组的最大和"></a>2.34、环形子数组的最大和</h2><h3 id="1、题目描述-32"><a href="#1、题目描述-32" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个由整数数组 <code>A</code> 表示的**环形数组 <code>C</code>**，求 <code>C</code> 的非空子数组的最大可能和。</p><p>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，且当 i &gt;= 0 时 C[i+A.length] = C[i]）</p><p>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], …, C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length）</p></blockquote><ul><li>示例一</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,-2,3,-2]</span><br><span class="line">输出：3</span><br><span class="line">解释：从子数组 [3] 得到最大和 3</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,-3,5]</span><br><span class="line">输出：10</span><br><span class="line">解释：从子数组 [5,5] 得到最大和 5 + 5 &#x3D; 10</span><br></pre></td></tr></table></figure><ul><li>示例三</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,-1,2,-1]</span><br><span class="line">输出：4</span><br><span class="line">解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 &#x3D; 4</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-32"><a href="#2、解题思路-32" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>对于一个环形数组来说，它的最大连续子数组其实只有两种情况</li></ul><ol><li>第一种，最大连续子数组分布在数组中间，比如说下面的情况</li></ol><blockquote><p>对于这种情况，我们只需要按照求普通数组的<strong>最大连续子数组的和</strong>的思路做即可。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211213221457.png" alt="image-20211213221450727"></p><ol start="2"><li>第二种，最大连续子数组首尾相连，比如说下面的情况</li></ol><blockquote><p>这种情况下，我们要求的值 answer 满足 <code>answer = totalSum - min_so_far</code>，其中 <code>min_so_far</code> 表示图中灰色部分的和，即普通数组中最小连续子数组的和，我们可以借由最大连续子数组的和来做。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211213221549.png" alt="image-20211213221549112"></p><h3 id="3、解题代码-32"><a href="#3、解题代码-32" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> first = maxSubarray(nums);</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算 total 的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        total += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = minSubarray(nums);</span><br><span class="line">    <span class="keyword">int</span> second = total - min;</span><br><span class="line">    <span class="comment">// 如果 total 等于 min ，那么证明差为 0 ，那么此时如果 first 返回的值是负数，那么就会返回错误的 0 </span></span><br><span class="line">    <span class="keyword">if</span> (total == min) <span class="keyword">return</span> first;</span><br><span class="line">    <span class="keyword">return</span> Math.max(first, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        min = Math.min(dp[i], min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        max = Math.max(dp[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-35、乘积最大子数组"><a href="#2-35、乘积最大子数组" class="headerlink" title="2.35、乘积最大子数组"></a>2.35、乘积最大子数组</h2><h3 id="1、题目描述-33"><a href="#1、题目描述-33" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-33"><a href="#2、解题思路-33" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>与<strong>和最大子数组</strong>不一样的是，在本题中，我们需要根据当前遍历的元素来进行更新 dp 数组的值，我们设置两个变量，其中 <code>preMax</code> 为 <code>nums[0: i - 1]</code> 中最大的乘积，而 <code>preMin</code> 为 <code>nums[0: i - 1]</code> 中最小的乘积（可能为负数）</li><li>当 <code>nums[i]</code> 为正数时，此时由于正正得正，我们需要更新 <code>preMax = Math.max(preMax * nums[i], nums[i])</code>，同时更新 <code>preMin = Math.min(preMax * nums[i], nums[i])</code></li><li>当 <code>nums[i]</code> 为负数时，此时由于负负为正得正，我们需要更新 <code>preMax = Math.max(preMin * nums[i], nums[i])</code>，同时更新 <code>preMin = Math.min(preMin * nums[i], nums[i])</code></li></ul><blockquote><p>我们使用一个 max 变量来记录全局最大值，将其与 <code>preMax</code> 比较</p></blockquote><h3 id="3、解题代码-33"><a href="#3、解题代码-33" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preMax = nums[<span class="number">0</span>], preMin = nums[<span class="number">0</span>], max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>, curMin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curMax = preMax * nums[i];</span><br><span class="line">            curMin = preMin * nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curMax = preMin * nums[i];</span><br><span class="line">            curMin = preMax * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        preMax = Math.max(curMax, nums[i]);</span><br><span class="line">        preMin = Math.min(curMin, nums[i]);</span><br><span class="line">        max = Math.max(preMax, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-36、乘积为正数的最长子数组长度"><a href="#2-36、乘积为正数的最长子数组长度" class="headerlink" title="2.36、乘积为正数的最长子数组长度"></a>2.36、乘积为正数的最长子数组长度</h2><h3 id="1、题目描述-34"><a href="#1、题目描述-34" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个整数数组 <code>nums</code> ，请你求出乘积为正数的最长子数组的长度。</p><p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组，请你返回乘积为正数的最长子数组长度。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,-2,-3,4]</span><br><span class="line">输出：4</span><br><span class="line">解释：数组本身乘积就是正数，值为 24 。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,-2,-3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-34"><a href="#2、解题思路-34" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>与上一题相同，我们在遍历到某个元素时，根据这个元素的情况进行判断</li><li>确定 dp 数组的含义</li></ul><blockquote><p>我们需要创建两个数组，其中</p></blockquote><ol><li><code>pos[i]</code> 表示以 i 结尾的乘积为正数的最长子数组长度</li><li><code>neg[i]</code> 表示以 i 结尾的乘积为负数的最长子数组长度</li></ol><ul><li>状态转移方程</li></ul><ol><li>当 <code>nums[i] &gt; 0</code> 时，此时 <code>nums[i]</code> 的值不会影响之前子数组乘积的值的正负</li></ol><blockquote><p>所以，如果 <code>pos[i - 1]</code> 大于 0 ，那么此时它可以放心乘上 <code>nums[i]</code> ，如果 <code>pos[i - 1]</code> 等于 0 ，那么子数组 {nums[i]} 就是以 i 结尾的乘积为正数的最长子数组，即此时 pos[i] = 1，所以我们可以直接列出当 nums[i] 大于 0 的状态转移方程；</p><p>而如果 <code>neg[i - 1]</code> 大于 0 ，那么它也可以放心乘上 nums[i]，如果 <code>neg[i - 1]</code> 等于 0，那么 neg[i ] 依然为 0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pos[i] = pos[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    neg[i] = neg[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? neg[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当 <code>nums[i] &lt; 0</code> 时，此时 <code>nums[i]</code> 的值会影响之前子数组乘积的值的正负</li></ol><blockquote><p>如果 <code>pos[i - 1]</code> 大于 0，那么此时我们将 <code>nums[i]</code> 放入以 i - 1 结尾的子数组中，整个子数组的乘积变为了负数，所以此时有 <code>neg[i] = pos[i - 1] + 1</code>；如果 <code>pos[i - 1]</code> 等于 0 ，那么此时如果我们将 <code>nums[i]</code> 放入以 i - 1 结尾的子数组中，可能会导致整个子数组乘积变为正，所以此时我们直接记 <code>neg[i]</code> 为 1 ；</p><p>如果 <code>neg[i - 1]</code> 大于 0，那么此时将 <code>nums[i]</code> 放入以 i - 1 结尾的子数组中，整个子数组的乘积变为了正数，所以此时 pos[i] 的值应该更新为 <code>neg[i - 1] + 1</code> ，如果 <code>neg[i - 1]</code> 的值等于 0 ，那么应该将 pos[i] 置为 0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    neg[i] = pos[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    pos[i] = neg[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? neg[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以，我们可以得出状态转移方程如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pos[i] = pos[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    neg[i] = neg[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? neg[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">    pos[i] = neg[i] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    neg[i] = pos[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    pos[i] = neg[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? neg[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dp 数组的初始化</li></ul><blockquote><p>这个需要根据 <code>nums[0]</code> 的值进行判断</p></blockquote><ol><li>当 <code>nums[0]</code> 大于 0 时， pos[0] = 1，neg[0] = 0</li><li>当 <code>nums[0]</code> 等于 0 时，直接初始化为 0</li><li>当 <code>nums[0]</code> 小于 0 时，neg[0] = 1，pos[i] = 0</li></ol><h3 id="3、解题代码-34"><a href="#3、解题代码-34" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span>[] neg = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        neg[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pos[i] = pos[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            neg[i] = neg[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? neg[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            pos[i] = <span class="number">0</span>;</span><br><span class="line">            neg[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            neg[i] = pos[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            pos[i] = neg[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? neg[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, pos[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于在状态转移方程中， dp[i] 的值只与前一个状态相关，所以我们可以使用一个变量进行滚动更新</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> posMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> negMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        posMax = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        negMax = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> curPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curNeg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curPos = posMax + <span class="number">1</span>;</span><br><span class="line">            curNeg = negMax &gt; <span class="number">0</span> ? negMax + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            curPos = <span class="number">0</span>;</span><br><span class="line">            curNeg = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNeg = posMax + <span class="number">1</span>;</span><br><span class="line">            curPos = negMax &gt; <span class="number">0</span> ? negMax + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行滚动</span></span><br><span class="line">        negMax = curNeg;</span><br><span class="line">        posMax = curPos;</span><br><span class="line">        max = Math.max(max, curPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、01-背包"><a href="#三、01-背包" class="headerlink" title="三、01 背包"></a>三、01 背包</h1><h2 id="3-1、01-背包回顾"><a href="#3-1、01-背包回顾" class="headerlink" title="3.1、01 背包回顾"></a>3.1、01 背包回顾</h2><h3 id="1、题目描述-35"><a href="#1、题目描述-35" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>有 N 件物品和一个最多能负重 W 的背包，其中<strong>第 i 件物品的重量是 weight[i]，价值是 value[i]**。</strong>每件物品只能使用一次**，求解将哪些物品装入背包里，得到的物品价值总和最大？</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211208154535.png" alt="image.png"></p><h3 id="2、使用动态规划求解-01-背包问题"><a href="#2、使用动态规划求解-01-背包问题" class="headerlink" title="2、使用动态规划求解 01 背包问题"></a>2、使用动态规划求解 01 背包问题</h3><ul><li>明确选择和状态</li></ul><blockquote><p>在这个问题中，<strong>状态包含两个变量，即背包的重量及所得到的价值</strong>，而选择也非常简单，就是<strong>是否选择将某件物品放入背包中</strong>。</p></blockquote><ul><li><p>明确 dp 数组的含义，这里使用一个二维的 dp 数组来解决这个问题，其中 <code>dp[i][j]</code> 表示从下标 [0, i] 的物品中任意取，放入容量为 j 的背包中，所能获得价值的最大总和为多少</p></li><li><p>明确递推公式</p></li></ul><ol><li>对于第 i 件物品，当剩余背包容量无法容纳该物品，或者我们选择不将其放入到背包中时，此时有关系如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br></pre></td></tr></table></figure><ol start="2"><li>对于第 i 件物品，当剩余背包容量可以容纳该物品，且我们选择将其放入到背包时，此时存在关系如下，<strong>其中 weight[i] 、 value[i] 分别指 i 物品的重量与价值</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - i][j - weight[i]] + value[i];</span><br></pre></td></tr></table></figure><blockquote><p>因此我们可以得到以下的递推公式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &lt; weight[i]) &#123;</span><br><span class="line">	dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><ol><li>当 j 为 0 时，此时背包容量为 0 ，因此可获取的最大价值也为 0 ，即 <code>dp[i][0] = 0</code></li><li>当 i 为 0 时，即只有第一件物品可供选择时，如果此时背包容量 <code>j &gt;= weight[0]</code> ，那么应该初始化对应的 <code>dp[0][j]</code> 为 value[0]</li></ol><h2 id="3-2、使用一维滚动数组优化背包问题"><a href="#3-2、使用一维滚动数组优化背包问题" class="headerlink" title="3.2、使用一维滚动数组优化背包问题"></a>3.2、使用一维滚动数组优化背包问题</h2><h3 id="1、优化思路"><a href="#1、优化思路" class="headerlink" title="1、优化思路"></a>1、优化思路</h3><blockquote><p>当使用二维数组时，背包问题的递推公式为 <code>dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p></blockquote><ul><li><p>可以看到，如果我们将 <code>dp[i - 1]</code> 那一层都拷贝到 <code>dp[i]</code> 上，那么表达式完全可以是 <code>dp[i][j] = Math.max(dp[i][j], dp[i][j - weight[i]] + value[i])</code></p></li><li><p><strong>当前层的状态完全由上一层状态推导而来</strong>，对于这种情况，我们可以考虑使用滚动数组进行优化，这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p></li></ul><h3 id="2、含义介绍"><a href="#2、含义介绍" class="headerlink" title="2、含义介绍"></a>2、含义介绍</h3><ul><li>确定 dp 数组的含义</li></ul><blockquote><p>在一维 dp 数组中， <strong><code>dp[j]</code> 表示：容量为 j 的背包，所背的物品价值可以最大为 dp[j]</strong></p></blockquote><ul><li>确定递推公式</li></ul><ol><li>当我们选择不放物品 i 时，所得到的最大价值为 <code>dp[j]</code>，这里可以类比我们使用二维数组的时候，如果选择不放物品 i 时，我们得到的最大价值为 <code>dp[i - 1][j]</code> ， <strong>等于是把 dp[i][j] 的上一层数据拷贝下来</strong></li><li>当我们选择放物品 i 时，所得到的最大价值为 <code>dp[j - weight[i]] + value[i]</code></li></ol><blockquote><p>所以，我们可以得到使用一维数组时，01 背包问题的递推公式为</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &lt; weight[i]) &#123;</span><br><span class="line">	dp[j] = dp[j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dp 数组初始化</li></ul><blockquote><p>当 j 为 0 时，此时背包容量为 0 ，所以所能装的物品的最大价值也是 0 ，即 dp[0] = 0；</p><p>对于其他位置的值，我们同样将其初始化为 0 ，避免因初始化值过大导致递推公式计算出来的值无法将初始值覆盖（将整个数组都初始化为 0 ）</p></blockquote><ul><li>遍历顺序</li></ul><blockquote><p>在二维数组中，无论是先遍历物品，还是先遍历背包都是可以的，但是在一维 dp 数组中，我们需要<strong>先遍历物品，然后再遍历背包，同时需要注意的是，我们在遍历背包时，需要进行倒序遍历</strong></p></blockquote><ul><li>为什么要倒序遍历背包？</li></ul><blockquote><p><strong>这是为了保证物品只被添加一次</strong>，在使用二维数组时，当前层和上一层的数据是完全隔离开的，所以正序遍历和倒序遍历都可以，但当我们使用一维数组时， 如果先计算 dp[j - 1] ，那么它可能会影响到后面 dp [j] 的数据，我们可以来举一个例子，其中 <code>weight = &#123;1,3,4&#125;</code> ，<code>values = &#123;15,20,30&#125;</code> ，同时最大容量 capacity = 4.</p></blockquote><ol><li>当我们使用正序遍历时， <code>dp[1] = Math.max(dp[1], dp[1 - weight[0]] + values[0]) = Math.max(dp[1], dp[1 - 1] + 15) = 15</code>; <code>dp[2] = Math.max(dp[2], dp[2 - weight[0]] + values[0]) = Math.max(dp[2], dp[2 - 1] + 15) = 30</code></li></ol><blockquote><p>可以看到，如果我们使用正序遍历，那么在计算 dp[2] 时，递推公式中的 dp[2 - 1] = dp[1] 是我们在上一次计算出来的 15 ，而且得到的结果也是 30 ，这相当于我们将第 0 件物品重复加入到了背包中。</p></blockquote><ol start="2"><li>当我们使用倒序遍历时， <code>dp[2] = max(dp[2], dp[2 - weight[0]] + values[0]) = max (0, dp[1] + 15) = 15</code>；<code>dp[1] = max(dp[1], dp[1 - weight[0]] + values[0]) = max(0, dp[0] + 15) = 15</code></li></ol><blockquote><p>此时可以看到，第 0 件物品只被加入到了一次，这是因为此时在计算 dp[j] 时， dp[j - 1] 的结果还没有被计算出来，所以不会影响 dp[j] 的计算。</p></blockquote><h3 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> capacity, <span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (weight == <span class="keyword">null</span> || values == <span class="keyword">null</span> || weight.length != values.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个一维的 dp 数组，dp[j] 表示，当背包容量为 j 时，该背包能容纳物品的最大价值</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 外层循环，先遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; number;i++) &#123;</span><br><span class="line">        <span class="comment">// 内层循环，需要倒序遍历背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = capacity;j &gt;= weight[i];j--) &#123;</span><br><span class="line">            <span class="comment">// 使用递推公式，从右至左计算 dp[j] 的值</span></span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后返回 dp[capacity] ，就是 capacity 容量的背包所能容纳的物品的最大价值</span></span><br><span class="line">    <span class="keyword">return</span> dp[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3、目标和"><a href="#3-3、目标和" class="headerlink" title="3.3、目标和"></a>3.3、目标和</h2><h3 id="1、题目描述-36"><a href="#1、题目描述-36" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p></blockquote><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><blockquote><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一共有 <span class="number">5</span> 种方法让最终目标和为 <span class="number">3</span> 。</span><br><span class="line">-<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-35"><a href="#2、解题思路-35" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用动态规划来解决这道题，这道题也可以转换为 01 背包问题，与 01 背包问题不同的是，前者可以选择是否将这件物品装入背包中，而本题要求全部数字都被选中，但可以选择 <code>+</code> 和 <code>-</code></li><li>将这个数组分割为两部分，其中被赋予 <code>+</code> 的那一部分称为 <code>P</code> ，而被赋予 <code>-</code> 的那一部分称为 <code>N</code> ，所以我们可以得到以下结论</li></ul><ol><li>sum(P) - sum(N) = S</li><li>sum(P) + sum(N) = 数组中所有元素的和 sum</li><li>将上面的式子相加，有 <code>2 * sum(P) = target + sum</code>，移项有 <code>sum(P) = (target + sum) / 2</code>，我们记这个值为 result，即 <code>result = (target + sum) / 2</code></li></ol><blockquote><p><strong>所以问题就转换为求容量为 result 的 01 背包问题，要装满容量为 result 的背包，有几种方案</strong></p></blockquote><ul><li>如果 target 的值大于 sum ，那么直接返回 0 ，因为此时无法找到一种可能的实现</li><li>如果 sum(P) 不是正数，即 <code>(target + sum)</code> 不是偶数，那么返回 0</li><li>确定 dp 数组的含义</li></ul><blockquote><p><strong>dp[j] 表示在数据 nums 中，凑出 j 的方法有 dp[j] 种</strong>，换成背包问题就是，如果要填充 j 这么大容积的包，有 <code>dp[j]</code> 种方法</p></blockquote><ul><li>确定递推公式</li></ul><ol><li>填满容量为 <code>j - nums[i]</code> 的背包，有 <code>dp[j - nums[i]]</code> 种方法</li><li>那么只需要获得 <code>nums[i]</code> ，我们就可以凑出 <code>dp[j]</code> ，此时得到 <code>dp[j]</code> 的方法有 <code>dp[j - nums[i]]</code> ，这里有点类似凑硬币</li></ol><blockquote><p>比如说，如果我们当前需要计算 dp[5] ，同时我们手中有一个重量为 2 的物品，此时我们只需要计算出 dp[3] 就可以得到在我们有 重量为 2 的物品的前提下，能填满容量为 5 的背包的方法，所以我们可以得到以下的递推公式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>这道题中，由于我们要求 dp[result] ，所以我们需要初始化一个长度为 result + 1 的数组，同时，当 j == 0 时，使用 nums 数组中的元素可以有一种方法凑出 0 ，故 dp[0] = 1;</p></blockquote><h3 id="3、解题代码-35"><a href="#3、解题代码-35" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><blockquote><p>这里使用一维滚动数组来解这道题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1 计算数组元素和</span></span><br><span class="line">    <span class="keyword">int</span> sum = gengerateSumByArray(nums);</span><br><span class="line">    <span class="comment">//2 如果 sum 小于 target 或者 （sum + target） 不是偶数，那么直接返回 0 </span></span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target || (sum + target) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//3 使用一个变量保存 (sum + target) / 2;</span></span><br><span class="line">    target = (sum + target) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//这里需要进行判断，如果计算出来的 target 小于 0 ，那么需要将其变为相反数</span></span><br><span class="line">    target = Math.abs(target);</span><br><span class="line">    <span class="comment">//4 创建一个长度为 target + 1 的数组，并进行初始化</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 当 j == 0 时，此时在 nums 中，只能找出一种方案凑出 0 ，所以 dp[0] = 1</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//5 外层循环遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">//6 内层循环倒序遍历背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target;j &gt;= num;j--) &#123;</span><br><span class="line">            <span class="comment">// 使用递推公式累加 dp[j] 的值</span></span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gengerateSumByArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4、使用一维滚动数组优化分割等和子集问题"><a href="#3-4、使用一维滚动数组优化分割等和子集问题" class="headerlink" title="3.4、使用一维滚动数组优化分割等和子集问题"></a>3.4、使用一维滚动数组优化分割等和子集问题</h2><h3 id="1、优化思路-1"><a href="#1、优化思路-1" class="headerlink" title="1、优化思路"></a>1、优化思路</h3><ul><li>使用一维滚动数组代替原来的二维数组</li><li>dp 数组的含义</li></ul><blockquote><p>dp 是一个一维的 boolean 数组，其中 dp[j] 表示在数组中，是否可以找到一个子集，使得这些子集的和等于 j</p></blockquote><ul><li>递推公式</li></ul><blockquote><p>当我们知道数组元素 nums[i] 时，此时如果 dp[j] 或 dp[j - nums[i]] 有一个为 true ，那么就代表 dp[j] 为 true ，即</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = dp[j] || dp[j - nums[i]]</span><br></pre></td></tr></table></figure><h3 id="2、解题代码"><a href="#2、解题代码" class="headerlink" title="2、解题代码"></a>2、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这道题可以看为，在 nums 中，是否可以找到几个数，这几个数的和为 sum / 2 ，其中 sum 为数组元素和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//1 计算数组元素和</span></span><br><span class="line">    <span class="keyword">int</span> sum = gengerateSumByArray(nums);</span><br><span class="line">    <span class="comment">// 如果数组元素和不是一个偶数，那么直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//2 我们需要在数组 nums 中，找到是否存在几个数字，满足这几个数字的和为 target</span></span><br><span class="line">    <span class="comment">// dp[j] 表示在数组 nums 中，是否存在几个数字，满足这几个数字的和为 j</span></span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，当 j == 0 时，此时可以找到几个数字，满足这几个数字的和为 0 </span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target;j &gt;= num;j--) &#123;</span><br><span class="line">            <span class="comment">// 如果 dp[j] 或 dp[j - num] 有一个为真，那么 dp[j] 即为真，此时代表存在...</span></span><br><span class="line">            dp[j] = dp[j] || dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gengerateSumByArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5、最后一块石头的重量-II"><a href="#3-5、最后一块石头的重量-II" class="headerlink" title="3.5、最后一块石头的重量 II"></a>3.5、最后一块石头的重量 II</h2><h3 id="1、解题思路"><a href="#1、解题思路" class="headerlink" title="1、解题思路"></a>1、解题思路</h3><ul><li><p>在上面有提到，这道题其实就是尽量将石头分成重量相同的两堆，然后让相撞之后剩下的石头最小。</p></li><li><p>这道题其实就是求，给你一个大小为 sum / 2 的背包，其中 sum 为 nums 的元素和，然后尽可能地往背包中装东西，我们假设最多往背包中装了 maxWeight 重量的石头，那么我们要求的结果就是 sum - 2 * maxWeight;</p></li><li><p>确定 dp 数组</p></li></ul><blockquote><p>使用一个一维的 boolean 类型的 dp 数组，<strong>其中 dp[j] 的含义、状态转移方程与 分割等和子集 问题中 dp 数组的含义相同</strong>，即<strong>在数组 nums 中，能否找到一个子集，使得这个子集的元素和的值等于 j</strong> 。</p></blockquote><ul><li>当计算好 dp 数组后，我们需要反向遍历 dp 数组，寻找第一个为 true 的元素值，然后得到结果并返回，结果为 <code>sum - 2 * j</code></li></ul><h3 id="2、解题代码-1"><a href="#2、解题代码-1" class="headerlink" title="2、解题代码"></a>2、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stones == <span class="keyword">null</span> || stones.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = generateSumByArray(stones);</span><br><span class="line">    <span class="comment">// 计算出 target 的值，我们要尽可能装满这个容量为 target 的包</span></span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 外层循环遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">        <span class="comment">// 内层循环反向遍历背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target;j &gt;= stone;j--) &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j - stone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填完表后，我们需要找到最接近 target 的一个 j 值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = target;;j--) &#123;</span><br><span class="line">        <span class="comment">// 找到第一个为 true 的j</span></span><br><span class="line">        <span class="keyword">if</span> (dp[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum - <span class="number">2</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">generateSumByArray</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) sum += stone;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6、一和零"><a href="#3-6、一和零" class="headerlink" title="3.6、一和零"></a>3.6、一和零</h2><h3 id="1、题目描述-37"><a href="#1、题目描述-37" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p></blockquote><ul><li><strong>示例 1：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;10&quot;</span>, <span class="string">&quot;0001&quot;</span>, <span class="string">&quot;111001&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>], m = <span class="number">5</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最多有 <span class="number">5</span> 个 <span class="number">0</span> 和 <span class="number">3</span> 个 <span class="number">1</span> 的最大子集是 &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>&#125; ，因此答案是 <span class="number">4</span> 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;1&quot;</span>&#125; 和 &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>&#125; 。&#123;<span class="string">&quot;111001&quot;</span>&#125; 不满足题意，因为它含 <span class="number">4</span> 个 <span class="number">1</span> ，大于 n 的值 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><ul><li><strong>示例 2：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;10&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>], m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最大的子集是 &#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>&#125; ，所以答案是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-36"><a href="#2、解题思路-36" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>这道题也可以看为 01 背包问题，其中字符串数组中的每一个字符串都是一件物品，而 m 和 n 相当于一个二维的背包</p></blockquote><ul><li>确定 dp 数组的含义，这里使用滚动数组进行优化，其中 <code>dp[i][j]</code> 表示最多有 i 个 0 和 j 个 1 的 strs 的最大子集的大小为 <code>dp[i][j]</code></li><li>对于 <code>dp[i][j]</code> 而言，它可以由前一个 strs 里的字符串推导出来，假设该字符串中含有 zeroNum 个 0 ，同时含有 oneNum 个 1 ，那么有以下的递推公式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>如何初始化 dp 数组？</li></ul><blockquote><p>只需要将 dp 初始化为 0 即可</p></blockquote><h3 id="3、解题代码-36"><a href="#3、解题代码-36" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个二维数组，其中 dp[i][j] 表示子集最多能有 i 个 0 ，j 个 1 时，最大子集的长度</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 外层循环遍历物品，在这道题中，一个字符串就是一件物品</span></span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="comment">// 获取这个字符串中 1 的个数和 0 的个数</span></span><br><span class="line">        <span class="keyword">int</span> zeroNum = countCharNum(str, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> oneNum = countCharNum(str, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="comment">// 内层循环遍历背包，这里有两个背包需要进行遍历，分别为容量为 m 的背包和 容量为 n 的背包，倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &gt;= zeroNum;i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n;j &gt;= oneNum;j--) &#123;</span><br><span class="line">                <span class="comment">// 使用递推公式计算 dp[i][j] 的值</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countCharNum</span><span class="params">(String str, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == ch) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、完全背包问题"><a href="#四、完全背包问题" class="headerlink" title="四、完全背包问题"></a>四、完全背包问题</h1><h2 id="4-1、完全背包问题理论说明"><a href="#4-1、完全背包问题理论说明" class="headerlink" title="4.1、完全背包问题理论说明"></a>4.1、完全背包问题理论说明</h2><h3 id="1、题目描述-38"><a href="#1、题目描述-38" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>设有 n 种物品，每种物品都有一个重量及一个价值，其中第 i 件物品的重量为 <code>weight[i]</code>，价值为 <code>value[i]</code>。且<strong>每种物品的数量是无限的</strong>，同时有一个背包，最大载重量为 M ，<strong>今从 n 种物品种选取若干个物品（同一种物品可以被多次选取）放入背包中，使其重量的和小于等于 M ，而价值的和为最大</strong>。</p></blockquote><ul><li>与 01 背包不同的是，前者每件物品只有一个，而完全背包问题中每种物品可以有无限多个。</li></ul><h3 id="2、解题思路-37"><a href="#2、解题思路-37" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>在完全背包问题中，对于第 i 件物品，我们有几种选择</li></ul><ol><li>选择将 0 个物品装入到背包中</li><li>选择将 n 个该物品装入到背包中，我们可以不断往背包中添加该物品，直到背包被装满，也就是说，在完全背包问题中，同一件物品被装入背包的次数是有上下限的，下限为 0 ，上限为 M / n （向下取整）</li></ol><blockquote><p>当当前背包容量为 j 时，对于第 i 件物品装入背包的次数范围为 <code>[0, j / w[i]]</code> ，其中 <code>j / w[i]</code> 需要向下取整</p></blockquote><ul><li>在之前使用一维滚动数组优化 01 背包问题时，我们有谈及到为什么内层循环需要进行反向遍历 – 为了避免一个物品被重复添加到背包中多次；而完全背包问题里的物品完全可以多次添加到背包中，所以对于完全背包问题的内层循环，我们可以正序遍历背包。</li></ul><h3 id="3、解题代码-37"><a href="#3、解题代码-37" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求解完全背包问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number 物品个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 背包容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> weight 物品重量数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 物品价值数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 能获取到的最大收益</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">completeBackpack</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> capacity, <span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (weight == <span class="keyword">null</span> || value == <span class="keyword">null</span> || weight.length != value.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个一维数组 dp</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 外层数组遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; number;i++) &#123;</span><br><span class="line">        <span class="comment">// 内层物品遍历背包，这里需要从左往右遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = weight[i];j &lt;= capacity;j++) &#123;</span><br><span class="line">            <span class="comment">// 使用递推公式</span></span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2、零钱兑换"><a href="#4-2、零钱兑换" class="headerlink" title="4.2、零钱兑换"></a>4.2、零钱兑换</h2><h3 id="1、题目描述-39"><a href="#1、题目描述-39" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> ，<strong>你可以认为每种硬币的数量是无限的</strong></p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-38"><a href="#2、解题思路-38" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>这个问题可以看为一个完全背包问题，在这道题中，我们需要求解<strong>最值问题</strong></li><li>确定 dp 数组含义</li></ul><blockquote><p>其中 <code>dp[j]</code> 表示，要想在 coins 中凑出金额为 j 的零钱，最少需要 <code>dp[j]</code> 个硬币</p></blockquote><ul><li>状态转移方程</li></ul><blockquote><p>如果我们手一个 <code>coins[i]</code> ，那么我们只需要计算出凑出 <code>j - coins[i]</code> 的最少硬币数，然后 + 1，即可得到凑出 j 的最少硬币数，所以，我们得到的状态转移方程如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);<span class="comment">// 注意，这里需要当子问题有解时才进行状态转移，即 dp[j - coins[i]] 不为 Integer.MAX_VALUE 时</span></span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><ol><li>当 j 为 0 时，此时只需要 0 个硬币就可以凑出，所以 dp[0] = 0;</li><li>当 j 不为 0 时，我们需要将其初始化为一个非常大的数，避免后面在求出一个大于 0 的数时，在经由 <code>Math.min (0, dp[j])</code> 进行选择时，让 0 覆盖了结果值，比如说，我现在求出了 dp[1] 为 1 ，但是我的 dp[1] 在初始化时初始化为 0 了，所以导致我在进行取最小值时，无法将 dp[1] = 1 这个值正确地更新到数组中。</li></ol><ul><li>什么样的子问题才需要进行求解？</li></ul><blockquote><p>在我们进行遍历时，只有当子问题有解时，我们才考虑进行递推，所以，如果 <code>dp[j - coin]</code> 的值为 <code>Integer.MAX_VALUE</code> ，那么我们没必要进行状态转移，因为此时代表这个问题无解</p></blockquote><h3 id="3、解题代码-38"><a href="#3、解题代码-38" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组，长度为 amount + 1 ，其中 dp[amount] 就是在 coins 数组中，凑出 amount 所需的最少硬币数，也就是我们要求的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，dp[0] = 1，这一步可以省略，我们需要将 dp 数组中非 0 位置的元素 初始化为 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; dp.length;i++) &#123;</span><br><span class="line">        dp[i] = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外层遍历，遍历物品，也即硬币</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="comment">// 内层遍历，正向遍历背包，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = coin;j &lt;= amount;j++) &#123;</span><br><span class="line">            <span class="comment">//  dp[j - coin] 不为 Integer.MAX_VALUE 时，证明此时 j - coin 可以被凑出，即这个问题有解，此时才需要进行求解。</span></span><br><span class="line">            <span class="keyword">if</span> (dp[j - coin] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="comment">// 使用状态转移方程求解 dp[j] 的值，这里求得是最小值</span></span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3、零钱兑换-II"><a href="#4-3、零钱兑换-II" class="headerlink" title="4.3、零钱兑换 II"></a>4.3、零钱兑换 II</h2><h3 id="1、题目描述-40"><a href="#1、题目描述-40" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> ，<strong>假设每一种面额的硬币有无限个</strong>。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = <span class="number">5</span>, coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = <span class="number">3</span>, coins = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：只用面额 <span class="number">2</span> 的硬币不能凑成总金额 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-39"><a href="#2、解题思路-39" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>使用<strong>动态规划</strong>解决这道题，在本题中，由于每一种面额的硬币有无限个，我们将给定的 coins 数组看为物品数组，coins 数组中每个硬币的数额看为物品的重量，<strong>我们要做的就是寻找出凑齐 amount 重量的背包的方案数</strong>，这是一个完全背包问题。</p></blockquote><ul><li>确定 dp 数组的含义</li></ul><blockquote><p><strong>dp[j] 指的是，在 coins 数组中，有 dp[j] 种凑出 amount 数值的方案</strong>。</p></blockquote><ul><li>状态转移方程</li></ul><blockquote><p>这是典型的组合问题，当我们手上有一颗数值为 <code>coins[i]</code> 的硬币时，此时我们只需要知道在 coins 中凑出 <code>amount - nums[i]</code> 的方案数，就可以得到该条件下的方案数，所以状态转移方程应该如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组，当 j 为 0 时，此时有一种方案可以凑出 0 ，所以</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="3、解题代码-39"><a href="#3、解题代码-39" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组，其中 dp[j] 表示在 coins 中，能凑出数额为 j 的方案数</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，当 j 为 0 时， dp[j] == 1</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 外层遍历，遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; coins.length;i++) &#123;</span><br><span class="line">        <span class="comment">// 内层遍历，对于完全背包问题，我们需要正向遍历背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i];j &lt;= amount;j++) &#123;</span><br><span class="line">            <span class="comment">// 使用递推公式计算出 dp[j]</span></span><br><span class="line">            dp[j] += dp[j - coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4、组合总和-IV"><a href="#4-4、组合总和-IV" class="headerlink" title="4.4、组合总和 IV"></a>4.4、组合总和 IV</h2><h3 id="1、题目描述-41"><a href="#1、题目描述-41" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p><strong>请注意，顺序不同的序列被视作不同的组合</strong>。</p></blockquote><ul><li><strong>示例 1：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">4</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><ul><li><strong>示例 2：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-40"><a href="#2、解题思路-40" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>这道题是典型的完全背包问题，同时求的是<strong>排列数</strong>，所以外层循环需要遍历背包，内层循环需要遍历物品</li><li>确定 dp 数组的含义</li></ul><blockquote><p><code>dp[i]</code> 表示<strong>凑成正整数为 i 的排列个数为 <code>dp[i]</code></strong></p></blockquote><ul><li>确定递推公式</li></ul><blockquote><p><strong><code>dp[i]</code> 可以由 <code>dp[i - nums[j]]</code> 推导出来</strong>，其中 <code>dp[i]</code> 考虑了 <code>nums[j]</code> ，而 <code>dp[i - nums[j]]</code> 不考虑 <code>nums[j]</code> ，因为只要得到 <code>nums[j]</code>，排列个数 <code>dp[i - nums[j]]</code>，就是 dp[i]的一部分</p><p>我们可以确定递推公式如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] += dp[i - nums[j]];</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>由于递推公式为 <code>dp[i] += dp[i - nums[j]]</code> 的缘故，所以 dp[0] 要初始化为 1 ，这样递归其他 dp[i] 时才会有数值基础。</p><p>这里需要注意， dp[0] 是没有意义的。</p></blockquote><h3 id="3、解题代码-40"><a href="#3、解题代码-40" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 创建一个 dp 数组，其中 dp[i] 表示能在 nums 中能组成 i 的排列数</span></span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 初始化 dp[0] = 1 ，这个 dp[0] 是没有含义的</span></span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 外层循环遍历背包</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= target;i++) &#123;</span><br><span class="line">           <span class="comment">// 内层循环遍历物品</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">               <span class="comment">// 只有当背包容量大于第 j 件物品时，才需要进行分割子问题</span></span><br><span class="line">               <span class="keyword">if</span> (i &gt;= nums[j]) &#123;</span><br><span class="line">                   dp[i] += dp[i - nums[j]];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[target];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="4-5、爬楼梯"><a href="#4-5、爬楼梯" class="headerlink" title="4.5、爬楼梯"></a>4.5、爬楼梯</h2><h3 id="1、题目描述-42"><a href="#1、题目描述-42" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-41"><a href="#2、解题思路-41" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li><strong>使用完全背包的思路解决这道题，这道题又是一道排列数的问题</strong></li><li>此时，背包中只有两件物品，即 1 和 2 ，我们需要找出装满容量为 n 的背包的方案数</li><li>确定 dp 数组的含义</li></ul><blockquote><p>其中 <code>dp[i]</code> 表示爬上 n 阶楼梯有 <code>dp[i]</code> 种不同的<strong>排列</strong>方案。</p></blockquote><ul><li>确定递推公式</li></ul><blockquote><p>由于此时球的是排列方法，所以我们可以得到本体的递推公式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] += dp[i - nums[j]];</span><br></pre></td></tr></table></figure><ul><li>初始化 dp 数组</li></ul><blockquote><p>与上题相同，由于此时递推公式是 <code>dp[i] += dp[i - nums[j]]</code> ，所以我们需要初始 dp[0] = 1 ，这是递推的基础值</p></blockquote><ul><li>本题中的物品</li></ul><blockquote><p>在本题中，只有两个物品，其中第一个物品的重量为 1 ，第二个物品的重量为 2。</p></blockquote><h3 id="3、解题代码-41"><a href="#3、解题代码-41" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 初始化一个 dp 数组，长度为 n + 1，其中 dp[i] 表示爬上 i 阶楼梯的方案排列数</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 外层循环，在求排列的过程中需要遍历背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="comment">// 内层循环，需要遍历物品，这里只有两件物品，其中第一件物品的重量为 1 ，第二件物品的重量为 2 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">2</span>;j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前背包的容量大于物品重量，这里为 j </span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                dp[i] += dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6、完全平方数"><a href="#4-6、完全平方数" class="headerlink" title="4.6、完全平方数"></a>4.6、完全平方数</h2><h3 id="1、题目描述-43"><a href="#1、题目描述-43" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定正整数 <em>n</em> ，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em> 。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">12</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">13</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-42"><a href="#2、解题思路-42" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>这道题中，n 可以有多个相同的完全平方数 <code>x^2</code> 组成，也就是说，如果我们将 x 看为背包问题中的物品，那么每个 x 可以被多次加入到背包中</li><li>我们可以将这道题转换为，给你一个容量为 n 的背包，同时给你一些物品，而物品由 n 决定，物品为 [1, b] ，其中满足 b * b &lt;= n 且 (b + 1) * (b + 1) &gt; n</li><li>明确 dp 数组含义</li></ul><blockquote><p><strong>其中 dp[j] 表示 j 最少可以由 <code>dp[j]</code> 个完全平方数组成</strong></p></blockquote><ul><li>确定状态转移方程，这道题是一道求最值问题，所以状态转移方程为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>当我们手中握有 i * i 这个平方数时，我们只需要求出组成 j - i * i 最少需要多少个平方数，然后再这个结果的基础上加上一，就得到了我们想要的结果。</p></blockquote><ul><li>初始化 dp 数组</li></ul><ol><li>dp[0] 可以由 0 个平方数组成，所以 dp[0] = 0;</li><li>dp[1] 可以由一个平方数组成，所以 dp[1] = 1;</li><li>对于其他下标的元素，在使用递推公式进行运算时，我们不希望它的真正结果被 0 覆盖，所以我们将其他下标的值都初始化为 <code>Integer.MAX_VALUE</code></li></ol><blockquote><p>在进行子问题分割时，只有当 <code>dp[j - i * i]</code> 不为 <code>Integer.MAX_VALUE</code> 时（此时子问题存在有效解），才进行递推公式的计算。</p></blockquote><h3 id="3、解题代码-42"><a href="#3、解题代码-42" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><ul><li>首先，我们需要根据 n 找到本次问题所有所需的物品，即 [1, b] ，其中满足 b * b &lt;= n 且 (b + 1) ^ 2 &gt; n</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSizeByN</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 比如说 size 为 10 ，那么比 10 小的平方数有 1、4和9，可供选择的物品有 1 2 3 </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 size + 1 的平方大于 n ，那么此时直接 break ，得到的 size 就是我们要寻找的值，当前物品的个数就是 1 - n </span></span><br><span class="line">        <span class="keyword">if</span> ((size + <span class="number">1</span>) * (size + <span class="number">1</span>) &gt; n) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用两个循环来解决这道题，先遍历物品后遍历背包，只有当当前背包容量大于 i * i 且子问题有效时，才能进行状态转移</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组，其中 dp[i] 表示和为 i 的完全平方数的最少数量</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算出当前物品的个数，即 size </span></span><br><span class="line">    <span class="keyword">int</span> size = getSizeByN(n);</span><br><span class="line">    <span class="comment">// 外层循环遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= size;i++) &#123;</span><br><span class="line">        <span class="comment">// 内层循环正序遍历背包，只有当当前背包容量大于等于物品重量的平方时且子问题有解时，才能进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= i * i &amp;&amp; dp[j - i * i] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="comment">// 此时可以进行状态转移</span></span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、背包问题总结"><a href="#五、背包问题总结" class="headerlink" title="五、背包问题总结"></a>五、背包问题总结</h1><blockquote><p>背包问题大体的接替模板是两层循环，<strong>分别是外层循环遍历物品，然后内层循环遍历背包，然后在循环中写状态转移方程</strong>。</p><p>在我现在的学习中，背包问题可以根据所给条件和待求项分为以下几类</p></blockquote><h2 id="5-1、根据所给条件分类"><a href="#5-1、根据所给条件分类" class="headerlink" title="5.1、根据所给条件分类"></a>5.1、根据所给条件分类</h2><blockquote><p>根据所给物品的个数，可以分为 01 背包问题和完全背包问题，在使用一维数组进行空间优化时，二者的区别是内层循环的遍历顺序，其中：</p></blockquote><ul><li>对于 01 背包问题而言，内层循环在遍历背包时需要逆序遍历，保证物品只被加入到背包中一次</li><li>对于完全背包问题而言，内层循环在遍历背包时需要正序遍历。</li></ul><h2 id="5-2、根据待求项分类"><a href="#5-2、根据待求项分类" class="headerlink" title="5.2、根据待求项分类"></a>5.2、根据待求项分类</h2><h3 id="1、最值问题-I"><a href="#1、最值问题-I" class="headerlink" title="1、最值问题 I"></a>1、最值问题 I</h3><blockquote><p>问背包最多能装多少，状态转移方程一般如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><h3 id="2、存在问题"><a href="#2、存在问题" class="headerlink" title="2、存在问题"></a>2、存在问题</h3><blockquote><p>当我们求解存在问题时，状态转移方程一般如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = dp[j] || dp[j - nums[i]];</span><br></pre></td></tr></table></figure><blockquote><p>比如说上面我们就是将 <strong>分割等和子集</strong> 、 <strong>最后一块石头重量 II</strong> 看为存在问题解决。</p></blockquote><h3 id="3、组合问题"><a href="#3、组合问题" class="headerlink" title="3、组合问题"></a>3、组合问题</h3><blockquote><p>当我们求解存在问题时，状态转移方程一般如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]];</span><br></pre></td></tr></table></figure><blockquote><p>比如说上面提到的<strong>零钱兑换 II</strong> 、 <strong>目标和</strong> 就是这类问题</p></blockquote><h3 id="4、最值问题-II"><a href="#4、最值问题-II" class="headerlink" title="4、最值问题 II"></a>4、最值问题 II</h3><blockquote><p>问装满背包所有物品的最小个数，状态转移方程一般如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = Math.min(dp[j], dp[j - nums[i]] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>零钱问题</strong> I 就是这样的问题</p></blockquote><h2 id="5-3、组合问题和排列问题"><a href="#5-3、组合问题和排列问题" class="headerlink" title="5.3、组合问题和排列问题"></a>5.3、组合问题和排列问题</h2><h3 id="1、组合问题"><a href="#1、组合问题" class="headerlink" title="1、组合问题"></a>1、组合问题</h3><ul><li>组合数的概念：从 n 个不同元素中，任取 m（m≤n）个元素<strong>不计顺序</strong>的组成一组，则所有不同的组合个数，称为组合数。</li><li><strong>如果求组合数，那么就是外层循环遍历物品，内层循环遍历背包</strong></li></ul><h3 id="2、排列问题"><a href="#2、排列问题" class="headerlink" title="2、排列问题"></a>2、排列问题</h3><ul><li>排列数的概念：从 n 个不同元素中，任取 m（m≤n）个元素<strong>有顺序</strong>的排成一列，则所有不同的排列个数，称为排列数。</li><li><strong>如果求组合数，那么就是外层循环遍历背包，内层循环遍历物品</strong></li></ul><h1 id="六、编辑距离问题总结"><a href="#六、编辑距离问题总结" class="headerlink" title="六、编辑距离问题总结"></a>六、编辑距离问题总结</h1><blockquote><p>在使用动态规划求解字符串相关问题时， <code>dp[i][j]</code> 的含义通常是指字符串 <code>s1</code> 下标范围为 [0. i - 1] 的子串 a ，与字符串 <code>s2</code> 下标范围为 [0, j - 1] 的子串 b ，二者之间的某些指标。</p><p>个人觉得是为了考虑空串，同时为了 初始化工作的方便</p></blockquote><h2 id="6-1、判断子序列"><a href="#6-1、判断子序列" class="headerlink" title="6.1、判断子序列"></a>6.1、判断子序列</h2><ul><li><p>dp 数组含义：<code>dp[i][j]</code> 表示字符串 s 中范围下标为 <code>[0, i - 1]</code> 的子串 a ，是否为字符串 t 中范围下标为 <code>[0, j - 1]</code> 的字符串 b 的子序列， dp 数组是一个二维的 boolean 数组</p></li><li><p>当 <code>s[i - 1] == t[j - 1]</code> 时，此时表示 s 与 t 找到了一个公共字符，此时我们只需要判断当前 s 的子串 a ，在去掉公共字符后，是否为去掉公共字符的 b 的子序列即可（其中 b 为 t 的子串）</p></li></ul><blockquote><p>此时 <code>s[0, i - 1]</code> 是否为 <code>t[0, j - 1]</code> 的子序列，这个结果完全由 <code>s[0, i - 2]</code> 与 <code>t[0, j - 2]</code> 的关系决定。</p><p>如果此时 a 是 b 的子序列，那么证明 <code>s[0, i - 1]</code> 是 <code>t[0, j - 1]</code> 的子序列；反之则不是</p></blockquote><ul><li>当 <code>s[i - 1] != t[j - 1]</code> ，此时我们需要删去 t 子串中的最后一个字符 t[j - 1] ，因为此时 s[0, i - 1] 是否为 t[0,j - 1] 的子序列与 t[j - 1] 完全没有关系</li></ul><blockquote><p>如果 <code>s[0, i - 1]</code> 已经是 <code>t[0, j - 2]</code> 的子序列，那么 <code>s[0, i - 1]</code> 也必定为 <code>t[0, j - 1]</code> 的子序列；</p><p>如果 <code>s[0, i - 1]</code> 并不是 <code>t[0, j - 2]</code> 的子序列，那么此时 t[j - 1] 这个字符于事无补，所以 <code>s[0, i - 1]</code> 也一定不为 <code>t[0, j - 1]</code> 的子序列；</p></blockquote><ul><li>本题递推公式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[i - <span class="number">1</span>]) &#123;</span><br><span class="line">	dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2、不同的子序列"><a href="#6-2、不同的子序列" class="headerlink" title="6.2、不同的子序列"></a>6.2、不同的子序列</h2><ul><li>dp 数组含义：<code>dp[i][j]</code> 表示字符串 s 中范围下标为 <code>[0, i - 1]</code> 的子串 a ，在字符串 t 中范围下标为 <code>[0, j - 1]</code> 的字符串 b 中作为子序列出现的次数，dp 数组是一个二维的 int 数组</li><li>当 <code>s[i - 1] == t[j - 1]</code> 时，此时出现了公共字符，那么我们有两个选择</li></ul><ol><li>第一个选择就是让 <code>s[i - 1]</code> 字符直接与 <code>t[j - 1]</code> 进行匹配，比如说 <code>s = bag</code> , <code>t = baagg</code> ，我们可以选择让 t 中的最后一个 g 与 s 的最后一个 g 进行匹配，这是其中一种选择，这种选择下得到的个数为 <code>dp[i][j] = dp[i - 1][j - 1]</code> ，即我们只需要查找 <code>s[0, i - 2]</code> 在 <code>t[0,j - 1]</code> 中作为子序列出现的次数即可</li><li>第二种选择就是让 <code>s[i - 2]</code> 字符与 <code>t[j - 1]</code> 进行匹配，而 <code>s[i - 1]</code> 不参与匹配，比如说 <code>s = bag</code> , <code>t = baagg</code> ，让 t 中倒数第二个 g 与 s 中的最后一个 g 进行匹配，这也是其中一种情况，这种情况下得到的个数为 <code>dp[i][j] = dp[i][j - 1]</code> ，我们需要查找 <code>s[0. i - 1]</code> 在 <code>t[0, j - 2]</code> 中作为子序列出现的次数</li></ol><blockquote><p>由于本题中我们需要求出所有情况下出现次数之和，所以我们需要将上面两种选择得到的结果进行汇总</p></blockquote><ul><li>当 <code>s[i - 1] != t[j - 1]</code> 时，此时我们只能舍弃 t 中最后一个字符，然后用剩下的字符进行匹配，此时式子为 <code>dp[i][j] = dp[i][j - 1]</code></li><li>递推公式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[i - <span class="number">1</span>]) &#123;</span><br><span class="line">	<span class="comment">// 两种情况汇总</span></span><br><span class="line">	dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 去掉 t 中最后一个字符，然后尝试进行匹配</span></span><br><span class="line">	dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-3、两个字符串中的删除操作"><a href="#6-3、两个字符串中的删除操作" class="headerlink" title="6.3、两个字符串中的删除操作"></a>6.3、两个字符串中的删除操作</h2><ul><li>dp 数组含义：<code>dp[i][j]</code> 表示字符串 s 中范围下标为 <code>[0, i - 1]</code> 的子串 a ，变为字符串 t 中范围下标为 <code>[0, j - 1]</code> 的子串 b ，所需要进行的删除操作次数</li><li>当 <code>s[i - 1] == t[j - 1]</code> 时，此时我们此刻相等的字符为公共字符，从 <code>a[0, i - 1]</code> 变为 <code>b[0, j - 1]</code> 所需的最小删除次数与 <code>a[0, i - 2]</code> 变为 <code>b[0. j - 1]</code> 所需的最小删除次数相等，也就是说，公共字符的存在与否并不会对两个字符串的最小删除次数造成影响，所以我们可以得出此时的式子为 <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>当 <code>s[i - 1] == t[j - 1]</code> 时，此时我们用三种做法可供选择，此时我们假设 s 的子串为 a ，t 的子串为 b</li></ul><ol><li>删去 a 中的某一个字符，此时得到的式子为 <code>dp[i - 1][j] + 1</code> ，1 表示删去 a 中字符的那一次操作</li><li>删去 b 中的某一个字符，此时得到的式子为 <code>dp[i][j - 1] + 1</code> ，1 表示删去 b 中字符的那一次操作</li><li>同时删去 a 和 b 中的字符，此时得到的式子为 <code>dp[i - 1][j - 1] + 2</code></li></ol><blockquote><p>由于我们要求最小删除次数，所以我们需要在上述的三种情况中选择一个最小的结果</p></blockquote><ul><li>递推公式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[i - <span class="number">1</span>]) &#123;</span><br><span class="line">	dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4、编辑距离"><a href="#6-4、编辑距离" class="headerlink" title="6.4、编辑距离"></a>6.4、编辑距离</h2><ul><li>dp 数组含义：<code>dp[i][j]</code> 表示字符串 s 中范围下标为 <code>[0, i - 1]</code> 的子串 a ，与字符串 t 中范围下标为 <code>[0, j - 1]</code> 的子串 b 之间的最小编辑距离</li><li>当 <code>s[i - 1] == t[j - 1]</code> 时，此时子串 a 和 子串 b 二者的编辑距离与去掉公共字符的编辑距离相等，即 <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>当 <code>s[i - 1] == t[j - 1]</code> 时，此时我们有几种做法可供选择</li></ul><ol><li>word1 删除一个元素，那么就是以下标 <code>word1[0, i - 2]</code> 与 <code>word2[0, j - 1]</code> 的最短编辑距离，再加上一个删除操作，此时得到的式子应该为 <code>dp[i - 1][j] + 1</code></li><li>word2 删除一个元素，那么就是以下标 <code>word1[0, i - 1]</code> 与 <code>word2[0. j - 2]</code> 的最短编辑距离，再加上一个删除操作，此时得到的式子应该为 <code>dp[i][j - 1] + 1</code></li><li>替换元素，此时 word1 替换 <code>word1[i - 1]</code> ，使其等于 <code>word2[j - 1]</code> ，此时我们又可以将 <code>word1[i - 1]</code> 看为一个公共元素，只不过我们需要原来的基础上加上一次编辑，此时得到的式子为 <code>dp[i - 1][j - 1] + 1</code></li><li>对于添加操作来说， <code>word1</code> 添加一个字符，就相当于 <code>word2</code> 删除一个字符，比如说，当 <code>word1</code> 为 <code>abce</code> ，<code>word2</code> 为 <code>abc</code> 时，<code>word1</code> 删去 <code>e</code> 与 <code>word2</code> 加上 <code>e</code> 的结果都相同，所以我们只需要考虑删除的情况即可</li></ol><ul><li>递推公式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[i - <span class="number">1</span>]) &#123;</span><br><span class="line">	dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>数据结构与算法学习（二十一）-动态规划</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/278458465.html">https://sutianxin.top/posts/278458465.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-12-02</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-12-17</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%98%95Java/">☕Java</a><a class="post-meta__tags" href="/tags/%F0%9F%92%BB%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/">💻后端学习</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/blogImage/raw/master/img/20211202163900.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3487497828.html"><img class="prev-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211202163935.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构与算法学习（二十）-暴力递归与回溯</div></div></a></div><div class="next-post pull-right"><a href="/posts/2617042707.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211111234105.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构与算法学习（十九）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1128227004.html" title="Java应用学习（七）-回顾Mybatis和Spring MVC"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210430102830.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">Java应用学习（七）-回顾Mybatis和Spring MVC</div></div></a></div><div><a href="/posts/2938255980.html" title="Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210208120213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-12</div><div class="title">Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用</div></div></a></div><div><a href="/posts/913123791.html" title="Spring Cloud学习（七）-Spring Cloud Config"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210516192228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="title">Spring Cloud学习（七）-Spring Cloud Config</div></div></a></div><div><a href="/posts/2863462089.html" title="Spring Cloud学习（二）-OpenFeign微服务调用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504192527.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-11</div><div class="title">Spring Cloud学习（二）-OpenFeign微服务调用</div></div></a></div><div><a href="/posts/995752607.html" title="Spring Cloud学习（四）-Eureka服务注册中心"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210214225250.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-14</div><div class="title">Spring Cloud学习（四）-Eureka服务注册中心</div></div></a></div><div><a href="/posts/650479038.html" title="在线教育项目总结（二）-用户认证"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210205204706.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-05</div><div class="title">在线教育项目总结（二）-用户认证</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">二、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E"><span class="toc-text">2.1、概念说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">2.2、使用最小花费爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">2.3、不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-1"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-text">2.4、不同路径 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-2"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E3%80%81%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-text">2.5、整数拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-3"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">2.6、不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-4"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7%E3%80%81%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">2.7、分割等和子集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-5"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8%E3%80%81%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="toc-text">2.8、最后一块石头的重量 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-6"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9%E3%80%81%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">2.9、最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-7"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10%E3%80%81%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">2.10、打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-8"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11%E3%80%81%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="toc-text">2.11、打家劫舍 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-9"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">2.12、买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-10"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13%E3%80%81%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-text">2.13、最长连续递增序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-11"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-11"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14%E3%80%81%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">2.14、最长重复子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-12"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-12"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-12"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15%E3%80%81%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">2.15、最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-13"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-13"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-13"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16%E3%80%81-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="toc-text">2.16、 不相交的线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-14"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-14"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-14"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-17%E3%80%81%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-text">2.17、最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-15"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-15"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-15"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-18%E3%80%81%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">2.18、判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-16"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-16"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-16"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-19%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">2.19、不同的子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-17"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-17"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-17"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-20%E3%80%81%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">2.20、两个字符串的删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-18"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-18"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-18"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-21%E3%80%81%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">2.21、编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-19"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-19"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-19"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-22%E3%80%81%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">2.22、最长回文子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-20"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-20"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-20"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-23%E3%80%81%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%90%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0"><span class="toc-text">2.23、让字符串成为回文串的最少插入次数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-21"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-21"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-21"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-24%E3%80%81%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98"><span class="toc-text">2.24、俄罗斯套娃信封问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-22"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-22"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-22"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-25%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">2.25、正则表达式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-23"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-23"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-23"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-26%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-text">2.26、礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-24"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-24"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-24"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-27%E3%80%81%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2.27、最长不含重复字符的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-25"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-25"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-25"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-28%E3%80%81%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2.28、把数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-26"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-26"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-26"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-29%E3%80%81%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0"><span class="toc-text">2.29、删除并获得点数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-27"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-27"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-27"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-30%E3%80%81%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-text">2.30、接雨水</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-28"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-28"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-28"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-31%E3%80%81%E4%B8%91%E6%95%B0-II"><span class="toc-text">2.31、丑数 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-29"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-29"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-29"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-32%E3%80%81%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-I"><span class="toc-text">2.32、跳跃游戏 I</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-30"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-30"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-30"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-33%E3%80%81%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="toc-text">2.33、跳跃游戏 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-31"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-31"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-31"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-34%E3%80%81%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-text">2.34、环形子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-32"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-32"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-32"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-35%E3%80%81%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">2.35、乘积最大子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-33"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-33"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-33"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-36%E3%80%81%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-text">2.36、乘积为正数的最长子数组长度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-34"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-34"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-34"><span class="toc-text">3、解题代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%8101-%E8%83%8C%E5%8C%85"><span class="toc-text">三、01 背包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%8101-%E8%83%8C%E5%8C%85%E5%9B%9E%E9%A1%BE"><span class="toc-text">3.1、01 背包回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-35"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E8%A7%A3-01-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">2、使用动态规划求解 01 背包问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">3.2、使用一维滚动数组优化背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-text">1、优化思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%90%AB%E4%B9%89%E4%BB%8B%E7%BB%8D"><span class="toc-text">2、含义介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81"><span class="toc-text">3、代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">3.3、目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-36"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-35"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-35"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-text">3.4、使用一维滚动数组优化分割等和子集问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF-1"><span class="toc-text">1、优化思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">2、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E3%80%81%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="toc-text">3.5、最后一块石头的重量 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">1、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-1"><span class="toc-text">2、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6%E3%80%81%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-text">3.6、一和零</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-37"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-36"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-36"><span class="toc-text">3、解题代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">四、完全背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E8%AF%B4%E6%98%8E"><span class="toc-text">4.1、完全背包问题理论说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-38"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-37"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-37"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text">4.2、零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-39"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-38"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-38"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="toc-text">4.3、零钱兑换 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-40"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-39"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-39"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-IV"><span class="toc-text">4.4、组合总和 IV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-41"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-40"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-40"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E3%80%81%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">4.5、爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-42"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-41"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-41"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6%E3%80%81%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">4.6、完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-43"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-42"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-42"><span class="toc-text">3、解题代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-text">五、背包问题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E6%A0%B9%E6%8D%AE%E6%89%80%E7%BB%99%E6%9D%A1%E4%BB%B6%E5%88%86%E7%B1%BB"><span class="toc-text">5.1、根据所给条件分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E6%A0%B9%E6%8D%AE%E5%BE%85%E6%B1%82%E9%A1%B9%E5%88%86%E7%B1%BB"><span class="toc-text">5.2、根据待求项分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98-I"><span class="toc-text">1、最值问题 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-text">2、存在问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-text">3、组合问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98-II"><span class="toc-text">4、最值问题 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%E5%92%8C%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-text">5.3、组合问题和排列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-text">1、组合问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-text">2、排列问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-text">六、编辑距离问题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">6.1、判断子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">6.2、不同的子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">6.3、两个字符串中的删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4%E3%80%81%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">6.4、编辑距离</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init({el:"#twikoo-wrap",envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai"})},e=()=>{twikoo.getCommentsCount({envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then(function(o){t.innerText=o[0].count}).catch(function(o){console.error(o)})};var n;n=!0,"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" data-lrctype="0" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_yegv7kt2bj.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.js"></script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><script src="https://www.luckyclover.top/rain.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"]):not([href="/contact/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>