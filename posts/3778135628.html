<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构与算法学习（十八） | Arno</title><meta name="keywords" content="☕Java,💻后端学习"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、判断字符是否唯一1.1、题目描述 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。  1.2、解题思路 使用一个数组来解决这个问题，创建一个长度为 256 的数组（ascii 码数目） 循环遍历字符串转换而成的字符数组，当遍历到一个字符时，判断这个字符对应的 ascii 码对应的值是否为 1 ，如果是，直接返回 false ，否则将字符 ascii 码对应的那个元素置为 1    这"><meta property="og:type" content="article"><meta property="og:title" content="数据结构与算法学习（十八）"><meta property="og:url" content="https://sutianxin.top/posts/3778135628.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="1、判断字符是否唯一1.1、题目描述 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。  1.2、解题思路 使用一个数组来解决这个问题，创建一个长度为 256 的数组（ascii 码数目） 循环遍历字符串转换而成的字符数组，当遍历到一个字符时，判断这个字符对应的 ascii 码对应的值是否为 1 ，如果是，直接返回 false ，否则将字符 ascii 码对应的那个元素置为 1    这"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20211106121506.jpg"><meta property="article:published_time" content="2021-11-06T04:13:10.000Z"><meta property="article:modified_time" content="2021-11-11T15:40:18.464Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="☕Java"><meta property="article:tag" content="💻后端学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20211106121506.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/3778135628"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-11-11 23:40:18"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,a={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(a)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">85</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/blogImage/raw/master/img/20211106121506.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法学习（十八）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-06T04:13:10.000Z" title="发表于 2021-11-06 12:13:10">2021-11-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-11T15:40:18.464Z" title="更新于 2021-11-11 23:40:18">2021-11-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.1k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、判断字符是否唯一"><a href="#1、判断字符是否唯一" class="headerlink" title="1、判断字符是否唯一"></a>1、判断字符是否唯一</h2><h3 id="1-1、题目描述"><a href="#1-1、题目描述" class="headerlink" title="1.1、题目描述"></a>1.1、题目描述</h3><blockquote><p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p></blockquote><h3 id="1-2、解题思路"><a href="#1-2、解题思路" class="headerlink" title="1.2、解题思路"></a>1.2、解题思路</h3><ul><li>使用一个数组来解决这个问题，创建一个长度为 256 的数组（ascii 码数目）</li><li>循环遍历字符串转换而成的字符数组，当遍历到一个字符时，判断这个字符对应的 ascii 码对应的值是否为 1 ，如果是，直接返回 false ，否则将字符 ascii 码对应的那个元素置为 1</li></ul><blockquote><p>这道题也可以用集合来做，但没必要</p></blockquote><h3 id="1-3、解题代码"><a href="#1-3、解题代码" class="headerlink" title="1.3、解题代码"></a>1.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (astr == <span class="keyword">null</span> || astr.length() == <span class="number">0</span> || <span class="string">&quot;&quot;</span>.equals(astr.trim())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span>[] array = astr.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[array[i]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[array[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、字符串压缩"><a href="#2、字符串压缩" class="headerlink" title="2、字符串压缩"></a>2、字符串压缩</h2><h3 id="2-1、题目描述"><a href="#2-1、题目描述" class="headerlink" title="2.1、题目描述"></a>2.1、题目描述</h3><blockquote><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串 <code>aabcccccaaa</code> 会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p></blockquote><h3 id="2-2、解题思路"><a href="#2-2、解题思路" class="headerlink" title="2.2、解题思路"></a>2.2、解题思路</h3><ul><li><p>使用快慢指针完成这道题</p></li><li><p>初始化两个指针，慢指针 slow 一开始指向下标为 0 的元素，快指针 fast 一开始指向下标为 1 的元素</p></li><li><p>当 fast 指向的元素等于 slow 指向的元素时，此时让 right 往后移</p></li><li><p>当 fast 指向的元素不等于 slow 指向的元素时，此时进行结果字符串拼接，将 left 指向的字符拼接到结果字符串中，然后再将 right - slow 的值拼接到结果字符串中，然后让 left 移动到 right 的位置，同时 right 后移</p></li></ul><h3 id="2-3、解题代码"><a href="#2-3、解题代码" class="headerlink" title="2.3、解题代码"></a>2.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (S.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> S;</span><br><span class="line">    <span class="comment">// 初始化 slow 指针为 0</span></span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化 fast 指针为 1</span></span><br><span class="line">    <span class="keyword">int</span> fast = <span class="number">1</span>;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; S.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.charAt(slow) != S.charAt(fast)) &#123;</span><br><span class="line">            builder.append(S.charAt(slow)).append(fast - slow);</span><br><span class="line">            <span class="comment">// 然后让 slow 来到 fast 的位置</span></span><br><span class="line">            slow = fast;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当两个指针指向的元素相等时，表示此时还不能进行结果字符串的拼接</span></span><br><span class="line">            <span class="comment">// 直接让 fast 指针后移即可</span></span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在最后，需要进行收尾，对此时 left 指向的元素进行拼接，否则会丢失最后一个字符及其出现次数</span></span><br><span class="line">    builder.append(S.charAt(slow)).append(fast - slow);</span><br><span class="line">    <span class="keyword">return</span> builder.toString().length() &gt;= S.length() ? S : builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、字符串轮转"><a href="#3、字符串轮转" class="headerlink" title="3、字符串轮转"></a>3、字符串轮转</h2><h3 id="3-1、题目描述"><a href="#3-1、题目描述" class="headerlink" title="3.1、题目描述"></a>3.1、题目描述</h3><blockquote><p>字符串轮转。给定两个字符串<code>s1</code>和<code>s2</code>，请编写代码检查<code>s2</code>是否为<code>s1</code>旋转而成（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串）。</p></blockquote><ul><li><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;waterbottle&quot;, s2 &#x3D; &quot;erbottlewat&quot;</span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure></li><li><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;aa&quot;, s2 &#x3D; &quot;aba&quot;</span><br><span class="line">输出：False</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2、解题思路"><a href="#3-2、解题思路" class="headerlink" title="3.2、解题思路"></a>3.2、解题思路</h3><ul><li>两个字符串排序后判断是否相等</li><li><strong>将两个 s2 进行拼接</strong>，得到结果串 Str ，然后判断 Str 是否含有 <code>s1</code> ，如果有，返回 true ，否则返回 false</li></ul><h3 id="3-3、解题代码"><a href="#3-3、解题代码" class="headerlink" title="3.3、解题代码"></a>3.3、解题代码</h3><ul><li>排序后判断是否相等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="keyword">null</span> &amp;&amp; s2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() != s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">char</span>[] array1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] array2 = s2.toCharArray();</span><br><span class="line">    Arrays.sort(array1);</span><br><span class="line">    Arrays.sort(array2);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array1).equals(<span class="keyword">new</span> String(array2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拼接后判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="keyword">null</span> &amp;&amp; s2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() != s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    String result = s2 + s2;</span><br><span class="line">    <span class="keyword">return</span> result.contains(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、字符串回文排列"><a href="#4、字符串回文排列" class="headerlink" title="4、字符串回文排列"></a>4、字符串回文排列</h2><h3 id="4-1、题目描述"><a href="#4-1、题目描述" class="headerlink" title="4.1、题目描述"></a>4.1、题目描述</h3><blockquote><p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。</p><p>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。</p><p>回文串不一定是字典当中的单词。</p></blockquote><h3 id="4-2、解题思路"><a href="#4-2、解题思路" class="headerlink" title="4.2、解题思路"></a>4.2、解题思路</h3><ul><li>要想一个字符串可以回文排列，那么必须满足以下条件之一</li></ul><ol><li>字符串有奇数个字符，同时只能有一个字符与其他字符不同，剩下的字符必须两两成对</li><li>字符串有偶数个字符，此时字符串中的字符必须两两成对。</li></ol><blockquote><p>使用一个 HashSet 来解决这个问题，遍历字符串中的每一个字符，然后尝试将其加入到 set 中，如果添加成功，那么什么都不做，如果添加失败，证明 set 中已经存在过当前遍历的字符，我们需要将其从 set 中剔除。</p><p>遍历完成后，判断 set 中的元素个数，如果小于等于 1 ，那么返回 true ，否则返回 false</p></blockquote><h3 id="4-3、解题代码"><a href="#4-3、解题代码" class="headerlink" title="4.3、解题代码"></a>4.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPermutePalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.add(c)) &#123;</span><br><span class="line">            set.remove(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size() &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、一次编辑"><a href="#5、一次编辑" class="headerlink" title="5、一次编辑"></a>5、一次编辑</h2><h3 id="5-1、题目描述"><a href="#5-1、题目描述" class="headerlink" title="5.1、题目描述"></a>5.1、题目描述</h3><blockquote><p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p></blockquote><h3 id="5-2、解题思路"><a href="#5-2、解题思路" class="headerlink" title="5.2、解题思路"></a>5.2、解题思路</h3><ul><li>如果两个字符串长度相差一，那么直接返回 false</li><li>如果两个字符串长度相等，那么只需要逐个比较字符串中的字符即可，使用一个标识符来标识是否编辑过，当遇到第一个不等字符时，将这个标识符从 false 置为 true ，表示已经编辑过，如果在之后的遍历中遇到另外的不等字符，那么直接返回 false 即可。</li><li>如果两个字符串长度不相等，那么此时我们记长的字符串为 long ，短的字符串为 small ，仍然使用一个标识符来表示是否编辑过，这里使用双指针遍历两个字符串，如果两个指针指向的字符不等，那么将标识符从 false 置为 true ，表示已经编辑过，然后将用于遍历长字符串的指针后移</li></ul><blockquote><p>因为对于这次编辑来说，如果是添加，那么这个多出来的元素可能是短字符串中缺少的元素，此时我们需要让长字符串的下一个字符与当前短字符串的字符相比。</p><p>删除同理，将不等的那个字符删掉后，比较长字符串下一个字符与短字符串当前字符是否相等。</p></blockquote><h3 id="5-3、解题代码"><a href="#5-3、解题代码" class="headerlink" title="5.3、解题代码"></a>5.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两个字符串的长度相差大于 1 ，那么直接返回 false</span></span><br><span class="line">    <span class="keyword">int</span> firstLength = first.length();</span><br><span class="line">    <span class="keyword">int</span> secondLength = second.length();</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(firstLength - secondLength) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isEdit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= firstLength - <span class="number">1</span> &amp;&amp; right &lt;= secondLength - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果两个指针指向的元素相等，那么直接让两个指针共同后移即可</span></span><br><span class="line">        <span class="keyword">if</span> (first.charAt(left) == second.charAt(right)) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isEdit)&#123;</span><br><span class="line">                <span class="keyword">if</span> (firstLength == secondLength) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstLength &lt; secondLength) &#123;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                isEdit = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、移除重复节点"><a href="#6、移除重复节点" class="headerlink" title="6、移除重复节点"></a>6、移除重复节点</h2><h3 id="6-1、题目描述"><a href="#6-1、题目描述" class="headerlink" title="6.1、题目描述"></a>6.1、题目描述</h3><blockquote><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p></blockquote><h3 id="6-2、解题思路"><a href="#6-2、解题思路" class="headerlink" title="6.2、解题思路"></a>6.2、解题思路</h3><ul><li>使用一个 Set 来解决这道题，初始化两个指针 pre 和 cur ，一个指向头节点，用于结果返回，第二个用于遍历链表</li><li>每遍历到一个节点，就尝试着将其加入到 set 中，如果加入成功，那么继续遍历，如果添加不成功，则删除那个无法加入到 set 之中的节点</li><li>最后返回头节点即可</li></ul><h3 id="6-3、解题代码"><a href="#6-3、解题代码" class="headerlink" title="6.3、解题代码"></a>6.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Set&lt;Integer&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    nodeSet.add(head.val);</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeSet.add(cur.next.val)) &#123;</span><br><span class="line">            <span class="comment">// 如果能放入 set 中，那么继续遍历</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则移除 cur.next 这个节点</span></span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、旋转矩阵"><a href="#7、旋转矩阵" class="headerlink" title="7、旋转矩阵"></a>7、旋转矩阵</h2><h3 id="7-1、题目描述"><a href="#7-1、题目描述" class="headerlink" title="7.1、题目描述"></a>7.1、题目描述</h3><blockquote><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像<strong>顺时针</strong>旋转 90 度。</p></blockquote><ul><li>示例 1:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>示例 2:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="7-2、解题思路"><a href="#7-2、解题思路" class="headerlink" title="7.2、解题思路"></a>7.2、解题思路</h3><ul><li>从外到内进行处理，在进行顺时针九十度旋转时，外圈和内圈的元素不会进行交换，也就是说，外圈元素只是和外圈元素进行交换，而内圈元素也仅和内圈元素进行交换</li><li>我们先处理最外圈的元素，以示例二的矩阵为例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ 5, 1, 9,11],</span><br><span class="line">[ 2,      10],</span><br><span class="line">[13,       7],</span><br><span class="line">[15,14,12,16]</span><br></pre></td></tr></table></figure><ul><li><p>在我们处理完最外圈元素后，我们再处理第二层的元素，此时只需要将左上角点向右下角移动，右下角点向左上角点移动即可处理第二圈…</p></li><li><p>在一个圈内，我们可以将这个 n * n 的圈的元素分为 n - 1 组，然后进行交换，下面以 4 * 4 的圈为例</p></li></ul><blockquote><p>我们将同组元素用相同的形状划分，在进行顺时针九十度旋转时，每个元素都根据箭头的指向进行元素覆盖</p></blockquote><ul><li>我们记这个圈的左上角点的行号为 sR ，右下角点的列号为 eC ，那么</li></ul><ol><li>第 i 组的第一个元素就可以表示为 <code>martix[sR] [sR + i]</code></li><li>第 i 组的第二个元素就可以表示为 <code>martix[sR + i] [eC]</code> （第 i 组的第二个元素全部都在最后一列）</li><li>第 i 组的第三个元素就可以表示为 <code>martix[eC] [eC - i]</code></li><li>第 i 组的第四个元素就可以表示为 <code>martix[eC - i] [sR]</code> （第 i 组的第四个元素一定在第一列）</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211024155926.png" alt="image-20211024155919089"></p><ul><li>如何交换元素，以上面的外圈矩阵为例</li></ul><ol><li>先使用一个变量保存第 i 组第一个元素的值</li><li>然后用第四个元素的值覆盖第一个元素的位置</li><li>用第三个元素的值覆盖第四个元素的位置</li><li>用第二个元素的值覆盖第三个元素的位置</li><li>最后用临时变量中第一个元素的值覆盖第二个元素的位置</li></ol><h3 id="7-3、解题代码"><a href="#7-3、解题代码" class="headerlink" title="7.3、解题代码"></a>7.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用两个变量来表示矩阵的左上角点，初始化为 (0,0)</span></span><br><span class="line">    <span class="keyword">int</span> startRow = <span class="number">0</span>, startColumn = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用两个变量来表示矩阵的右下角点，初始化为 (matrix.length - 1, matrix[0].length - 1)</span></span><br><span class="line">    <span class="keyword">int</span> endRow = matrix.length - <span class="number">1</span>, endColumn = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当 startRow &lt; endRow 时，表示左上角点和右上角点还能构成一个待处理矩阵，所以需要进行处理</span></span><br><span class="line">    <span class="keyword">while</span> (startRow &lt; endRow) &#123;</span><br><span class="line">        <span class="comment">// 处理完外圈后，要让左上角点向右下角移动，右上角点向左上角移动</span></span><br><span class="line">        rotateCircle(matrix, startRow++, startColumn++, endRow++, endColumn++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对以点 (startRow,startColumn) 作为左上角点，以点 (endRow,endColumn) 作为右下角点的外围元素进行交换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateCircle</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> startRow, <span class="keyword">int</span> startColumn, <span class="keyword">int</span> endRow, <span class="keyword">int</span> endColumn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = endRow - startRow;</span><br><span class="line">    <span class="comment">// 这个变量用于交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对于一个 n * n 的圈，我们需要分为 n - 1 组处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        <span class="comment">// 先保存第 i 组第一个元素的值</span></span><br><span class="line">        temp = matrix[startRow][startRow + i];</span><br><span class="line">        <span class="comment">// 第 i 组第二个元素的值：matrix[startRow + i][endColumn]</span></span><br><span class="line">        <span class="comment">// 第 i 组第三个元素的值：matrix[endRow][endColumn - i]</span></span><br><span class="line">        <span class="comment">// 第 i 组第四个元素的值：matrix[endRow - i][startColumn]</span></span><br><span class="line">        <span class="comment">// 先用第四个元素的值覆盖第一个元素的位置</span></span><br><span class="line">        matrix[startRow][startColumn + i] = matrix[endRow - i][startColumn];</span><br><span class="line">        <span class="comment">// 然后用第三个元素的值覆盖第四个元素的位置</span></span><br><span class="line">        matrix[endRow - i][startColumn] = matrix[endRow][endColumn - i];</span><br><span class="line">        <span class="comment">// 用第二个元素的值覆盖第三个元素的位置</span></span><br><span class="line">        matrix[endRow][endColumn - i] = matrix[startRow + i][endColumn];</span><br><span class="line">        <span class="comment">// 用临时变量中第一个元素的值覆盖第二个元素的位置</span></span><br><span class="line">        matrix[startRow + i][endColumn] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、分割链表"><a href="#8、分割链表" class="headerlink" title="8、分割链表"></a>8、分割链表</h2><h3 id="8-1、题目描述"><a href="#8-1、题目描述" class="headerlink" title="8.1、题目描述"></a>8.1、题目描述</h3><blockquote><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你不需要 保留 每个分区中各节点的初始相对位置。</p></blockquote><h3 id="8-2、解题思路"><a href="#8-2、解题思路" class="headerlink" title="8.2、解题思路"></a>8.2、解题思路</h3><ul><li>使用快慢指针遍历链表，当快指针指向的节点的 val 大于等于 x 时，此时慢指针不动，而快指针右移</li><li>当快指针指向的节点的 val 小于 x 时，此时交换慢指针指向节点的值和快指针指向的节点的值，然后快慢指针一起后移</li></ul><h3 id="8-3、解题代码"><a href="#8-3、解题代码" class="headerlink" title="8.3、解题代码"></a>8.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="comment">// 这个值用于交换使用</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果此时快指针指向的节点的值小于 x</span></span><br><span class="line">        <span class="keyword">if</span> (fast.val &lt; x) &#123;</span><br><span class="line">            <span class="comment">// 此时需要将 slow.val 和 fast.val 的值进行交换，然后将 slow 后移</span></span><br><span class="line">            temp = fast.val;</span><br><span class="line">            fast.val = slow.val;</span><br><span class="line">            slow.val = temp;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于只是进行值的交换，没有涉及节点的移动和增删，所以可以直接返回</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、回文链表"><a href="#9、回文链表" class="headerlink" title="9、回文链表"></a>9、回文链表</h2><h3 id="9-1、题目描述"><a href="#9-1、题目描述" class="headerlink" title="9.1、题目描述"></a>9.1、题目描述</h3><blockquote><p>编写一个函数，检查输入的链表是否是回文的。</p></blockquote><h3 id="9-2、解题思路"><a href="#9-2、解题思路" class="headerlink" title="9.2、解题思路"></a>9.2、解题思路</h3><ul><li>使用快慢指针找到链表的中间结点，然后将中间结点之后的部分反转</li><li>比较链表前半部分和后半部分是否相同，如果相同，则证明是回文链表</li></ul><h3 id="9-3、解题代码"><a href="#9-3、解题代码" class="headerlink" title="9.3、解题代码"></a>9.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 初始化快慢指针指向 head 结点</span></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 fast 不为空，证明为奇数个结点</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转后半段链表</span></span><br><span class="line">    slow = reverseList(slow);</span><br><span class="line">    <span class="comment">// 让 fast 从头开始，比较前半部分和后半部分的值</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow.val != fast.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode reverseNode = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reverseNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、最小栈"><a href="#10、最小栈" class="headerlink" title="10、最小栈"></a>10、最小栈</h2><h3 id="10-1、题目描述"><a href="#10-1、题目描述" class="headerlink" title="10.1、题目描述"></a>10.1、题目描述</h3><blockquote><p>请设计一个栈，除了常规栈支持的 <code>pop</code> 与 <code>push</code> 函数以外，还支持 <code>min</code> 函数，该函数返回栈元素中的最小值。**执行push、pop和min操作的时间复杂度必须为O(1)**。</p></blockquote><h3 id="10-2、解题思路"><a href="#10-2、解题思路" class="headerlink" title="10.2、解题思路"></a>10.2、解题思路</h3><ul><li>定义一个 Node 类，这个类包含两个属性</li></ul><ol><li>value：结点的值</li><li>min：这个 Node 对象为栈顶元素时，当前栈的最小值</li></ol><ul><li>push 方法</li></ul><blockquote><p>当我们将一个值 x 压入栈中时，判断这个 x 与栈顶元素的关系</p></blockquote><ol><li>如果 x 小于当前栈顶元素的值，那么构造出一个 Node 对象压入栈中，这个 Node 对象的 value 为 x ，min 为 x</li><li>如果 x 大于等于当前栈顶元素的值，那么构造一个 Node 对象压入栈中，这个 Node 对象的 value 为 x ，min 为 <code>stack.peek().min</code> （栈顶元素的 min 值）</li></ol><ul><li>pop、peek 方法</li></ul><blockquote><p>返回栈顶 Node 对象的 value 值即可</p></blockquote><ul><li>getMin() 方法</li></ul><blockquote><p>返回栈顶 Node 对象 的 min 值即可</p></blockquote><h3 id="10-3、解题代码"><a href="#10-3、解题代码" class="headerlink" title="10.3、解题代码"></a>10.3、解题代码</h3><ul><li>Node 类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span> <span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> minValue)</span> </span>&#123;</span><br><span class="line">        min = minValue;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MinStack 实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Node&gt; minStack;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; minStack.peek().min || minStack.empty()) &#123;</span><br><span class="line">            minStack.push(<span class="keyword">new</span> Node(x, x));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minStack.push(<span class="keyword">new</span> Node(x, minStack.peek().min));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek().value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek().min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、Sqrt-x"><a href="#11、Sqrt-x" class="headerlink" title="11、Sqrt(x)"></a>11、Sqrt(x)</h2><h3 id="11-1、题目描述"><a href="#11-1、题目描述" class="headerlink" title="11.1、题目描述"></a>11.1、题目描述</h3><blockquote><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p><strong>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去</strong> 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5)</p></blockquote><h3 id="11-2、解题思路"><a href="#11-2、解题思路" class="headerlink" title="11.2、解题思路"></a>11.2、解题思路</h3><ul><li>使用二分法来解决这个问题，假设我们要求 104 的算术平方根</li></ul><ol><li>104 的算术平方根一定处于 [1,104] 之间，先求出 (1 + 104) / 2 的值，向下取整后得到 52</li><li>计算 52 * 52 的值，由于 52 * 52 的值远远大于 104 ，故 104 的算术平方根一定不会落在 [52, 104] 之间</li><li>所以我们从 [1,51] 中继续二分查找 104 的算术平方根</li></ol><ul><li>按照上面的步骤，我们可以一步步地缩减查找的范围</li></ul><ol><li><p>查找 1 - 51 之间的中位数，发现 26 * 26 的值大于 104 ，故我们缩减范围，在 [1,25] 之间查找</p></li><li><p>查找 1 - 25 之间的中位数，由于 13 * 13 的值大于 104 ，所以我们在 [1,12] 之间查找</p></li><li><p>在 1 - 12 之间查找，由于 6 * 6 的值小于 104 ，所以我们在 7 - 12 之间查找</p></li><li><p>在 7 - 12 之间查找，由于 9 * 9 的值小于 104 ，所以我们在 10 - 12 之间查找</p></li><li><p>在 10 - 12 之间查找，由于 11 * 11 的值大于 104 ，所以我们得到结果为 10</p></li></ol><h3 id="11-3、解题代码"><a href="#11-3、解题代码" class="headerlink" title="11.3、解题代码"></a>11.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化左右边界的值</span></span><br><span class="line">    <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> right = x;</span><br><span class="line">    <span class="keyword">long</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &lt;= x) &#123;</span><br><span class="line">            <span class="comment">// 如果计算出来的结果小于等于 x </span></span><br><span class="line">            <span class="comment">// 那么先记录答案，然后看看有没有更接近的</span></span><br><span class="line">            result = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12、最小覆盖子串"><a href="#12、最小覆盖子串" class="headerlink" title="12、最小覆盖子串"></a>12、最小覆盖子串</h2><h3 id="12-1、题目描述"><a href="#12-1、题目描述" class="headerlink" title="12.1、题目描述"></a>12.1、题目描述</h3><blockquote><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。<strong>返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串</strong>。</p><p>如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p></blockquote><ul><li><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;sabsbbcca&quot;, t &#x3D; &quot;aabbc&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-2、解题思路"><a href="#12-2、解题思路" class="headerlink" title="12.2、解题思路"></a>12.2、解题思路</h3><ul><li><p>只有当 s 长度大于等于 t 长度时，才需要进行讨论</p></li><li><p>创建一张“欠债表”，这张表中初始化为 t 字符串中出现的字符及其出现次数，并使用一个变量 <code>all</code> 记录欠债表中所有字符的个数，初始化为 t 字符串的长度</p></li><li><p>遍历 s 字符串，根据遍历到的内容对欠债表中内容和 <code>all</code> 变量中的值进行修改</p></li><li><p>以示例一为例</p></li></ul><ol><li>初始化一张欠债表，欠债表中的内容为字符串 t 中出现的字符及其出现次数，即 {“a”：2，”b”：2 ，”c”：1}，并初始化 <code>all</code> 为 t 字符串的长度 5</li><li>初始化两个指针，一开始均指向下标为 0 的元素，一开始，保持 left 不动，而 right 向右移动。根据遍历到的字符串的字符来修改欠债表和 all 的值</li></ol><blockquote><p>当遍历到 ‘s’ 字符时，由于 t 字符串中没有对应的字符，所以在欠债表中添加一条记录 s：-1 ，不修改 all ；</p><p>遍历到 ‘a’ 字符时，由于 t 字符串中含有 a ，所以修改欠债表和 all 的值，将欠债表中 a 记录对应的值 - 1，然后<strong>如果此时 a 记录对应的值不小于 0 ，那么我们称这次修改为 有效修改</strong>，所以我们将 all 的值 -1</p><p>遍历到 ‘b’ 时，此时修改欠债表和 all 的值；</p><p>遍历到 ‘s’ 时，修改欠债表中 s 对应的值为 -2 ，不修改 all</p><p>遍历到第二个 ‘b’ 时，修改欠债表和 all 的值，在遍历到第三个 ‘b’ 时，由于修改欠债表后，b 对应的值变为 -1 ，所以此时不是有效修改，不修改 all 的值</p><p>遍历到第二个 a 后，此时 all 的值已经变为 0 ，同时 right 来到第二个 ‘a’ 下。</p></blockquote><ol start="3"><li>当 <code>all</code> 变为 0 时，我们就找到了题目的一个解 [left ,right ]，此时我们保持 right 不动，让 left 后移，如果 left 后移后不会使 s 字符串变为“欠款”状态（欠债表中有记录值大于 0）</li></ol><blockquote><p>如果不会，那么让 left 继续后移</p><p>如果会，那么让 right 继续往后移，直到重新恢复未欠款状态</p></blockquote><ul><li>这样我们就可以得到所有的答案，之后在所有的答案中选出一个最短的即可。</li></ul><h3 id="12-3、解题代码"><a href="#12-3、解题代码" class="headerlink" title="12.3、解题代码"></a>12.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 t 的长度大于 s 的长度，那么直接返回空串</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; t.length()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>[] strArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] targetArray = t.toCharArray();</span><br><span class="line">    <span class="comment">// 欠债表，初始化为 target 中字符及其出现次数</span></span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : targetArray) &#123;</span><br><span class="line">        map[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 欠债总额，初始化为 target 字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> all = targetArray.length;</span><br><span class="line">    <span class="comment">// 初始化双指针</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 答案窗口，用于记录最佳答案的左右下标</span></span><br><span class="line">    <span class="keyword">int</span> resultLeft = -<span class="number">1</span>, resultRight = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; strArray.length) &#123;</span><br><span class="line">        <span class="comment">// 根据遍历到的字符修改欠债表中的记录</span></span><br><span class="line">        map[strArray[right]]--;</span><br><span class="line">        <span class="comment">// 如果修改后对应记录的值大于等于 0 ，那么说明这次修改是有效修改</span></span><br><span class="line">        <span class="keyword">if</span> (map[strArray[right]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            all--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 all 为 0 ，证明找到了一个答案</span></span><br><span class="line">        <span class="keyword">if</span> (all == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果此时左指针指定的值在欠债表中为负数，那么证明让左指针后移</span></span><br><span class="line">            <span class="comment">// 也不会变为负债状态，所以直接让左指针后移</span></span><br><span class="line">            <span class="comment">// 同时修改欠债表中的内容</span></span><br><span class="line">            <span class="keyword">while</span> (map[strArray[left]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 修改欠债表中的内容</span></span><br><span class="line">                map[strArray[left]]++;</span><br><span class="line">                <span class="comment">// 左指针后移</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果此时左右指针形成的窗口大小小于 minLen 的值</span></span><br><span class="line">            <span class="comment">// 或者 minLen == -1</span></span><br><span class="line">            <span class="keyword">if</span> (minLen == -<span class="number">1</span> || minLen &gt; right - left + <span class="number">1</span>) &#123;</span><br><span class="line">                minLen = right - left + <span class="number">1</span>;</span><br><span class="line">                resultLeft = left;</span><br><span class="line">                resultRight = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当以当前 left 为开头的结果弄完后，需要将 left 后移</span></span><br><span class="line">            <span class="comment">// 寻找下一个以 left 为开头的结果</span></span><br><span class="line">            all++;</span><br><span class="line">            map[strArray[left++]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLen == -<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(resultLeft, resultRight + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13、汉诺塔问题"><a href="#13、汉诺塔问题" class="headerlink" title="13、汉诺塔问题"></a>13、汉诺塔问题</h2><h3 id="13-1、题目描述"><a href="#13-1、题目描述" class="headerlink" title="13.1、题目描述"></a>13.1、题目描述</h3><blockquote><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:</p></blockquote><ul><li>每次只能移动一个盘子;</li><li>盘子只能从柱子顶端滑出移到下一根柱子;</li><li>盘子只能叠在比它大的盘子上。</li></ul><blockquote><p>请编写程序，将所有盘子从第一根柱子移到最后一根柱子。</p></blockquote><h3 id="13-2、解题思路"><a href="#13-2、解题思路" class="headerlink" title="13.2、解题思路"></a>13.2、解题思路</h3><ul><li>使用递归来解决这个问题，我们需要将 A 中的 A.size() 个盘子从 source 柱（A 集合所表示的柱子）移动到 target 柱（C 集合所表示的柱子）</li><li>先将 <code>A.size() - 1</code> 个从 source 柱借助 target 柱移动到 help 柱，然后此时 source 柱上只剩下一个柱子，此时直接将 source 柱子上的最后一个盘子直接从 source 柱放到 target 柱上即可。</li><li>将存放了 <code>A.size() - 1</code> 个柱子的 help 柱看为新的 source 柱，重复以上步骤，借助 target 柱将 <code>A.size() - 2</code> 个盘子放到原来的 source 柱，然后将第 <code>A.size() - 1</code> 个盘子放到 target 柱…</li><li>重复以上步骤，问题就得到了解决。</li></ul><h3 id="13-3、解题代码"><a href="#13-3、解题代码" class="headerlink" title="13.3、解题代码"></a>13.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">    move(A.size(), A, B, C);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> size, List&lt;Integer&gt; source, List&lt;Integer&gt; help, List&lt;Integer&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接将 source 柱子上的盘子弹出，放在 target 柱子上</span></span><br><span class="line">        target.add(source.remove(source.size() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先将上面的 size - 1 个盘子，借助 target 移动到中间的 help 柱子上</span></span><br><span class="line">    move(size - <span class="number">1</span>, source, target, help);</span><br><span class="line">    <span class="comment">// 将最下面的第 size 个盘子，直接从 source 移动到 target </span></span><br><span class="line">    target.add(source.remove(source.size() - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 将存放着 size - 1 个盘子的 help 柱看为新的 source 柱，我们需要将这 size - 1 个盘子移动到 target 柱</span></span><br><span class="line">    move(size - <span class="number">1</span>, help, source, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14、二叉树的锯齿形层序遍历"><a href="#14、二叉树的锯齿形层序遍历" class="headerlink" title="14、二叉树的锯齿形层序遍历"></a>14、二叉树的锯齿形层序遍历</h2><h3 id="14-1、题目描述"><a href="#14-1、题目描述" class="headerlink" title="14.1、题目描述"></a>14.1、题目描述</h3><blockquote><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p></blockquote><ul><li>示例</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211028231325.png" alt="image-20211027201123446"></p><blockquote><p>返回：</p><p>[</p><p>​ [a],</p><p>​ [c,b],</p><p>​ [d,e,f],</p><p>​ [j,i,h,g]</p><p>]</p></blockquote><h3 id="14-2、解题思路"><a href="#14-2、解题思路" class="headerlink" title="14.2、解题思路"></a>14.2、解题思路</h3><ul><li>使用一个双端队列来解决这道题</li></ul><blockquote><p>在将一层节点全部加入队列之后，我们需要记录一个 size ，来让我们知道什么时候该更改遍历的顺序</p></blockquote><ol><li>当节点从左往右遍历时，我们将节点从队列尾部放入，从队列头部弹出</li></ol><blockquote><p>当一个节点从队列头部弹出时，我们先将该节点的左子树加入队列，然后将它的右孩子加入队列，注意，此时需要将子节点从尾部放入</p></blockquote><ol start="2"><li>节点从右往左遍历时，我们将节点从队列头部放入，从队列尾部弹出</li></ol><blockquote><p>当一个节点从队列尾部弹出时，我们先将该节点的右子树加入队列，然后将其左子树加入队列，注意，此时需要将子节点从头部放入</p></blockquote><ul><li>假设在一个双端队列中存放着 4 个元素，它们是二叉树中某一层的所有元素，此时的方向是从左往右遍历，同时它们也存在子节点，情况如下</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211028231326.png" alt="image-20211027203723688"></p><ol><li>确定 size 为 4</li><li>由于是从左往右遍历，所以需要将节点从 头 弹出，同时先加左节点再加右节点，需要从尾部加入</li></ol><blockquote><p>将 a 弹出，同时将 L 节点从尾巴加入到队列中，size – ，此时队列中元素从左到右依次为：<code>b c d L</code></p><p>将 b 弹出，同时将 M N 依次从尾部加入到队列中，size – ，此时队列元素从左到右依次为：<code>c d L M N</code></p><p>当 c、d 依次弹出后，队列中的元素变为 <code>L M N O P Y Z</code></p></blockquote><ol start="3"><li>当 c、d 弹出后，由于 size == 0 ，所以表示当前层已经遍历完毕，我们需要调换遍历顺序，此时元素应该从尾部弹出，同时添加子节点时先添加右节点，后加左节点，子节点从头部加入。</li></ol><blockquote><p>此时弹出的顺序为 <code>Z Y P O N M L</code></p></blockquote><h3 id="14-3、解题代码"><a href="#14-3、解题代码" class="headerlink" title="14.3、解题代码"></a>14.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 开始前，先将根节点加入到双端队列中</span></span><br><span class="line">    deque.add(root);</span><br><span class="line">    <span class="comment">// 如何判断一层已经遍历完，使用一个 size 遍历来判断</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历方向，一开始为从左往右</span></span><br><span class="line">    <span class="keyword">boolean</span> leftDirection = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">        size = deque.size();</span><br><span class="line">        List&lt;Integer&gt; curLevel = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (leftDirection) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                <span class="comment">// 从左往右遍历时，节点从头弹出</span></span><br><span class="line">                TreeNode cur = deque.pollFirst();</span><br><span class="line">                curLevel.add(cur.val);</span><br><span class="line">                <span class="comment">// 先将左节点，后加右节点，从尾巴加入</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    deque.addLast(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    deque.addLast(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// 从右往左遍历，节点从尾部弹出</span></span><br><span class="line">                TreeNode cur = deque.pollLast();</span><br><span class="line">                curLevel.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    deque.addFirst(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    deque.addFirst(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(curLevel);</span><br><span class="line">        <span class="comment">// 改变遍历方向</span></span><br><span class="line">        leftDirection = !leftDirection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15、填充每个节点的下一个右侧节点指针"><a href="#15、填充每个节点的下一个右侧节点指针" class="headerlink" title="15、填充每个节点的下一个右侧节点指针"></a>15、填充每个节点的下一个右侧节点指针</h2><h3 id="15-1、题目描述"><a href="#15-1、题目描述" class="headerlink" title="15.1、题目描述"></a>15.1、题目描述</h3><blockquote><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。</li><li>如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</li><li>初始状态下，所有 next 指针都被设置为 NULL。</li></ul><h3 id="15-2、解题思路"><a href="#15-2、解题思路" class="headerlink" title="15.2、解题思路"></a>15.2、解题思路</h3><ul><li>可以利用一个队列，按照层序遍历的原理将遍历到的每一个节点都连起来</li><li>创建一个单向的队列，这个单向队列中的元素为 Node 对象</li></ul><blockquote><p>Node 类定义如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    Node next;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MyQueue 实现如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node head;</span><br><span class="line">    <span class="keyword">public</span> Node tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断这个单向队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向单向队列中添加元素的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果此时队列为空，那么由于 cur 是队列中的唯一元素，那么头和尾都是它</span></span><br><span class="line">            head = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列不为空，那么证明该队列存在一个尾巴</span></span><br><span class="line">        <span class="comment">// 需要将原来尾巴的 next 指向新添加的元素</span></span><br><span class="line">        tail.next = cur;</span><br><span class="line">        <span class="comment">// 然后这个新添加进来的元素变为新尾巴</span></span><br><span class="line">        tail = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? <span class="keyword">null</span> : head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 使用一个变量保存 head， 队列从尾部进，头部出</span></span><br><span class="line">        Node result = head;</span><br><span class="line">        <span class="comment">// 队列的头指针后移</span></span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="comment">// 然后让 result.next 指向空</span></span><br><span class="line">        result.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以下面的树为例，先将根加入到队列中，此时队列中只有 <code>a</code></li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211028231327.png" alt="image-20211028200447546"></p><ol><li><p>此时队列不为空，将 a 节点弹出，然后如果它的左节点不为空，那么先将它的左节点加入到队列中；</p></li><li><p>如果右节点不为空，那么将它的右节点加入到队列中</p></li></ol><blockquote><p>弹出 a 后，因为它的左右节点均不为空，所以 b 和 c 会被加入到队列中，所以 b 的next 域会置为 c ，也就是说 b 的 next 已经填充为了 c ，此时队列中的值为 <code>b c</code></p></blockquote><ol start="3"><li>此时队列不为空，那么会先弹出 b ，然后将 d、e 加入到队列中，此时 d 的 next 域被置为了 e ，当两个节点都被弹出后，队列中的值为 <code>d -&gt; e -&gt; f -&gt; g</code></li></ol><h3 id="15-3、解题代码"><a href="#15-3、解题代码" class="headerlink" title="15.3、解题代码"></a>15.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 记录当前队列这一层的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">            <span class="comment">// 从队头拿出元素</span></span><br><span class="line">            Node node = queue.poll();</span><br><span class="line">            <span class="comment">// 进行连接，当 i 小于 size - 1 时进行连接</span></span><br><span class="line">            <span class="comment">// 即这一层的最后一个元素的 next 应该为空</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                node.next = queue.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将它的左右节点加入到队列中</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16、买卖股票的最佳时机-I"><a href="#16、买卖股票的最佳时机-I" class="headerlink" title="16、买卖股票的最佳时机 I"></a>16、买卖股票的最佳时机 I</h2><h3 id="16-1、题目描述"><a href="#16-1、题目描述" class="headerlink" title="16.1、题目描述"></a>16.1、题目描述</h3><blockquote><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 i 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h3 id="16-2、解题思路"><a href="#16-2、解题思路" class="headerlink" title="16.2、解题思路"></a>16.2、解题思路</h3><ul><li>如果拥有的股票必须在 i 时间段卖出，那么在 <code>min&#123;nums[0:i]&#125;</code> 时段买入利润最大</li><li>遍历数组，在每一个位置根据上面的规则求出在 i 位置能获取利润的最大值，然后在这些最大值中再求一个最大值，就得到了我们想要的答案</li></ul><h3 id="16-3、解题代码"><a href="#16-3、解题代码" class="headerlink" title="16.3、解题代码"></a>16.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// nums[0:i] 这一段上的最小值，初始化为 0 </span></span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取数组 [0:i] 这一段数据的最小值</span></span><br><span class="line">        min = Math.min(min, prices[i]);</span><br><span class="line">        <span class="comment">// 使用当前卖出价格 - [0:i] 上的最小值</span></span><br><span class="line">        <span class="comment">// 就得到了在当前位置所能获取的最大利润</span></span><br><span class="line">        result = Math.max(result, prices[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17、买卖股票的最佳时机-II"><a href="#17、买卖股票的最佳时机-II" class="headerlink" title="17、买卖股票的最佳时机 II"></a>17、买卖股票的最佳时机 II</h2><h3 id="17-1、题目描述"><a href="#17-1、题目描述" class="headerlink" title="17.1、题目描述"></a>17.1、题目描述</h3><blockquote><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><ul><li><strong>示例 1:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><ul><li><strong>示例 2:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><h3 id="17-2、解题思路"><a href="#17-2、解题思路" class="headerlink" title="17.2、解题思路"></a>17.2、解题思路</h3><ul><li>对于所有 i ，如果 <code>prices[i] &gt; prices[i - 1]</code> ，那么将 <code>prices[i] - prices[i - 1]</code> 的值累加到 result 中</li></ul><blockquote><p>因为此时可以进行无数次交易，因为如果满足 <code>prices[i] &gt; prices[i - 1]</code> ，那么证明在 i - 1 位置买入，在 i 位置卖出有利可图，所以我们只需要将每一个位置的利润都累加起来，就可以得到最终利润。</p></blockquote><h3 id="17-3、解题代码"><a href="#17-3、解题代码" class="headerlink" title="17.3、解题代码"></a>17.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i - <span class="number">1</span>] &lt; prices[i]) &#123;</span><br><span class="line">            result += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18、买卖股票的最佳时机-III"><a href="#18、买卖股票的最佳时机-III" class="headerlink" title="18、买卖股票的最佳时机 III"></a>18、买卖股票的最佳时机 III</h2><h3 id="18-1、题目描述"><a href="#18-1、题目描述" class="headerlink" title="18.1、题目描述"></a>18.1、题目描述</h3><blockquote><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。<strong>你最多可以完成 两笔 交易</strong>。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><h3 id="18-2、解题思路"><a href="#18-2、解题思路" class="headerlink" title="18.2、解题思路"></a>18.2、解题思路</h3><ul><li><strong>在 i 位置卖出第二支股票</strong>，如何在 i 位置卖出第二支股票时，获得最大收益？</li></ul><blockquote><p>我们需要考虑两个条件，即在 [0,i - 1] 位置中卖出第一支股票时，获得最大利润，同时在卖出后以一个最有利的低价买进第二支股票。</p></blockquote><ol><li>在 [0, i - 1] 选择一个合适的卖出时机 x ，在 x 卖出第一支股票时，获得利润 <code>a</code></li><li>在 [x + 1,i - 1] 中选择一个合适的买入时机以价格 <code>b</code> 买入第二支股票</li></ol><blockquote><p>我们要求 <code>a</code> - <code>b</code> 最大</p></blockquote><ul><li><strong>此时在 i 位置卖出第二支股票，能得到的全局收益就为上一步中获取的 Max(<code>a</code> - <code>b</code>) 与当前位置股票价格的和</strong></li></ul><h3 id="18-3、解题代码"><a href="#18-3、解题代码" class="headerlink" title="18.3、解题代码"></a>18.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果数组长度小于 2 ，那么直接返回 0 即可</span></span><br><span class="line">    <span class="comment">// 当数组只存在一个元素时，那么此时两次买入，两次卖出的时机都在 0 位置</span></span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个变量表示第一次卖出，同时买入第二支股票后得到的利润最大值</span></span><br><span class="line">    <span class="comment">// 设第一次卖出后赚得的利润为 a ，第二次买入时花费的钱为 b</span></span><br><span class="line">    <span class="comment">// 那么这个变量的意义就是 max(a - b)</span></span><br><span class="line">    <span class="keyword">int</span> firstDoneMinusBuyMax = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 卖出第一支股票获取的最大收益</span></span><br><span class="line">    <span class="keyword">int</span> firstDoneMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 0 - i 位置的价格最小值</span></span><br><span class="line">        min = Math.min(min, prices[i]);</span><br><span class="line">        <span class="comment">// 第一次卖出股票且第二次买入股票后获取的纯利润 + 当前 i 位置卖出的价格，就是两次交易的利润总和</span></span><br><span class="line">        <span class="comment">// 拿这个数和 result 对比</span></span><br><span class="line">        result = Math.max(result, firstDoneMinusBuyMax + prices[i]);</span><br><span class="line">        firstDoneMax = Math.max(firstDoneMax, prices[i] - min);</span><br><span class="line">        firstDoneMinusBuyMax = Math.max(firstDoneMinusBuyMax, firstDoneMax - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19、二叉树的最大路径和"><a href="#19、二叉树的最大路径和" class="headerlink" title="19、二叉树的最大路径和"></a>19、二叉树的最大路径和</h2><h3 id="19-1、题目描述"><a href="#19-1、题目描述" class="headerlink" title="19.1、题目描述"></a>19.1、题目描述</h3><blockquote><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，<strong>且不一定经过根节点</strong>。</p><p><strong>路径和 是路径中各节点值的总和</strong>。</p><p>给你一个二叉树的根节点 root ，返回其 <strong>最大路径和</strong> 。</p></blockquote><ul><li>示例一</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure><h3 id="19-2、解题思路"><a href="#19-2、解题思路" class="headerlink" title="19.2、解题思路"></a>19.2、解题思路</h3><ul><li><p>对于一棵以 x 节点为头节点的树（x 不一定为整棵树的根节点，可以是某棵子树的根节点），它的最大路径和可能存在以下几种可能性</p></li><li><p>它的最大路径和与 x 节点无关，此时它的最大路径和是 x 节点内某一棵更小的子树的最大路径和</p></li></ul><blockquote><p>比如，在示例二中的树中，以 <code>-10</code> 为根节点的树它的最大路径和与 <code>-10</code> 无关，而是它的一棵子树（以 <code>20</code> 为根节点的子树）的最大路径和</p><p>此时结果为该节点<strong>左子树最大路径和与右子树最大路径和中的最大值</strong>，即 <code>maxPath(root) = Math.max &#123;maxPath(root.left), maxPath(root.right)&#125;</code></p></blockquote><ul><li>它的最大路径与 x 节点有关，此时yi x 为根节点的树的最大路径和有以下几种可能性</li></ul><ol><li>x 节点的最大路径和只包括 x 节点的值</li><li>x 节点的最大路径和包括 x 节点，我们记 x 节点的值为 <code>a</code> ，同时在以 <code>x.left</code> 为出发点的前提下，设 x.left 的最大路径和 <code>b</code> ，这个可能性下的值为 <code>a</code> + <code>b</code></li><li>x 节点的最大路径和包括 x 节点，我们记 x 节点的值为 <code>c</code>，同时在以 <code>x.right</code> 为出发点的前提下，设 x.right 的最大路径和 <code>d</code> ，这个可能性下的值为 <code>c</code> + <code>d</code></li><li>最后一种可能性，即上面两种可能的性的总和，此时最大路径和经过 x 节点同时与 x 的左右节点均关联。</li></ol><ul><li>根据递归套路，我们需要向子树要什么信息？</li></ul><ol><li>不要求从 x 出发时，子树 x 的最大路径和，在这个条件下，最大路径不必从 x 节点出发</li><li>要求从 x 出发时，子树 x 的最大路径和， 这个条件下，最大路径和中必须从 x 出发</li></ol><blockquote><p>比如在示例二的右子树中，如果要求从 20 出发，那么最大路径和为 20 + 15 ；如果不要求从 20 出发，那么最大路径和为 15 + 20 + 7</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><h3 id="19-3、解题代码"><a href="#19-3、解题代码" class="headerlink" title="19.3、解题代码"></a>19.3、解题代码</h3><ul><li>创建一个类，用于封装左右子树返回的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxPathSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxPathSumContainHead;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> path, <span class="keyword">int</span> head)</span> </span>&#123;</span><br><span class="line">        maxPathSum = path;</span><br><span class="line">        maxPathSumContainHead = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归过程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 只需要返回最大路径和信息即可，不要求一定以 root 为出发点</span></span><br><span class="line">    <span class="keyword">return</span> process(root).maxPathSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Info <span class="title">process</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分别向左向右获取信息</span></span><br><span class="line">    Info leftInfo = process(root.left);</span><br><span class="line">    Info rightInfo = process(root.right);</span><br><span class="line">    <span class="comment">//1 可能性 1 ，结果为左树的最大路径和（这个最大路径和不包括左子树的根节点）</span></span><br><span class="line">    <span class="keyword">int</span> firstCase = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) firstCase = leftInfo.maxPathSum;</span><br><span class="line">    <span class="comment">//2 可能性 2 ，同上，但结果为右子树</span></span><br><span class="line">    <span class="keyword">int</span> secondCase = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) secondCase = rightInfo.maxPathSum;</span><br><span class="line">    <span class="comment">//3 可能性 3 ，最大路径只包括 root 自己</span></span><br><span class="line">    <span class="keyword">int</span> thirdCase = root.val;</span><br><span class="line">    <span class="comment">//4 可能性 4 ，此时与 root 节点有关，root.val + 必须以 root.left 出发的最大路径和</span></span><br><span class="line">    <span class="keyword">int</span> fourthCase = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) fourthCase = root.val + leftInfo.maxPathSumFromHead;</span><br><span class="line">    <span class="comment">//5 可能性 5 ，此时与 root 节点有关，和上一个可能性类似，但是向右</span></span><br><span class="line">    <span class="keyword">int</span> fifthCase = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) fifthCase = root.val + rightInfo.maxPathSumFromHead;</span><br><span class="line">    <span class="comment">// 可能性 6 ，前面两种情况的集合</span></span><br><span class="line">    <span class="keyword">int</span> sixthCase = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; rightInfo != <span class="keyword">null</span>) sixthCase = root.val + leftInfo.maxPathSumFromHead + rightInfo.maxPathSumFromHead;</span><br><span class="line">    <span class="keyword">int</span> maxSum = Math.max(Math.max(Math.max(firstCase, secondCase), Math.max(thirdCase, fourthCase)), Math.max(fifthCase, sixthCase));</span><br><span class="line">    <span class="comment">// 必须为 root 为开头的最大路径和怎么求？</span></span><br><span class="line">    <span class="comment">// 只包含 root 、包含 root 同时只往左子树深入(fourthCase)、包含 root 同时只往右子树深入(fifthCase)</span></span><br><span class="line">    <span class="comment">// 上面三个值求一个最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxSumFromHead = Math.max(thirdCase, Math.max(fourthCase, fifthCase));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(maxSum, maxSumFromHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20、验证回文串"><a href="#20、验证回文串" class="headerlink" title="20、验证回文串"></a>20、验证回文串</h2><h3 id="20-1、题目描述"><a href="#20-1、题目描述" class="headerlink" title="20.1、题目描述"></a>20.1、题目描述</h3><blockquote><p>给定一个字符串，验证它是否是回文串，<strong>只考虑字母和数字字符，可以忽略字母的大小写</strong>。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释：&quot;amanaplanacanalpanama&quot; 是回文串</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释：&quot;raceacar&quot; 不是回文串</span><br></pre></td></tr></table></figure><h3 id="20-2、解题思路"><a href="#20-2、解题思路" class="headerlink" title="20.2、解题思路"></a>20.2、解题思路</h3><ul><li>使用双指针求解，左指针从下标 <code>0</code> 位置开始，右指针从下标 <code>s.length() - 1</code> 位置开始</li><li>只有当左右指针指向的值为有效字符时，才进行比较，循环时，左指针向右移，右指针向左移</li></ul><h3 id="20-3、解题代码"><a href="#20-3、解题代码" class="headerlink" title="20.3、解题代码"></a>20.3、解题代码</h3><ul><li>方法一，判断字符为有效字母或者有效数字的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidChar</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isLetter(ch) || isNumber(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLetter</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二，判断两个字符是否相等的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">char</span> ch1, <span class="keyword">char</span> ch2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNumber(ch1) || isNumber(ch2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ch1 == ch2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ch1 == ch2) || (Math.max(ch1, ch2) - Math.min(ch1, ch2) == <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断字符串是否为回文串的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValidChar(charArray[left]) &amp;&amp; isValidChar(charArray[right])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!equals(charArray[left], charArray[right])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left += isValidChar(charArray[left]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            right -= isValidChar(charArray[right]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21、单词接龙"><a href="#21、单词接龙" class="headerlink" title="21、单词接龙"></a>21、单词接龙</h2><h3 id="21-1、题目描述"><a href="#21-1、题目描述" class="headerlink" title="21.1、题目描述"></a>21.1、题目描述</h3><blockquote><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p></blockquote><ul><li>序列中第一个单词是 beginWord 。</li><li>序列中最后一个单词是 endWord 。</li><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典 wordList 中的单词。</li></ul><blockquote><p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><h3 id="21-2、解题思路"><a href="#21-2、解题思路" class="headerlink" title="21.2、解题思路"></a>21.2、解题思路</h3><ul><li>我们以 startWord 为基准，构造一个字典，字典中存放与 startWord 只有一字之差的字符串，我们将这些字符串称为 startWord 的下一层</li><li>以 startWord 下一层的元素为基准，分别构造它们各自的下一层元素，然后逐层构建下去</li><li>当 endWord 在字典中首次出现时，我们就找到了一条最短路径</li></ul><blockquote><p>如何创建这个字典？我们假设所有的词都只有小写字母</p></blockquote><ol><li>先将所有字符串都放在一个 HashSet 对象中</li><li>遍历基准词中的每一个字符，对它的每一次字符都进行一次变化，然后判断这个变化后的词在不在 HashSet 对象中</li></ol><blockquote><p>假设当前基准词为 <code>abc</code> ，那么我们先对 a 进行变化，变为 <code>bbc</code> ，<code>cbc</code> … <code>zbc</code> ，然后每变化一次，判断变化后的词是否在 HashSet 中</p><p>同理，将 <code>abc</code> 中的第二个字符进行变化，判断 <code>aac</code> … <code>azc</code> 是否在 HashSet 中，最后变化 c ，比较判断</p></blockquote><ol start="3"><li>在上一步变化判断的过程中，如果发现有<strong>变化后的字符串</strong>在 set 中（要求不和原始字符串相同），那么就将当前变化后的字符串加入到该基准词的下一层元素中。</li></ol><ul><li>同理，可以从 endWord 逐步向上推，在字典第一次出现 startWord 时，也找到了最短路径，所以我们可以这样进行优化</li></ul><blockquote><p>假设从 startWord 向下推时，发现它的字典中含有 n 个字符串，而从 endWord 向上推时，发现它的字典中含有 m 个字符串，而 n &gt; m ，那么我们此时从 endWord 向上推，如果 n &lt; m ，那么从 startWord 向下推。</p><p>每次都选择发散小的路走，可以少走一点弯路。</p></blockquote><h2 id="22、最长连续序列"><a href="#22、最长连续序列" class="headerlink" title="22、最长连续序列"></a>22、最长连续序列</h2><h3 id="22-1、题目描述"><a href="#22-1、题目描述" class="headerlink" title="22.1、题目描述"></a>22.1、题目描述</h3><blockquote><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p></blockquote><ul><li><strong>示例 1：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><ul><li><strong>示例 2：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><h3 id="22-2、解题思路"><a href="#22-2、解题思路" class="headerlink" title="22.2、解题思路"></a>22.2、解题思路</h3><ul><li>使用两张哈希表完成这道题，其中一张为头表（存放连续区间的头），一张为尾表（存放连续区间的尾）</li></ul><blockquote><p>以数组 {100,1,200,3,4,0,2} 为例</p></blockquote><ol><li><p>遍历到 100 时，由于 100 可以单独作为一个区间，所以在头表中插入键值对 100 - 1 ，表示以 100 作为连续区间头的区间当前只有一个数，同时在未表中插入键值对 100 - 1 ，表示以 100 作为连续区间尾的区间当前只有一个数</p></li><li><p>在尾表中查询有没有以 99 作为结尾的区间，发现没有，所以什么都不做；</p></li><li><p>在头表中查询有没有以 101 作为头部的区间，发现没有，所以什么都不做；</p></li><li><p>遍历到 1 ，同理在头尾表中插入 {1 - 1} ， 此时发现尾表中没有以 0 结尾的区间、在头表中没有以 2 为开头的区间，所以什么都不做</p></li><li><p>同理，200、3也是这样，加入头尾表后不做修改</p></li><li><p>遍历到 4 ，此时将 4 - 1 作为键值对插入头尾表中，然后遍历头表，发现此时没有以 5 作为开头的数据，所以什么都不做，遍历尾表，发现确实有以 3 作为结尾的序列，且序列长度为 1 ，现在我们需要将 3 -&gt; 3 序列变为 3 -&gt; 4 序列</p></li></ol><blockquote><p>将以 3 作为结尾的记录从尾表中删除，将以 4 作为开头的记录从头表中删除，同时修改头表中的记录，将 3 开头的序列长度从 1 改为 2 ，即头表中元素变为 { 3- 2}，同理尾表中记录也变为 {4 - 2}</p></blockquote><ol start="7"><li>…</li></ol><ul><li>使用 HashSet 解决这个问题，先将给的数组所有元素加入到 HashSet 中</li></ul><blockquote><p>对于一个连续序列，它一定存在一个左边界，如果一个序列以 num 作为左边界，那么 <code>num - 1</code> 就不应该存在与 HashSet 中；</p><p>因此，如果对于一个 num ，满足 <code>num - 1</code> 不在 HashSet 中，那么这个 num 就可以作为连续序列的左边界。</p></blockquote><ol><li>将数组中的所有元素加入到一个 HashSet 中</li><li>遍历数组，对于每一个元素 num ，进行判断，如果</li></ol><blockquote><p><code>num - 1</code> 存在于 HashSet 中，那么 num 不可能作为连续序列的左边界，直接跳过遍历下一个即可；</p><p><code>num - 1</code> 不存在于 HashSet 中，那么 num 会是一个左边界，我们再不断查找 <code>num + 1</code>、<code>num + 2</code> … 是否存在于 HashSet 中，来看以 <code>num</code> 作为左边界的连续序列有多长</p></blockquote><ol start="3"><li>遍历后，我们就知道了对于每一个可能的左边界，所括出的最长连续序列的长度，再在这些长度中取最大值即可</li></ol><h3 id="22-3、解题代码"><a href="#22-3、解题代码" class="headerlink" title="22.3、解题代码"></a>22.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将所有元素加入到集合中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 记录以 num 为左边界能括出的连续序列的最大长度</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (set.contains(num)) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将以 num 为左边界能括出的连续序列的最大长度的值与全局最大长度的值做对比，取大的</span></span><br><span class="line">            maxLen = Math.max(maxLen, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23、单词拆分"><a href="#23、单词拆分" class="headerlink" title="23、单词拆分"></a>23、单词拆分</h2><h3 id="23-1、题目描述"><a href="#23-1、题目描述" class="headerlink" title="23.1、题目描述"></a>23.1、题目描述</h3><blockquote><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p></blockquote><ul><li>说明</li></ul><ol><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ol><ul><li><strong>示例 1：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure><ul><li><strong>示例 2：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><h3 id="23-2、解题思路"><a href="#23-2、解题思路" class="headerlink" title="23.2、解题思路"></a>23.2、解题思路</h3><ul><li>查询要分解的 s 在字典表中能否找到一个前缀，以示例二为例，查询以 <code>a</code> 字符串作为前缀，发现字典表中没有 <code>a</code> 这个字符串，所以不可以以 <code>a</code> 作为前缀，同理 <code>ap</code> … <code>appl</code> 也不都可以作为前缀</li><li>查询 s 字符串是否能以 <code>apple</code> 作为前缀，此时发现 <code>apple</code> 存在于字典中，所以可以以 <code>apple</code> 作为前缀，此时问题转换为以求 s 中除去前缀之外的部分 <code>penapple</code> 能否被拆分的问题</li><li>将字符串所有的前缀枚举出来，然后在 s 中一次剔除这些前缀，问题就转换为了剩下字符串的拆分问题，最后将这些前缀的可能性都加起来，就得到了 s 字符串的所有拆分情况，问题就得到了解决。</li></ul><h3 id="23-3、解题代码"><a href="#23-3、解题代码" class="headerlink" title="23.3、解题代码"></a>23.3、解题代码</h3><ul><li>优化前的代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(s, <span class="number">0</span>, wordDict) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串中下标范围为 [index, s.length() - 1] 的部分，能够被 wordDict 分解的方法数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wordDict</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(String s, <span class="keyword">int</span> index, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 index 到达字符串最后时，证明已经找到了一种合理的分解方法，此时返回 1</span></span><br><span class="line">    <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// index 还没到最后</span></span><br><span class="line">    <span class="comment">// 找前缀，先找 index 这个单字符字符串能否作为前缀</span></span><br><span class="line">    <span class="comment">// 如果不行，那么就 index++ ，判断 [index,index + 1] 这个字符串能否作为前缀</span></span><br><span class="line">    <span class="comment">// 以此类推...，这个循环就是判断范围为 [index,end] 的字符串能否作为前缀</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = index; end &lt; s.length();end++) &#123;</span><br><span class="line">        <span class="comment">// 根据范围获取子串</span></span><br><span class="line">        String pre = s.substring(index, end + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果字典中含有这个子串，那么证明可以作为前缀</span></span><br><span class="line">        <span class="keyword">if</span> (wordDict.contains(pre)) &#123;</span><br><span class="line">            <span class="comment">// 如果这个子串可以作为前缀，那么需要判断剔除这个子串，字符串后面的串能否被 wordDict 成功分解</span></span><br><span class="line">            ways += process(s, end + <span class="number">1</span>, wordDict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化后的代码</li></ul><ol><li>将 List 换为 Set ，加快查重速度</li><li>将递归改为动态规划</li></ol><blockquote><p>在原来的递归参数中，只有一个参数是变化的，我们构造一个一维数组 <code>dp[i]</code> ，<code>dp[i]</code> 表示从下标 i 开始，字符串可以被 <code>wordDict</code> 中的字符串分解的次数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="comment">// 记录字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> size = s.length();</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组，dp[i] 表示字符串 s 从下标 index 后的子串能被分解的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case：如果走到字符串末尾，那么就得到了一种分解方法</span></span><br><span class="line">    <span class="comment">// 所以初始化 dp[size] = 1</span></span><br><span class="line">    dp[size] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// dp数组中，前一个下标的值可以从后一个下标的值中推出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = size - <span class="number">1</span>;index &gt;= <span class="number">0</span>;index--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = index;end &lt; s.length();end++) &#123;</span><br><span class="line">            <span class="comment">// 获取子串</span></span><br><span class="line">            String pre = s.substring(index, end + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(pre)) &#123;</span><br><span class="line">                ways += dp[end + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[index] = ways;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[0] 表示字符串 s 从下标 0 开始，能被 wordDict 分解的次数，如果这个值大于0 ，那么证明可以被分解</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24、寻找峰值"><a href="#24、寻找峰值" class="headerlink" title="24、寻找峰值"></a>24、寻找峰值</h2><h3 id="24-1、题目描述"><a href="#24-1、题目描述" class="headerlink" title="24.1、题目描述"></a>24.1、题目描述</h3><blockquote><p><strong>峰值元素是指其值严格大于左右相邻值的元素</strong>。</p><p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞ 。</p><p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p></blockquote><ul><li><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure></li><li><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">输出：1 或 5 </span><br><span class="line">解释：你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure></li></ul><h3 id="24-2、解题思路"><a href="#24-2、解题思路" class="headerlink" title="24.2、解题思路"></a>24.2、解题思路</h3><ul><li>如果 <code>nums[0] &gt; nums[1]</code> ，那么返回 0 ，因为 <code>nums[-1]</code> 为负无穷</li><li>如果 <code>nums[nums.length - 1] &gt; nums[nums.length - 2]</code> ，那么返回 0 ，因为 <code>nums[nums.length]</code> 为负无穷</li><li>如果上面的条件均不满足，那么证明此时 <code>nums[0] &lt; nums[1]</code> 且 <code>nums[nums.length - 2] &gt; nums[nums.length - 1]</code></li></ul><blockquote><p>从 0 –&gt; 1 ，呈现向上的趋势，而从倒数第二个到最后一个元素，呈下降的趋势，那么证明在数组中间必定存在一个拐点 M ，使得在 M 左边的元素小于 M 元素，而 M 右边的元素也小于 M 元素，这个 M 元素所在下标就是我们要找的值</p></blockquote><ul><li>使用二分查找，找到中间下标 mid 时，判断是否满足以下条件，即 <code>nums[mid] &gt; nums[mid - 1] &amp;&amp; nums[mid] &lt; nums[mid + 1]</code>，如果满足，直接返回 mid 即可</li><li>如果不满足以上条件，此时 <code>nums[mid - 1] &gt; nums[mid]</code> ，那么由于在 <code>mid - 1</code> –&gt; mid 之间呈现向下趋势，而 0 -&gt; 1 呈现向上趋势，那么 1 –&gt; <code>mid - 1</code> 之间一定存在一个拐点</li><li>如果 <code>nums[mid] &lt; nums[mid + 1]</code>，那么可以往右侧二分；</li><li>如果两个条件均满足，那么往左右二分都可以</li></ul><h3 id="24-3、解题代码"><a href="#24-3、解题代码" class="headerlink" title="24.3、解题代码"></a>24.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有一个元素时，直接返回 0 即可</span></span><br><span class="line">        <span class="comment">// 因为 nums[-1] 和 nums[2] 默认为负无穷</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[size - <span class="number">2</span>] &lt; nums[size - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> size - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行二分，对 [1, size - 2] 返回进行二分</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = size - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将唯一剩下的元素下标返回</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25、多数元素"><a href="#25、多数元素" class="headerlink" title="25、多数元素"></a>25、多数元素</h2><h3 id="25-1、题目描述"><a href="#25-1、题目描述" class="headerlink" title="25.1、题目描述"></a>25.1、题目描述</h3><blockquote><p>给定一个大小为 n 的数组，找到其中的多数元素。<strong>多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素</strong>。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p></blockquote><h3 id="25-2、解题思路"><a href="#25-2、解题思路" class="headerlink" title="25.2、解题思路"></a>25.2、解题思路</h3><ul><li>在这道题中，<strong>数组一定有一个数出现的次数大于 N / 2</strong>；</li><li><strong>一次在数组中删掉两个不同的数，当数组删无可删时，剩下的数就是要求的数</strong></li><li>使用一个 target 变量来表示<strong>靶子</strong>，用一个 hp 变量来表示<strong>靶子的血量</strong>，遍历数组</li></ul><ol><li>遍历到一个元素时，查看当前是否存在靶子，如果不存在，那么将当前的元素立为靶子，然后为这个靶子添加一点 hp</li><li>继续遍历，判断当前的元素是否和靶子相同，如果相同，那么让靶子血量 + 1</li><li>继续遍历，如果当前元素与靶子不同，那么将当前元素删除，同时将当前靶子的 hp - 1</li><li>最后剩下的数就是那个多数元素</li></ol><h3 id="25-3、解题代码"><a href="#25-3、解题代码" class="headerlink" title="25.3、解题代码"></a>25.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 靶子变量</span></span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 靶子血量</span></span><br><span class="line">    <span class="keyword">int</span> hp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前靶子的 hp 为 0 ，那么证明不存在靶子</span></span><br><span class="line">            target = num;</span><br><span class="line">            hp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">            hp++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hp--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回靶子</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26、逆波兰表达式求值"><a href="#26、逆波兰表达式求值" class="headerlink" title="26、逆波兰表达式求值"></a>26、逆波兰表达式求值</h2><h3 id="26-1、题目描述"><a href="#26-1、题目描述" class="headerlink" title="26.1、题目描述"></a>26.1、题目描述</h3><blockquote><p>根据<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求表达式的值。</p><p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p></blockquote><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><ol><li>示例一</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure><h3 id="26-2、解题思路"><a href="#26-2、解题思路" class="headerlink" title="26.2、解题思路"></a>26.2、解题思路</h3><ul><li>创建一个栈，然后遍历字符数组，如果遇到的是一个数字，那么直接压入栈中，如果是符号，那么从栈中弹出两个数，进行运算，然后将结果压入栈中，遍历完成后，最后还留在栈中的元素就是结果</li></ul><blockquote><p>对于减法和除法，需要用后弹出的数<code>减去/除以</code> 先弹出的数</p></blockquote><h3 id="26-3、解题代码"><a href="#26-3、解题代码" class="headerlink" title="26.3、解题代码"></a>26.3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(token) || <span class="string">&quot;-&quot;</span>.equals(token) || <span class="string">&quot;*&quot;</span>.equals(token) || <span class="string">&quot;/&quot;</span>.equals(token)) &#123;</span><br><span class="line">            <span class="comment">// 从栈中弹出两个数进行运算</span></span><br><span class="line">            compute(stack, token);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(Integer.valueOf(token));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">(Stack&lt;Integer&gt; stack, String token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = stack.pop();</span><br><span class="line">    <span class="keyword">int</span> next = stack.pop();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            res = pre + next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            res = next - pre;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">            res = next * pre;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            res = next / pre;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>数据结构与算法学习（十八）</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/3778135628.html">https://sutianxin.top/posts/3778135628.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-11-06</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-11-11</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%98%95Java/">☕Java</a><a class="post-meta__tags" href="/tags/%F0%9F%92%BB%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/">💻后端学习</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/blogImage/raw/master/img/20211106121506.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2617042707.html"><img class="prev-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211111234105.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构与算法学习（十九）</div></div></a></div><div class="next-post pull-right"><a href="/posts/4114983771.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20211024205022.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构与算法学习（十七）-负载均衡算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1128227004.html" title="Java应用学习（七）-回顾Mybatis和Spring MVC"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210430102830.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">Java应用学习（七）-回顾Mybatis和Spring MVC</div></div></a></div><div><a href="/posts/2938255980.html" title="Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210208120213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-12</div><div class="title">Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用</div></div></a></div><div><a href="/posts/913123791.html" title="Spring Cloud学习（七）-Spring Cloud Config"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210516192228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="title">Spring Cloud学习（七）-Spring Cloud Config</div></div></a></div><div><a href="/posts/2863462089.html" title="Spring Cloud学习（二）-OpenFeign微服务调用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504192527.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-11</div><div class="title">Spring Cloud学习（二）-OpenFeign微服务调用</div></div></a></div><div><a href="/posts/995752607.html" title="Spring Cloud学习（四）-Eureka服务注册中心"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210214225250.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-14</div><div class="title">Spring Cloud学习（四）-Eureka服务注册中心</div></div></a></div><div><a href="/posts/650479038.html" title="在线教育项目总结（二）-用户认证"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210205204706.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-05</div><div class="title">在线教育项目总结（二）-用户认证</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80"><span class="toc-text">1、判断字符是否唯一</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">1.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">1.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">1.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9"><span class="toc-text">2、字符串压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">2.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">2.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">2.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC"><span class="toc-text">3、字符串轮转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">3.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">3.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">3.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97"><span class="toc-text">4、字符串回文排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">4.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">4.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">4.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91"><span class="toc-text">5、一次编辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">5.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">5.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">5.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="toc-text">6、移除重复节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">6.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">6.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">6.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="toc-text">7、旋转矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">7.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">7.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">7.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8"><span class="toc-text">8、分割链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">8.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">8.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">8.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">9、回文链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">9.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">9.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">9.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-text">10、最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">10.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">10.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">10.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81Sqrt-x"><span class="toc-text">11、Sqrt(x)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">11.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">11.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">11.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-text">12、最小覆盖子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">12.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">12.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">12.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-text">13、汉诺塔问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">13.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">13.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">13.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">14、二叉树的锯齿形层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">14.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">14.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">14.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text">15、填充每个节点的下一个右侧节点指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">15.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">15.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">15.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-I"><span class="toc-text">16、买卖股票的最佳时机 I</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">16.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">16.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">16.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-text">17、买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">17.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">17.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">17.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III"><span class="toc-text">18、买卖股票的最佳时机 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">18.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">18.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">18.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">19、二叉树的最大路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">19.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">19.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">19.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">20、验证回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">20.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">20.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">20.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="toc-text">21、单词接龙</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">21.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">21.2、解题思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-text">22、最长连续序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">22.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">22.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">22.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-text">23、单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">23.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">23.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">23.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="toc-text">24、寻找峰值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#24-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">24.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">24.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">24.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-text">25、多数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#25-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">25.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">25.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">25.3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">26、逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">26.1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">26.2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">26.3、解题代码</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init({el:"#twikoo-wrap",envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai"})},e=()=>{twikoo.getCommentsCount({envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then(function(o){t.innerText=o[0].count}).catch(function(o){console.error(o)})};var n;n=!0,"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" data-lrctype="0" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_yegv7kt2bj.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.js"></script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><script src="https://www.luckyclover.top/rain.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"]):not([href="/contact/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>