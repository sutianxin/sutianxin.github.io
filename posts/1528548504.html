<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL高级学习（五）-MySQL学习补充 | Arno</title><meta name="keywords" content="🤓数据库"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL 的学习补充"><meta property="og:type" content="article"><meta property="og:title" content="MySQL高级学习（五）-MySQL学习补充"><meta property="og:url" content="https://sutianxin.top/posts/1528548504.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="MySQL 的学习补充"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165848.jpg"><meta property="article:published_time" content="2022-02-17T08:56:37.850Z"><meta property="article:modified_time" content="2022-02-17T09:01:12.425Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="🤓数据库"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165848.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/1528548504"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-02-17 17:01:12"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,a={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(a)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165848.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL高级学习（五）-MySQL学习补充</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-17T08:56:37.850Z" title="发表于 2022-02-17 16:56:37">2022-02-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-17T09:01:12.425Z" title="更新于 2022-02-17 17:01:12">2022-02-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL%E9%AB%98%E7%BA%A7/">MySQL高级</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.8k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、MySQL-的日志"><a href="#一、MySQL-的日志" class="headerlink" title="一、MySQL 的日志"></a>一、MySQL 的日志</h1><blockquote><p>在任何一款数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种时间。</p><p>在 MySQL 中，有 4 种不同的日志，分别是<strong>错误日志</strong>、<strong>二进制日志（BINLOG 日志）</strong>、<strong>查询日志</strong>和<strong>慢查询日志</strong>，这些日志记录着数据库在不同方面的踪迹</p></blockquote><h2 id="1-1、错误日志"><a href="#1-1、错误日志" class="headerlink" title="1.1、错误日志"></a>1.1、错误日志</h2><blockquote><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld （MySQL 服务器）启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。</p></blockquote><ul><li><p><strong>当数据库出现任何故障导致无法正常使用时，可以首先查看此日志</strong>。</p></li><li><p>可以使用 –log-error[=file_name] 选项来指定 mysqld 保存错误日志文件的位置；如果没有指定 file_name 值，那么 mysqld 使用错误日志名 host_name.err（host_name 为主机名）并默认在参数 DATADIR （数据目录）指定的目录中写入日志文件。</p></li></ul><h2 id="1-2、二进制日志"><a href="#1-2、二进制日志" class="headerlink" title="1.2、二进制日志"></a>1.2、二进制日志</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><blockquote><p>二进制日志记录了<strong>所有的 DDL （数据定义语言）语句和 DML（数据操纵语言）语句</strong>，但是<strong>不包括数据查询语言</strong>。</p></blockquote><ul><li>语句以 <strong>事件</strong> 的形式保存，它描述了数据的更改过程</li><li>二进制日志对灾难时的数据回复和主从赋值起着极其重要的作用。</li></ul><blockquote><p>binlog 是 MySQL 的<strong>逻辑日志</strong>，并且由 Server 层进行记录，使用任何存储引擎的 MySQL 数据库都会记录 binlog 日志</p></blockquote><h3 id="2、日志的位置和格式"><a href="#2、日志的位置和格式" class="headerlink" title="2、日志的位置和格式"></a>2、日志的位置和格式</h3><ul><li>binlog 位置</li></ul><ol><li>当使用 <code>--log-bin[=file_name]</code> 选项启动时，mysqld 将包含所有更新数据的 SQL 命令写入日志文件。</li><li>如果没有给出 file_name 的值，那么日志默认名为主机名 + <code>-bin</code> ，如果给出了这个文件名，但是没有包含路径，那么文件会默认写入参数 DATADIR （数据目录）指定的目录</li></ol><ul><li>binlog 的格式</li></ul><blockquote><p>binlog 日志有三种存储格式，分别为 <strong>statement</strong> 、 <strong>row</strong> 和 <strong>mixed</strong> ，在 MySQL 5.7 后，默认值是 Row ，日志格式可以通过 <strong>binlog-format</strong> 参数指定</p></blockquote><h3 id="3、mysqlbinlog-工具"><a href="#3、mysqlbinlog-工具" class="headerlink" title="3、mysqlbinlog 工具"></a>3、mysqlbinlog 工具</h3><ul><li>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文件的文本格式，那么就会用到 mysqlbinlog 日志管理工具。</li><li>具体用法如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span><span class="bash"> mysqlbinlog [options] log-files1 log-files2...</span></span><br></pre></td></tr></table></figure><ul><li>其中 options 有许多选项，常用的如下：</li></ul><ol><li>-d，–database=name：指定数据库名称，只列出指定的数据库相关操作。</li><li>-o，–offset=#：忽略掉日志中的前 n 行命令</li><li>-r，–result-file=name：将输出的文本格式日志输出到指定文件</li><li>-s，–short-form：显示简单格式，忽略一些信息</li><li>–set-charset=char-name：在输出为文本格式时，在文件第一行加上 char-name ，这个选项在某些情况下装载数据时非常有用。</li><li>–start-datetime = name -stop-datatime=name：指定日期间隔内的所有日志</li><li>–start-position = # –stop-position = #：指定位置间隔内的所有日志。</li></ol><h3 id="4、日志的读取"><a href="#4、日志的读取" class="headerlink" title="4、日志的读取"></a>4、日志的读取</h3><blockquote><p>由于 binlog 以二进制方式存储，不能直接读取，需要用 mysqlbinlog 工具来查看，语法如下：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span><span class="bash"> mysqlbinlog log-file</span></span><br></pre></td></tr></table></figure><h3 id="5、binlog-的刷盘时机"><a href="#5、binlog-的刷盘时机" class="headerlink" title="5、binlog 的刷盘时机"></a>5、binlog 的刷盘时机</h3><ul><li>对于 InnoDB 存储引擎而言，只有在事务提交时才会记录 binlog ，此时记录还在内存中；</li><li>MySQL 使用 <code>sync_binlog</code> 参数控制 binlog 的刷盘时机，取值范围是 0 - N：</li></ul><ol><li>0：不去强制要求，由系统自行判断何时写入磁盘</li><li>1：每次 commit 的时候都要将 binlog 写入到磁盘</li><li>N：每 N 个事务，才会将 binlog 写入到磁盘中。</li></ol><blockquote><p>从上面可以看出，sync_binlog 最安全的设置是 1 ，这也是 MySQL 5.7 后的默认值。</p><p>但是在某种情况下也可以适当调大，牺牲一定的一致性来获取更好的数据库性能。</p></blockquote><h2 id="1-3、查询日志"><a href="#1-3、查询日志" class="headerlink" title="1.3、查询日志"></a>1.3、查询日志</h2><ul><li><p>查询日志记录了<strong>客户端</strong>的所有语句，而 binlog 不包含只查询数据的语句。</p></li><li><p>查询日志记录的格式是纯文本，因此可以直接进行读取。</p></li><li><p>对于访问频繁的系统，此日志对系统性能的影响较大，建议在一般情况下关闭</p></li></ul><h2 id="1-4、慢查询日志"><a href="#1-4、慢查询日志" class="headerlink" title="1.4、慢查询日志"></a>1.4、慢查询日志</h2><h3 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h3><blockquote><p>慢查询日志记录了包含所有执行时间超过参数 <strong>long_query_time</strong> （单位：秒）所设置值的 SQL 查询语句的日志</p><p><strong>注意：获取表锁定的事件不算作执行时间</strong></p></blockquote><h3 id="2、文件位置及格式"><a href="#2、文件位置及格式" class="headerlink" title="2、文件位置及格式"></a>2、文件位置及格式</h3><blockquote><p>当使用 <code>--log-slow-queries[=file_name]</code> 选项启动 mysqld 时，慢查询日志开始被记录。和前面几个日志一样，如果没有给定 file_name 的值，日志将写入参数 DATADIR 指定的路径下，默认文件名为 <code>host_name-slow.log</code></p></blockquote><h3 id="3、日志的读取"><a href="#3、日志的读取" class="headerlink" title="3、日志的读取"></a>3、日志的读取</h3><ul><li>和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。</li><li>查询一下参数 <strong>long_query_time</strong> 的值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">&#x27;%long&#x27;</span>;</span></span><br></pre></td></tr></table></figure><ul><li>设置 <strong>long_query_time</strong> 参数的值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">set</span> long_query_value = 2;</span></span><br></pre></td></tr></table></figure><ul><li>慢查询日志对于我们发现应用中有性能的 SQL 很有帮助，建议正常情况下，打开此日治并经常查看分析。</li></ul><h1 id="二、InnoDB-的事务日志"><a href="#二、InnoDB-的事务日志" class="headerlink" title="二、InnoDB 的事务日志"></a>二、InnoDB 的事务日志</h1><h2 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h2><ul><li><p>InnoDB 是一个支持事务的存储引擎，它利用<strong>回滚日志</strong>（redo log）和<strong>重做日志</strong>（undo log）实现事务，并实现 <strong>MVCC</strong>（多版本并发控制）</p></li><li><p>需要注意的是，<strong>undo log 不是 redo log 的逆向过程</strong>，它们两个都算是用来恢复的日志。</p></li></ul><ol><li>redo log 通常是<strong>物理日志</strong>，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，它用来恢复提交后的物理数据页（只能恢复到最后一次提交的位置）</li></ol><blockquote><p>如果数据发生了丢失，数据库可以根据 redo log 进行数据恢复。</p></blockquote><ol start="2"><li>undo log 通常是<strong>逻辑日志</strong>，用于回滚行记录到某个版本，当我们对记录做了变更操作时就会产生 undo 记录。</li></ol><blockquote><p>如何理解逻辑日志这个概念？</p><p>可以认为，当我们 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，而当我们 update 一条记录时，undo log 中会记录一条与其相反的 update 记录。</p></blockquote><h2 id="2-2、redo-log-和-binlog-的区别"><a href="#2-2、redo-log-和-binlog-的区别" class="headerlink" title="2.2、redo log 和 binlog 的区别"></a>2.2、redo log 和 binlog 的区别</h2><blockquote><p>redo log 不是二进制日志，虽然二进制日志中也记录了 InnoDB 表中的许多操作，也能实现重做的功能，但它们之间有很大差别。</p></blockquote><ul><li><strong>binlog 是由 MySQL 的 Server 层产生的</strong>，不管使用什么存储引擎，对数据库的修改都会产生二进制日志记录；而 <strong>redo log 是 InnoDB 存储引擎产生的</strong>，只记录使用了 InnoDB 引擎的表的修改。</li><li>binlog 是逻辑日志，而 redo log 是物理日志</li><li>binlog 在事务提交时一次性将缓存写入日志文件中（对于非事务表的操作，则是每次执行语句成功后就直接写入）。而后者是在对数据修改前就将缓存中的 redo log 进行写入，然后才对数据进行修改操作；</li></ul><blockquote><p>redo log 保证在发出事务提交指令时，先将缓存中的 redo log 写入磁盘，写入完成后再执行提交动作。</p></blockquote><ul><li>redo log 在事务执行过程中会不断地写入，而 binlog 是在事务最终提交前写入。</li><li>redo log 是循环写的，因为它地固定空间会被用完；binlog 是可以追加写的。</li></ul><h2 id="2-3、redo-log"><a href="#2-3、redo-log" class="headerlink" title="2.3、redo log"></a>2.3、redo log</h2><h3 id="1、redo-log-的组成"><a href="#1、redo-log-的组成" class="headerlink" title="1、redo log 的组成"></a>1、redo log 的组成</h3><ul><li>redo log 包括两部分：<strong>一是内存中的日志缓冲（redo log buffer），这一部分的数据是易丢失的</strong>；<strong>二是磁盘上的重做日志文件（redo log file），这部分日志是持久化的</strong>。</li></ul><blockquote><p>InnoDB 引擎对数据的更新，是先将更新记录写入到 redo log buffer 中，然后再更新数据，在缓冲中的数据会在系统空闲或者是按照设定的更新策略再将缓冲的内容刷新到磁盘中。</p><p>这就是所谓的预写式技术（Write Ahead Logging），这种技术可以大大降低 I / O 操作的频率，提升数据刷新的效率。</p></blockquote><h3 id="2、持久化的实现方式"><a href="#2、持久化的实现方式" class="headerlink" title="2、持久化的实现方式"></a>2、持久化的实现方式</h3><ul><li>在概念上，<strong>InnoDB 使用 <code>force log at commit</code> 机制实现事务的持久性</strong>，即在事务提交时，必须先将该事务的所有事务日志写入到磁盘上的 redo log file 和 undo log file 中进行持久化</li></ul><blockquote><p>每次将 log buffer 中的日志写入到日志文件的过程中都会调用一次操作系统的 <code>fsync</code> 操作。这是因为 MySQL 是工作在 用户空间上的，故 <code>log buffer</code> 处于用户空间的内存中，写入操作需要经过操作系统内核空间的 <code>os buffer</code> ，调用 <code>fsync()</code> 的作用就是将 os buffer 中的日志刷到磁盘的日志文件中。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217164821.png" alt="image.png"></p><ul><li>MySQL 支持用户自定义在 commit 时如何将 log buffer 中的日志刷到 log file 中。可以通过控制变量 <code>innodb_flush_log_at_trx_commit</code> 的值来决定，该值有 3 种值：0、1、2，默认为 1</li></ul><blockquote><p>这个值仅仅控制 commit 动作是否刷新 log buffer 到磁盘</p></blockquote><ol><li>当设置为 0 时，事务提交时不会将 log buffer 中的日志写入到 os buffer，而是每秒写入 os buffer 并调用 <code>fsync()</code> 写入到磁盘文件中。</li></ol><blockquote><p>也就是说，当 <code>innodb_flush_log_at_trx_commit</code> 值为 0 时，如果数据库系统崩溃，那么可能丢失一秒钟的数据。</p></blockquote><ol start="2"><li>当设置为 1 时，事务的每次提交都会将 log buffer 中的日志写入到 os buffer 并调用 <code>fsync()</code> 将内容刷到磁盘文件中。</li></ol><blockquote><p>这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都要写入磁盘，所以效率较低</p></blockquote><ol start="3"><li>当设置为 2 时，事务的每次提交都仅写入到 os buffer ，然后是每秒调用 <code>fsync()</code> 将 os buffer 中的内容写入到磁盘文件中。</li></ol><blockquote><p>如果只是 MySQL 数据库挂了，那么由于文件系统没有问题，所以对应的事务数据不会丢失。<strong>只有在数据库所在的主机操作系统损坏或者突然断电的情况下，数据库的事务数据可能丢失一秒的 事务数据。</strong></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217164826.png" alt="image.png"></p><ul><li>在主从复制结构中，要保证事务的持久性和一致性，需要对日志相关变量设置如下：</li></ul><ol><li>如果开启了 binlog ，那么需要设置 <code>sync_binlog = 1</code> ，每提交一次事务就将事务同步写到磁盘中</li><li>设置 <code>innodb_flush_log_at_trx_commit = 1</code> ，每提交一次事务就将 redo log 和 undo log 缓冲中的数据写到磁盘中。</li></ol><h3 id="3、为什么有了-binlog-还需要-redo-log-？"><a href="#3、为什么有了-binlog-还需要-redo-log-？" class="headerlink" title="3、为什么有了 binlog 还需要 redo log ？"></a>3、为什么有了 binlog 还需要 redo log ？</h3><blockquote><p><strong>redo log 是保证 MySQL <code>crash-safe</code> 的重要因素</strong>，在 MySQL 崩溃恢复后，主要依靠 redo log 和 binlog 来对 MySQL 进行数据恢复，从而保持数据的完整和一致。</p></blockquote><h3 id="4、InnoDB-的两阶段提交"><a href="#4、InnoDB-的两阶段提交" class="headerlink" title="4、InnoDB 的两阶段提交"></a>4、InnoDB 的两阶段提交</h3><ul><li>为了保证两份日志最终恢复到数据库的数据是一致的，所以采用两阶段提交的机制。</li></ul><blockquote><p>MySQL 中更新一条语句的流程，以蓝色表示执行器，白色表示存储引擎，假设我们现在要给 id 为 2 的员工涨 1000 工资</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165131.jpg" alt="未命名文件 (4)-20211212203941-cbmjqtq"></p><blockquote><p>具体流程如下：</p></blockquote><ol><li>server 层中的执行器先找引擎取 id 为 2 这一行，id 是主键，如果这一行所在的数据页在内存中，那么直接返回，否则需要先从磁盘读入内存，然后再返回</li><li>执行器拿到引擎给的行数据，对其工资 + 1000，再调用引擎接口写入这行新数据</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后通知执行器执行完成，可以提交事务。</li><li>执行器生成这个操作的 binlog ，并将 binlog 写入到磁盘中；</li><li>执行器调用引擎的提交事务接口，引擎将刚刚写入的 redo log 改为 commit 状态，完成更新。</li></ol><blockquote><p>redo log 的写入分为两个阶段，分别是 prepare 和 commit ，这就是两阶段提交。</p></blockquote><h3 id="5、MySQL-异常重启后如何保证数据完整？"><a href="#5、MySQL-异常重启后如何保证数据完整？" class="headerlink" title="5、MySQL 异常重启后如何保证数据完整？"></a>5、MySQL 异常重启后如何保证数据完整？</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165110.jpg" alt="未命名文件 (5)-20211212204631-j3vp1r0"></p><ul><li>在上图时刻 A 中，也即是写入 redo log 并处于 prepare 阶段以后、写 binlog 之前，MySQL 发生了崩溃：此时由于 binlog 还没写，redo log 也还处于 prepare 状态，所以崩溃恢复后，这个事务会被回滚。这个时候由于 binlog 还没写，所以也不会传播到备库，数据一致。</li><li>在上图时刻 B 中，也就是写完 binlog 后发生 crash ，如果 redo log 里面的事务存在 commit 标识（事务是完整的），则直接提交；如果 redo log 里面的事务只有 prepare 没有 commit ，那么需要判断对应事务在 binlog 中是否存在并完整，完整则提交事务，否则回滚事务。</li></ul><h2 id="2-4、undo-log"><a href="#2-4、undo-log" class="headerlink" title="2.4、undo log"></a>2.4、undo log</h2><h3 id="1、概述-2"><a href="#1、概述-2" class="headerlink" title="1、概述"></a>1、概述</h3><blockquote><p><code>undo log</code> 是逻辑日志，只是将数据库逻辑地恢复到原来的样子；所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p></blockquote><ul><li>undo log 主要有两个作用：提供<strong>事务回滚</strong>和<strong>多版本并发控制 (MVCC)</strong></li><li>当执行 rollback 或者数据库崩溃时，就可以从 undo log 中的逻辑记录中读取到对应的内容进行回滚，撤销未提交事务对数据库产生的影响。</li></ul><blockquote><p>有时候应用到行版本控制的时候，也是通过 undo log 来实现的：当读取的某一行被其他事务锁定时，它可以从 undo log 中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p></blockquote><h3 id="2、undo-log-的存储方式"><a href="#2、undo-log-的存储方式" class="headerlink" title="2、undo log 的存储方式"></a>2、undo log 的存储方式</h3><ul><li>InnoDB 存储引擎对 undo log 的管理采用段（segment）的方式，具体来说是一种名为回滚段（rollback segment）的数据结构</li></ul><blockquote><p>回滚段中有 1024 个 <code>undo log segment</code> ，以前旧版本只支持 1 个 rollback segment ，也就是说只能存储 1024 个 <code>undo log segment</code> ，MySQL 5.5 后，可以支持 128 个 rollback segment ，也就是说可以存储 128 * 1024 个 <code>undo log segment</code></p></blockquote><h3 id="3、工作原理"><a href="#3、工作原理" class="headerlink" title="3、工作原理"></a>3、工作原理</h3><ul><li><p>undo log 在事务开始前产生；事务在提交后，并不会立刻删除 undo log，InnoDB 会将该事务对应的 undo log 放入到删除列表中，后面会通过一个称为 purge thread 的后台线程进行回收处理。</p></li><li><p>undo log 在 MySQL InnoDB 存储引擎中用于实现 MVCC ，在事务未提交之前，undo log 保存了未提交之前的版本数据，所以 undo log 中的数据可以作为数据旧版本快照提供给其他事务进行快照读</p></li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165140.png" alt="image.png"></p><ol><li>事务 A 手动开启事务，执行更新操作，首先会将更新命中的数据先被分到 undo buffer 中。</li><li>事务 B 手动开启事务，执行查询操作，此时会从 undo 日志中读取数据返回，进行快照读。</li></ol><h2 id="2-5、MySQL-脏读、幻读和不可重复读"><a href="#2-5、MySQL-脏读、幻读和不可重复读" class="headerlink" title="2.5、MySQL 脏读、幻读和不可重复读"></a>2.5、MySQL 脏读、幻读和不可重复读</h2><h3 id="1、脏读、不可重复读、幻读的区别和出现场景"><a href="#1、脏读、不可重复读、幻读的区别和出现场景" class="headerlink" title="1、脏读、不可重复读、幻读的区别和出现场景"></a>1、脏读、不可重复读、幻读的区别和出现场景</h3><ul><li>脏读：事务读取到了其他事务还未提交的数据。</li><li>不可重复读：在<strong>同一次事务</strong>中前后查询不一致的问题（同一条数据前后不一致）</li><li>幻读：事务 A 先按照一定条件进行数据读取，期间事务 B 插入了相同搜索条件的新数据，事务 A 再按照原先条件进行搜索时，发现了事务 B 新插入的数据。（多了数据）</li></ul><h3 id="2、事务的隔离级别"><a href="#2、事务的隔离级别" class="headerlink" title="2、事务的隔离级别"></a>2、事务的隔离级别</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>会发生</td><td>会发生</td><td>会发生</td></tr><tr><td>READ COMMITTED</td><td>不会发生</td><td>会发生</td><td>会发生</td></tr><tr><td>REPEATABLE READ</td><td>不会发生</td><td>不会发生</td><td>会发生（InnoDB 除外）</td></tr><tr><td>SERIALIZABLE</td><td>不会发生</td><td>不会发生</td><td>不会发生</td></tr></tbody></table><h3 id="3、数据库并发场景"><a href="#3、数据库并发场景" class="headerlink" title="3、数据库并发场景"></a>3、数据库并发场景</h3><ul><li><strong>读 - 读</strong>：不存在任何问题，也不需要并发控制</li><li><strong>读 - 写</strong>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读、幻读、不可重复读</li><li><strong>写 - 写</strong>：有线程安全问题，可能会存在更新丢失问题</li></ul><h1 id="三、MVCC"><a href="#三、MVCC" class="headerlink" title="三、MVCC"></a>三、MVCC</h1><h2 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h2><ul><li>MVCC 全称 <code>Multi-Version Concurrency Control</code> ，即<strong>多版本并发控制</strong>，主要是为了提升数据库的并发性能，MyISAM 不支持事务，所以 MVCC 一般都是围绕 InnoDB 存储引擎展开的，MVCC 是基于<strong>数据版本</strong>对并发事务进行访问，作用于 RC 和 RR 两个隔离级别。</li><li>当同一行数据平行发生读写请求时，通常采用上锁的方式进行阻塞，<strong>而 MVCC 采用更好的方式去处理读 - 写请求，做到在发生读 - 写请求冲突时不用加锁</strong>。</li></ul><blockquote><p>这里的读指的是<strong>快照读</strong>，而不是<strong>当前读</strong>，当前读是一种加锁操作。</p></blockquote><h2 id="3-2、快照读和当前读"><a href="#3-2、快照读和当前读" class="headerlink" title="3.2、快照读和当前读"></a>3.2、快照读和当前读</h2><h3 id="1、当前读"><a href="#1、当前读" class="headerlink" title="1、当前读"></a>1、当前读</h3><blockquote><p>它读取的数据库记录，都是<strong>当前最新的版本</strong>，会对当前读取的数据进行<strong>加锁</strong>，防止其他事务修改数据。它是需要加<strong>悲观锁的一种操作</strong></p><p>以下的操作都是当前读：</p></blockquote><ol><li>select lock in share mode（共享锁）</li><li>select for update（排他锁）</li><li>update（排他锁）</li><li>insert（排他锁）</li><li>delete（排他锁）</li><li>串行化事务隔离级别</li></ol><h3 id="2、快照读"><a href="#2、快照读" class="headerlink" title="2、快照读"></a>2、快照读</h3><blockquote><p>快照读的实现<strong>基于多版本并发控制</strong>，既然是多版本，那么<strong>快照读读取到的数据不一定是当前最新的版本</strong>，有可能是<strong>之前历史版本的数据</strong>。</p><p>一般来说，<strong>普通的不加锁的 select 操作都是快照读（事务级别不可是串行化）</strong></p></blockquote><h3 id="3、MVCC-和快照读的关系"><a href="#3、MVCC-和快照读的关系" class="headerlink" title="3、MVCC 和快照读的关系"></a>3、MVCC 和快照读的关系</h3><ul><li>MVCC 是一个抽象概念，即<strong>维持一个数据的多个版本，从而使得读 - 写操作没有冲突</strong></li></ul><blockquote><p>在一个事务对数据进行写时，其他事务可以读取这条数据的另外版本，从而使同时进行的读写操作没有冲突。</p></blockquote><ul><li><strong>快照读是实现 MVCC 的一种方案</strong>。</li></ul><h2 id="3-3、MVCC-的实现原理"><a href="#3-3、MVCC-的实现原理" class="headerlink" title="3.3、MVCC 的实现原理"></a>3.3、MVCC 的实现原理</h2><blockquote><p>MVCC 主要通过 <strong>版本链</strong>、<strong>undo log</strong> 和 <strong>Read View</strong> 来实现的。</p></blockquote><h3 id="1、版本链"><a href="#1、版本链" class="headerlink" title="1、版本链"></a>1、版本链</h3><blockquote><p>我们数据库中的每行数据，除了我们肉眼看见的字段之外，还存在几个<strong>隐藏字段</strong>，它们分别是：</p></blockquote><ul><li><code>trx_id</code> （6 byte）</li></ul><blockquote><p>最近修改（修改 / 插入）<strong>事务 ID</strong>：记录<strong>修改 / 创建</strong>这条该数据行的<strong>事务 ID</strong></p></blockquote><ul><li><code>roll_pointer</code>（7 byte）</li></ul><blockquote><p><strong>回滚指针</strong>，它是实现版本 <strong>链</strong> 的关键，<strong>用于指向该数据行的上一个版本</strong>（该数据行上一个版本的记录存储在 rollback segment 中）</p></blockquote><ul><li><code>row_id</code>（6 byte）</li></ul><blockquote><p><strong>隐含的自增 ID（主键）</strong>：如果数据表没有主键，那么 InnoDB 引擎会自动以 <code>row_id</code> 产生一个聚簇索引</p></blockquote><ul><li><code>delete_flag</code></li></ul><blockquote><p><strong>删除标志，记录被更新或删除时并不代表真的删除，而是删除标志改变了</strong></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165149.png" alt="image.png"></p><blockquote><p>比如说，在 Person 表中存在一条记录如上，其中 row_id 是 InnoDB 为没有设定主键的表生成的隐式主键；trx_id 代表将数据行修改为以上状态的事务的 id ；而回滚指针指向该数据行上一个版本的指针。</p></blockquote><ol><li><code>roll_pointer</code> 配合 <code>undo log</code> ，指向该数据的上一个旧版本。</li><li>每次对该数据进行一次改动时，都会记录一条 <code>undo log</code> ，每条 <code>undo log</code> 都会有一个 <code>roll_pointer</code> 属性（INSERT 操作对应的 undo log 没有该属性，因为新数据并没有更早的版本），<strong>我们可以通过回滚指针将不同版本的同一行数据连起来，串成一个链表</strong>。</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165152.png" alt="image.png"></p><ol start="3"><li>对该记录每次更新后，都会将更新前的记录放到一条 undo log 中，这算是该记录的一个旧版本，随着更新次数的增多，所有版本都会被 <code>roll_pointer</code> 属性连接成一个链表，这个链表就是<strong>版本链</strong>，<strong>链表头节点就是当前记录的最新版本</strong>。</li></ol><blockquote><p>每个版本中还包含生成该版本时对应的事务 id ，这个信息在根据 Read View 判断版本可见性时会用到。</p></blockquote><h3 id="2、undo-log"><a href="#2、undo-log" class="headerlink" title="2、undo log"></a>2、undo log</h3><blockquote><p><code>undo log</code> 主要用于<strong>记录数据被修改之前的日志</strong>，<strong>在表信息进行修改前，会先将数据拷贝到 undo log 中</strong>。</p><p>当事务进行回滚时，可以通过 undo log 的记录进行数据还原。</p></blockquote><ul><li><code>undo log</code> 的用途</li></ul><ol><li>保证事务进行 rollback 时的原子性和一致性。</li><li>用于 MVCC 快照读的数据，在 MVCC 中，通过读取 undo log 中的<strong>历史版本数据</strong>，<strong>可以实现不同事务版本号都有自己独立的快照数据版本</strong>。</li></ol><ul><li><code>undo log</code> 的分类</li></ul><ol><li><code>insert undo log</code></li></ol><blockquote><p>代表事务在 insert 新纪录时产生的 <code>undo log</code> ，<strong>只在事务回滚时需要，并且在事务提交后就可以立即被丢弃</strong></p></blockquote><ol start="2"><li><code>update undo log</code> （主要）</li></ol><blockquote><p>事务在进行 <code>update / delete</code> 时产生的 undo log；不仅在事务回滚时需要，在快照读时也需要。</p><p>不能随便删除，只有当快照读或事务回滚不再涉及该日志时，对应的日志才会被 <code>purge</code> 线程统一删除。</p></blockquote><h3 id="3、Read-View"><a href="#3、Read-View" class="headerlink" title="3、Read View"></a>3、Read View</h3><blockquote><p>事务进行<strong>快照读</strong>操作时生成的<strong>读试图（Read View）</strong>，在该事务执行快照读的那一刻，会生成数据库系统当前的一个<strong>快照</strong></p><p><strong>当每个事务开启时，都会被分配一个 ID ，这个 ID 是递增的，所以越是新的事务，ID 值就越大</strong>。</p><p>Read View 主要是用来做<strong>可见性</strong>判断的，即当我们某个事务执行快照读时，对该记录创建一个 Read View 读视图，<strong>用它作为条件来判断当前事务能够看到那个版本的数据，能看到的数据可能是当前最新的数据，也有可能是该行记录的 undo log 里面某个版本的数据</strong>。</p></blockquote><ul><li>我们可以将一个 Read View 类比为 Java 中的一个对象，它存在以下几个重要的属性</li></ul><ol><li><code>m_ids</code>：表示在生成 <code>Read View</code> 的那一时刻，<strong>当前系统中活跃（未提交）的读写事务的 id 列表</strong></li><li><code>min_trx_id</code>：表示在生成 <code>Read View</code> 的那一时刻，<strong>当前系统活跃的读写事务中最小的事务 id，也就是 <code>m_ids</code> 中的最小值</strong></li><li><code>max_trx_id</code>：表示在生成 <code>Read View</code> 的那一时刻，应该分配给下一个事务的 id 值，也就是 <code>m_ids</code> 中的最大值 + 1，这个属性也称为预分配事务编号</li><li><code>creator_trx_id</code>：表示生成该 <code>Read View</code> 的事务的事务 id</li></ol><h3 id="4、读已提交的数据提取"><a href="#4、读已提交的数据提取" class="headerlink" title="4、读已提交的数据提取"></a>4、读已提交的数据提取</h3><blockquote><p>当隔离级别为 RC （读已提交）时，<strong>它会在每一次执行快照读时生成 Read View</strong>。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165201.png" alt="image.png"></p><ul><li>上述事务 4 进行了两次快照读，由于隔离级别为 RC ，所以在两次快照读时分别生成了两次快照</li></ul><ol><li>生成第一个快照时，此时 <code>trx_id</code> 为 1 的事务已经结束，还有活跃中的事务仅有 <code>trx_id</code> 分别为 2，3，4 的事务，故 <code>m_ids</code> 列表为 {2，3，4}，同时可以得到最小活跃事务 id 为 2 ，预分配事务 id 为 5（4 + 1），创建当前 Read View 的事务为 4</li><li>生成第二个快照时，此时 <code>trx_id</code> 为 1，2 的事务已经结束，还处于活跃状态的事务仅有 <code>trx_id</code> 分别为 3， 4 的事务，故 <code>m_ids</code> 列表为 {3,4}，同时可以得到最小活跃事务 id 为 3，预分配事务 id 为 5 ，创建当前 Read View 的事务为 4</li></ol><ul><li>版本链中数据的提取规则，将当前 Read View 中的信息代入到以下的数据访问规则中，当符合访问规则时，直接将对应数据返回</li></ul><ol><li>如果被访问的 <code>trx_id</code> 与 Read View 中的 <code>creator_trx_id</code> 相同，那么说明当前事务在访问自己修改的记录，可见，直接返回数据即可</li></ol><blockquote><p>这种情况类似在事务中执行了 update 后立即又执行了一次 select ，相同事务内当然可以看到修改后的数据。</p></blockquote><ol start="2"><li>如果被访问的 <code>trx_id</code> 小于 Read View 中的 <code>min_trx_id</code> 属性，那么证明该版本已经提交，可见，直接返回数据即可</li><li>如果被访问的 <code>trx_id</code> 大于等于 Read View 中的 <code>max_trx_id</code> ，表示该版本在生成 Read View 时还未开启，不可见，直接返回</li><li>如果被访问的 <code>trx_id</code> 满足 <code>min_trx_id &lt;= trx_id &lt;= max_trx_id</code> ，那么判断 <code>trx_id</code> 是否在 <code>m_ids</code> 中，如果在，那么说明生成 Read View 时，该版本事务尚未提交，所以该版本不可见；如果不存在，那么说明生成 Read View 时，该版本事务已经提交，可见，返回数据。</li></ol><ul><li>演示读已提交隔离级别的数据提取，此时版本链中的数据如下</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165207.png" alt="image.png"></p><ul><li>生成第一个快照时，快照的信息如下</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165212.png" alt="image.png"></p><ol><li>判断版本链事务 id <code>trx_id</code> (3) 是否等于 <code>creator_trx_id</code>(4)，如果成立说明数据就是自己这个事务更改的，可以访问；</li></ol><blockquote><p>这里不成立，所以向下继续匹配条件</p></blockquote><ol start="2"><li>判断版本链事务 id <code>trx_id</code> (3) 是否满足 <code>trx_id &lt; min_trx_id</code> (2) ？ 如果成立说明 <code>trx_id</code> 对应的事务已经提交，可以访问当前 <code>trx_id</code> 对应事务的数据；</li></ol><blockquote><p>这里条件不成立，所以向下继续匹配条件</p></blockquote><ol start="3"><li>判断版本链事务 id <code>trx_id</code> (3) 是否满足 <code>trx_id &gt; max_trx_id</code> (5) ？如果成立说明该事务是在 Read View 生成后才开启的，不允许访问</li></ol><blockquote><p>这里条件不成立，所以继续向下匹配</p></blockquote><ol start="4"><li>判断版本链事务 id <code>trx_id</code> (3) 是否满足 <code>min_trx_id &lt;= trx_id &lt;= max_trx_id</code> ，如果成立，那么需要进一步判断 <code>trx_id</code> 是否存在于 <code>m_ids</code> 中，如果存在，那么证明此时事务尚未提交，不可访问；如果不存在，那么证明此数据对应的事务已经提交了，可以访问</li></ol><blockquote><p>如果对于某一个 undo log 版本链中的元素，它的数据均不满足以上的条件，那么将顺着回滚指针往下找到更早的数据。然后继续带入到以上的数据中进行判断。</p><p>比如说，在 trx_id 为 3 的数据均不满足以上的条件后，我们按照回滚指针找到 trx_id 为 2 的那一个版本的数据，然后将这个数据代入 Read View 条件中进行匹配，最终我们会找到 <code>trx_id</code> 为 1 的数据，即 name 为 “张三” 的数据并返回。</p></blockquote><ul><li>生成第二个快照时，快照的信息如下</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165216.png" alt="image.png"></p><blockquote><p>此时再将 undo log 版本链中的数据信息一一与快照信息进行对比，最终会将 <code>trx_id</code> 为 2 的数据返回，此时读取到 name 为 “张小三” 的数据</p></blockquote><ul><li><strong>可以看到，在隔离级别为 RC 的情况下，由于每次快照读都会产生一个 Read View ，所以就会出现不可重复读现象</strong>。</li></ul><h3 id="5、可重复读的数据提取"><a href="#5、可重复读的数据提取" class="headerlink" title="5、可重复读的数据提取"></a>5、可重复读的数据提取</h3><blockquote><p>与 RC 不同的是，在隔离级别为可重复读的情况下，<strong>仅在第一次执行快照读时生成 Read View ，后续快照读会复用第一次快照读生成的 Read View</strong>，但这种情况存在特例。</p></blockquote><ul><li>在隔离级别为 RR 时，由于多次快照读之间使用的 <code>undo log</code> 版本链一致、<code>Read View</code> 一致，故而两次快照读的结果也应该一致，从而解决了不可重复读的问题。</li><li><strong>在隔离级别为 RR 时，InooDB 在绝大部分情况下可以避免幻读</strong>。</li></ul><blockquote><p>因为在 InnoDB 中，不是用锁，而是用 MVCC 来解决幻读问题。</p></blockquote><ol><li><strong>连续多次快照读，Read View 会产生复用，没有幻读问题</strong></li><li><strong>如果两次快照读之间存在当前读，且当前读修改的数据覆盖到其他事务新增的信息时，那么会导致 Read View 重新生成，从而产生幻读</strong>。</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165220.png" alt="image.png"></p><h1 id="四、MySQL-学习补充"><a href="#四、MySQL-学习补充" class="headerlink" title="四、MySQL 学习补充"></a>四、MySQL 学习补充</h1><h2 id="4-1、存储引擎补充"><a href="#4-1、存储引擎补充" class="headerlink" title="4.1、存储引擎补充"></a>4.1、存储引擎补充</h2><ul><li>为了管理方便，人们把 <strong>连接管理</strong> 、 <strong>查询缓存</strong> 、 <strong>语法解析</strong> 和 <strong>查询优化</strong> 这些并不涉及真实数据存储的功能划分为 <strong>MySQL server</strong> 的功能，把真实存取数据的功能划分为 <strong>存储引擎</strong> 的功能。</li><li>在 <strong>MySQL server</strong> 完成了查询优化后，只需按照生成的 <strong>执行计划</strong> 调用底层存储引擎提供的 API ，获取到数据后返回给客户端就可以了。</li><li>MySQL 中提到了存储引擎的概念。简而言之，<strong>存储引擎就是表的类型</strong> 。</li><li>存储引擎以前也叫做<strong>表处理器</strong>，后来改名为 存储引擎，<strong>它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作</strong>。</li><li>存储引擎的不同，决定了数据在磁盘中存储的文件格式的不同。</li></ul><h2 id="4-2、存储引擎介绍"><a href="#4-2、存储引擎介绍" class="headerlink" title="4.2、存储引擎介绍"></a>4.2、存储引擎介绍</h2><blockquote><p>二者不是替代关系。</p></blockquote><h3 id="1、InnoDB-引擎"><a href="#1、InnoDB-引擎" class="headerlink" title="1、InnoDB 引擎"></a>1、InnoDB 引擎</h3><blockquote><p>支持外键、支持事务、支持行级锁的存储引擎</p></blockquote><ul><li><p>MySQL 从 3.23.34a 开始就包含了 InnoDB 存储引擎，5.5 版本后就使用 InnoDB 作为默认的存储引擎。</p></li><li><p>InnoDB 被设计用来处理大量的短期事务，可以确保事务的完整提交和回滚。</p></li><li><p>除了增加和查询外，还需要更新、删除操作时，那么应该优先选择 InnoDB 存储引擎。</p></li><li><p><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 InnoDB 存储引擎。</strong></p></li><li><p>数据文件结构：</p><ul><li><code>表名.frm</code> 存储表结构（MySQL 8.0 时，合并在 <code>表名.ibd</code> 中）</li><li><code>表名.ibd</code> 存储数据和索引</li></ul></li><li><p>在之前的版本中，数据字典以元数据文件，非事务表等来存储。现在这些元数据文件被删除了，比如：<code>.frm</code> 、 <code>.par</code> 、 <code>.trn</code> 等都在 8.0 版本中都不存在了。</p></li><li><p>对比 MyISAM 存储引擎，<strong>InnoDB 写的处理效率要差一些</strong>，并且会占用更多的磁盘空间以保存数据和索引。</p></li><li><p>MyISAM 只缓存索引，不缓存真实数据；InnoDB 不仅要缓存真实数据还要缓存索引，<strong>所以 InnoDB 对内存要求较高</strong>，而且内存大小对性能有决定性的影响</p></li></ul><blockquote><p>为什么说 InnoDB 的处理效率要差一点？因为 InnoDB 将数据和索引都放在一起，所以在加载时，需要加载的数据比 MyISAM 多（MyISAM 将数据与索引分开存储）</p></blockquote><h3 id="2、MyISAM-引擎"><a href="#2、MyISAM-引擎" class="headerlink" title="2、MyISAM 引擎"></a>2、MyISAM 引擎</h3><blockquote><p>主要的非事务处理存储引擎</p></blockquote><ul><li><p>MyISAM 提供了大量的特性，包括全文索引、压缩和空间函数等，但 MyISAM 不支持事务、行级锁和外键，另外一个致命的缺陷就是：<strong>MyISAM 在崩溃后无法安全恢复</strong></p></li><li><p>它是 5.5 版本之前默认使用的存储引擎</p></li><li><p>MyISAM 的优势是访问速度快，一些对事务的完整性要求不高，或者以 <strong>SELECT 、 INSERT</strong> 为主的场景下可以考虑使用 MyISAM</p></li><li><p>MyISAM <strong>针对数据统计有额外的常数存储</strong>，所以 <code>select count(*)</code> 的查询效率非常高</p></li><li><p>数据文件结构：</p><ul><li><code>表名.frm</code> 存储表结构</li><li><code>表名.myd</code> 存储表数据（MyData）</li><li><code>表名.myi</code> 存储表索引（MyIndex）</li></ul></li><li><p>应用场景：只读应用或者以读为主的业务。</p></li></ul><h3 id="3、Archive-引擎"><a href="#3、Archive-引擎" class="headerlink" title="3、Archive 引擎"></a>3、Archive 引擎</h3><blockquote><p>用于数据存档</p></blockquote><ul><li><code>archive</code> 是存档的意思，它仅仅支持 <strong>插入</strong> 和 <strong>查询</strong> 两种功能</li><li>被插入的行数据不能再修改</li><li>拥有很好的压缩机制，使用 <code>zlib</code> 压缩库，在记录请求时实时地进行压缩，经常被用来作为仓库使用。</li><li><strong>使用行级锁，它适合用于存储大量地独立的作为历史记录的数据</strong>，插入效率高，但查询效率不高。</li><li>同样数据量下，<code>Archive</code> 表比 MyISAM 表要小 75%，比 InnoDB 小 83%</li></ul><h3 id="4、Memory-引擎"><a href="#4、Memory-引擎" class="headerlink" title="4、Memory 引擎"></a>4、Memory 引擎</h3><blockquote><p>将数据置于内存中的表</p></blockquote><ul><li>Memory 采用的逻辑介质是内存，响应速度非常快，但是当 <code>mysqld</code> 守护进程崩溃时数据就会丢失。</li><li>Memory 存储引擎要求存储的数据是长度不变的格式，比如说 Text 和 Blob 类型的数据就是不可用的（长度不固定）</li><li><strong>Memory 同时支持哈希索引和 B+ 树索引</strong>：<ul><li>哈希索引在进行等值查询时较快，但是对于范围查询要慢上许多</li><li>默认使用哈希索引，其速度要比使用 B+ 树索引快</li></ul></li><li>Memory 表至少要比 MyISAM 表快上一个数量级。</li><li>Memory 表的大小是受到限制的，主要取决于 <strong>max_rows</strong> 和 <strong>max_heap_table_size</strong> 两个参数，其中前者可以在创建表时指定，而后者默认为 16MB ，可以按需扩容。</li><li>Memory 表的数据文件和索引文件分开存储。</li><li>Memory 表的数据非常容易丢失，且生命周期较短，所以选择该引擎时需要特别小心</li><li>如果目标数据较小，而且需要非常频繁地进行访问，在这种场景下可以考虑使用 Memory 引擎</li></ul><blockquote><p>可以通过参数 <strong>max_heap_table_size</strong> 来控制 Memory 表的大小。</p></blockquote><ul><li>如果数据是临时的，而且必须立即可以得到，那么可以放在内存中</li><li>存储在 Memory 表中的数据的重要性和完整性不宜过高。</li></ul><h2 id="4-3、联合索引"><a href="#4-3、联合索引" class="headerlink" title="4.3、联合索引"></a>4.3、联合索引</h2><ul><li>在 MySQL 中，我们可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 <code>c2</code> 和 <code>c3</code> 列的大小进行排序，这个包含两层含义：<ul><li>先把各个记录和页按照 c2 列进行排序</li><li>在记录的 c2 列相同的情况下，采用 c3 列进行排序</li></ul></li></ul><blockquote><p>我们需要注意以下几点：</p></blockquote><ul><li>每条<strong>目录项记录</strong>都由 <strong>c2、c3 和页号</strong> 这三部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列进行排序</li><li>B+ 树的叶子节点处的用户记录由 <code>c2、c3</code> 和 <strong>主键</strong> 组成</li><li>联合索引本质上还是一个二级所以，和分别为 c2 和 c3 建立索引的表述是不同的，不同点如下：<ul><li>建立联合索引时，只会建立一棵 B+ 树</li><li>分别为 c2 和 c3 建立索引时，会分别以 c2 和 c3 列的大小为排序规则建立两棵 B+ 树</li></ul></li></ul><h2 id="4-4、InnoDB-的-B-树索引的注意事项"><a href="#4-4、InnoDB-的-B-树索引的注意事项" class="headerlink" title="4.4、InnoDB 的 B+ 树索引的注意事项"></a>4.4、InnoDB 的 B+ 树索引的注意事项</h2><h3 id="1、根页面位置万年不动"><a href="#1、根页面位置万年不动" class="headerlink" title="1、根页面位置万年不动"></a>1、根页面位置万年不动</h3><ul><li>每当为某个表创建一个 B+ 树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 <strong>根节点</strong> 页面。</li></ul><blockquote><p>当表中不存在数据时，每个 B+ 树索引所对应的根节点中既没有用户记录，也没有目录项记录。</p></blockquote><ul><li>随后往表中插入用户记录时，先将用户记录存储到这个<strong>根节点</strong>中</li><li>当根节点中的可用空间用完时，此时再往表中插入记录时，<strong>会将根节点中所有的记录复制到一个新分配的页中</strong>（设这个新页为 页 a），然后对这个页进行页分裂的操作，得到一个新页（设为页 b）。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应索引列的值）的大小就会被分配到页 a 或者 页 b 中，而<strong>根节点</strong>便升为存储目录项记录的页</li></ul><blockquote><p>一个 B+ 树索引的根节点自诞生之日起，就不会再发生移动，这也只要我们对某个表建立一个索引，那么<strong>它的根节点的页号便会被记录到某个地方，然后凡是 InnoDB 存储引擎需要用到这个索引时，就从固定的地方取出根节点的页号，从而来访问这个索引</strong>。</p></blockquote><h3 id="2、内节点中目录项记录的唯一性"><a href="#2、内节点中目录项记录的唯一性" class="headerlink" title="2、内节点中目录项记录的唯一性"></a>2、内节点中目录项记录的唯一性</h3><ul><li><strong>对于二级索引的 B+ 树而言，它的非叶子节点除了记录索引列和页号外，还需要记录主键值</strong></li><li>比如说，现在有一张表</li></ul><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘a’</td></tr><tr><td>3</td><td>1</td><td>‘b’</td></tr><tr><td>5</td><td>1</td><td>‘c’</td></tr><tr><td>7</td><td>1</td><td>‘d’</td></tr></tbody></table><blockquote><p>如果此时二级索引目录项（非叶子节点）中记录的内容只是<strong>索引列</strong> + <strong>页号</strong> 的搭配的话，那么为 c2 列建立索引后的 B+ 树应该长这样</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165229.png" alt="image.png"></p><ul><li>如果此时我们希望插入一条新纪录，其中 c1 c2 c3 的值分别为 9 、 1 、 ‘c’ ，那么在修改 B+ 树时就遇到了一个问题，由于页 3 中只记录了 c2 列的值 + 页号，而页 3 中两个目录项记录对应的 c2 值都是 1 ，我们要插入的值也 为 1 ，那么我们这条新数据应该插入到页 4 还是页 5 ？</li></ul><blockquote><p>所以为了保证新插入的记录都可以找到自己在哪个页里，我们需要保证在 B+ 树的同一层内节点的目录项记录除页号这个字段以外是唯一的，所以对于二级索引的内节点的目录项记录的内容实际上由三部分组成：</p></blockquote><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><blockquote><p>故二级索引的 B+ 树应该为</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165233.png" alt="image.png"></p><blockquote><p>此时再插入记录（9，1，’c’）时，由于页 3 中存储的目录项由 <strong>c2 列 + 主键 + 页号</strong> 组成，那么我们可以将新插入记录的 c2 列与 页 3 中的各目录项进行对比，如果 c2 列的值相同，那么可以接着比较主键的值。<br>在本例中，最后新纪录应该被插入到页 5 中。</p></blockquote><h3 id="3、一个页最少可以存储两条数据"><a href="#3、一个页最少可以存储两条数据" class="headerlink" title="3、一个页最少可以存储两条数据"></a>3、一个页最少可以存储两条数据</h3><blockquote><p>一个 B+ 树只需要很少的层级就可以轻松存储数亿条记录，而且查询速度相当不错！这是因为 B+ 树本质上就是一个大的多层级目录，每次经过一个目录就可以过滤掉非常多无效的子目录，直到最后访问到存储真实数据的目录。</p><p>如果一个大目录中只存放一个子目录是啥效果呢？这样会造成目录层级非常非常多，而且最后的那个存放真实数据的目录中也只能存放一条记录，这样得不偿失，所以 InnoDB 的一个数据页至少可以存放两条数据。</p></blockquote><h2 id="4-5、MyISAM-索引的原理"><a href="#4-5、MyISAM-索引的原理" class="headerlink" title="4.5、MyISAM 索引的原理"></a>4.5、MyISAM 索引的原理</h2><blockquote><p>和 InnoDB 一样 ，MyISAM 也支持 B+ 树索引，但后者实现的原理与前者的略有不同，MyISAM 引擎使用 B+ 树索引时，在叶子节点的 <code>data</code> 域中存放的是<strong>数据记录的地址</strong></p></blockquote><h3 id="1、MyISAM-索引的原理"><a href="#1、MyISAM-索引的原理" class="headerlink" title="1、MyISAM 索引的原理"></a>1、MyISAM 索引的原理</h3><ul><li>MyISAM <strong>将数据与索引分开存储</strong>，它<strong>将表中的记录按照记录的插入顺序单独存储在一个文件中，称为数据文件</strong>。这个文件并不划分为若干个数据页，而是有多少记录就往文件中塞多少记录就完事了。</li></ul><blockquote><p><strong>由于在插入数据时没有刻意地按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找</strong>。</p></blockquote><ul><li>使用 MyISAM 存储引擎地表会把索引信息另外放存储在另一个索引文件中。MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<strong>主键值 + 数据记录地址的组合</strong></li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165237.png" alt="image.png"></p><ul><li><p>在 MyISAM 中，索引文件仅仅保存数据记录的地址，它的主键索引和二级索引在结构上没有任何区别，只是主键索引要求 key 是唯一的，而二级索引的 key 可以重复。</p></li><li><p>MyISAM 的索引方式都是<strong>非聚簇</strong>的，下面总结一下二者索引的区别：、</p><ul><li>在 InnoDB 引擎中，我们只需要根据主键值对 <strong>聚簇索引</strong> 进行一次查找就可以找到对应的记录，而在 MyISAM 中还需要进行一次<strong>回表</strong>，即 MyISAM 中的索引都是二级索引。</li><li>InnoDB 本身的数据文件就是索引文件，而 MyISAM 中索引和数据是分开存储的</li><li>InnoDB 的非聚簇索引的 data 记录的是相应记录主键的值，而 MyISAM 索引记录的是数据地址。换句话说，InnoDB 的所有非聚簇索引都引用主键作为 data 域</li><li>MyISAM 的回表操作是十分快的，因为是拿着地址偏移量直接到文件中取数据，而 InnoDB 是通过获取主键的值然后再去聚簇索引中查找记录。速度没前者快。</li><li>InnoDB 要求表必须有主键（MyISAM）可以没有，如果在 InnoDB 表中没有显式指定主键，那么会选择表中的唯一列作为主键，如果表没有指定主键，又没有唯一列， 那么 InnoDB 会生成一个隐含字段作为主键，这个字段长度为 6 byte ，类型为长整型</li></ul></li></ul><h1 id="五、InnoDB-数据存储结构"><a href="#五、InnoDB-数据存储结构" class="headerlink" title="五、InnoDB 数据存储结构"></a>五、InnoDB 数据存储结构</h1><h2 id="5-1、数据库的存储结构-–-页"><a href="#5-1、数据库的存储结构-–-页" class="headerlink" title="5.1、数据库的存储结构 – 页"></a>5.1、数据库的存储结构 – 页</h2><blockquote><p>索引结构为我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说<strong>是存储在页结构中</strong>。另一方面，索引是在存储引擎中实现的，MySQL 服务器上的<strong>存储引擎</strong>负责对表中数据的读取和写入工作。</p><p><strong>不同存储引擎中存放的格式一般是不同的</strong>，甚至有的存储引擎如 <code>Memory</code> 都不用磁盘来存储数据。</p></blockquote><h3 id="1、磁盘与内存交互的基本单位-–-页"><a href="#1、磁盘与内存交互的基本单位-–-页" class="headerlink" title="1、磁盘与内存交互的基本单位 – 页"></a>1、磁盘与内存交互的基本单位 – 页</h3><ul><li>InnoDB 将数据划分为若干个页，页的大小默认为 <strong>16KB</strong></li><li>以<strong>页作为磁盘与内存之间交互的基本单位</strong>，也就是说<strong>一次最少从磁盘中读取 16KB 的内容到内存中</strong>，<strong>一次最少将内存中的 16 KB 内容刷新到磁盘中</strong></li><li><strong>在数据库中，不论是读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页，数据库 I/O 操作的最小单位是页</strong>，一个页中可以存储多个行记录。</li></ul><blockquote><p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次 I / O 操作）只能处理一行数据，效率非常低。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165242.png" alt="image.png"></p><h3 id="2、页结构概述"><a href="#2、页结构概述" class="headerlink" title="2、页结构概述"></a>2、页结构概述</h3><ul><li>页 a、页 b、页 c…页 n 这些页<strong>可以不在物理结构上相连</strong>，只要通过<strong>双向链表</strong>相关联即可。</li><li><strong>每个数据页中的记录会按照主键值从小到达的顺序组成一个单向链表</strong></li><li><strong>每个数据页都会为存储在它里面的记录生成一个页目录</strong>，在通过主键查找某条记录的时候可以在页目录中使用<strong>二分法</strong>快速定位到对应的槽，<strong>然后再遍历该槽对应分组中的记录即可快速找到指定的记录</strong>。</li></ul><h3 id="3、页的上层结构"><a href="#3、页的上层结构" class="headerlink" title="3、页的上层结构"></a>3、页的上层结构</h3><blockquote><p>在数据库中，还存在着区（Extent）、段（Segment）和表空间（TableSpace）的概念。行、页、区、段和表空间的关系如下图所示</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165246.png" alt="image.png"></p><ul><li>区是比页大一级的存储结构，在 InnoDB 中，一个区会分配 64 个连续的页。因为 InnoDB 中页的大小默认是 16KB，所以一个区的大小为 64 * 16 KB</li><li>段由一个或多个区组成，在段中不要求区与区之间是相邻的。<strong>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在</strong>。</li></ul><blockquote><p><strong>当我们创建数据库表、索引时，会响应地创建对应的段，比如说创建一个表时会创建一个表段，创建一个索引时会创建一个索引段</strong>。</p></blockquote><p>表空间是一个逻辑容器，它存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或者多个表空间组成</p><blockquote><p>表空间从管理上可以划分为：<strong>系统表空间</strong>、<strong>用户表空间</strong>、<strong>撤销表空间</strong> 和 <strong>临时表空间</strong> 等</p></blockquote><h2 id="5-2、页的内部结构"><a href="#5-2、页的内部结构" class="headerlink" title="5.2、页的内部结构"></a>5.2、页的内部结构</h2><ul><li>页如果按照类型划分的话，常见的有<strong>数据页（保存 B+ 树节点）</strong>、<strong>系统页</strong>、<strong>Undo 页</strong> 和 <strong>事务数据页</strong>等，其中数据页是最常用的页</li><li>数据页的 16 KB 大小的存储空间被划分为七个部分，分别是<ul><li>文件头（File Header）</li><li>页头（Page Header）</li><li>最大最小记录</li><li>用户记录</li><li>空闲空间（Free Space）</li><li>页目录（Page Directory）</li><li>文件尾（File Tailer）</li></ul></li></ul><blockquote><p>如下图所示：</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165251.png" alt="image.png"></p><ul><li>这七个部分作用分别如下：</li></ul><table><thead><tr><th align="center">名称</th><th align="center">占用大小</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">文件头</td><td align="center">38 字节</td><td align="center">用于描述页的信息</td></tr><tr><td align="center">页头</td><td align="center">56 字节</td><td align="center">页的状态信息</td></tr><tr><td align="center">最大最小记录</td><td align="center">26 字节</td><td align="center">两个虚拟的行记录</td></tr><tr><td align="center">用户记录</td><td align="center">不确定</td><td align="center">用于存储行记录内容（如果是叶子节点，那么存储数据，如果是非叶子节点，那么存储目录项）</td></tr><tr><td align="center">空闲空间</td><td align="center">不确定</td><td align="center">用于记录页中还没有被使用过的空间</td></tr><tr><td align="center">页目录</td><td align="center">不确定</td><td align="center">存储用户记录的相对位置</td></tr><tr><td align="center">文件尾</td><td align="center">8 字节</td><td align="center">用于校验页是否完整</td></tr></tbody></table><blockquote><p>我们可以将这七个结构划分为三部分</p></blockquote><h3 id="1、文件头和文件尾"><a href="#1、文件头和文件尾" class="headerlink" title="1、文件头和文件尾"></a>1、文件头和文件尾</h3><blockquote><p>首先是<strong>文件通用部分</strong>，也就是<strong>文件头和文件尾</strong></p></blockquote><ul><li>文件头部信息</li></ul><blockquote><p>不同类型的页都会以 <code>File Header</code> 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，这一部分由以下内容组成</p></blockquote><table><thead><tr><th align="center">名称</th><th align="center">占用空间</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FIL_PAGE_SPACE_OR_CHKSUM</td><td align="center">4 byte</td><td align="center">页的校验和</td></tr><tr><td align="center">FIL_PAGE_OFFSET</td><td align="center">4 byte</td><td align="center">页号</td></tr><tr><td align="center">FIL_PAGE_PREV</td><td align="center">4 byte</td><td align="center">上一个页的页号</td></tr><tr><td align="center">FIL_PAGE_NEXT</td><td align="center">4 byte</td><td align="center">下一个页的页号</td></tr><tr><td align="center">FIL_PAGE_LSN</td><td align="center">8 byte</td><td align="center">页面被最后修改时对应的日志序列位置（Log Sequence Number）</td></tr><tr><td align="center">FIL_PAGE_TYPE</td><td align="center">2 byte</td><td align="center">该页的类型</td></tr><tr><td align="center">FIL_PAGE_FILE_FLUSH_LSN</td><td align="center">8 byte</td><td align="center">仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应 LSN 值</td></tr><tr><td align="center">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td align="center">4 byte</td><td align="center">页属于哪个表空间</td></tr></tbody></table><ol><li><strong>其中每一个页都有一个单独的页号，可以类比为人的身份证号码， InnoDB 可以通过页号唯一定位一个页</strong></li><li>FIL_PAGE_TYPE 代表当前页的类型，InnoDB 为了不同的目的将页划分为不同的类型</li></ol><blockquote><p><strong>用于存储数据的页的类型是 <code>FIL_PAGE_INDEX</code> ，也就是所谓的索引页</strong></p></blockquote><ol start="3"><li>数据页的链接实现</li></ol><blockquote><p>在文件头部内容中存在两个属性，即 <code>FIL_PAGE_PREV</code> 和 <code>FIL_PAGE_NEXT</code> ，如果数据分散到多个不连续的页中存储时，需要将这些页关联起来，而 <code>FIL_PAGE_PREV</code> 和 <code>FIL_PAGE_NEXT</code> 就分别代表本页的上一个和下一个页的页号。这样通过前驱指针与后继指针将许许多多的页串联成一个双向链表，保证这些页形成逻辑上的联系。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165257.png" alt="image.png"></p><ol start="4"><li>校验页的完整性</li></ol><blockquote><p>InnoDB 存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要将数据同步到磁盘中，但是在同步到一半时断电了，造成了页传输的不完整。</p><p>此时为了校验一个页是否完整，可以通过文件尾和文件头的校验和来判断，如果两个值不相等，那么证明该页的传输有问题，需要重新进行传输</p><p>在内存中对页数据进行修改后，需要重新计算它的校验和，然后同步时需要将校验和也同步回磁盘，如果内存中的数据完全被刷进磁盘，那么文件头和文件尾的校验和都会被刷新，此时表示同步成功，如果在刷盘的过程中断电崩溃，那么只有文件头的校验和被刷新，而文件尾的校验和还是上版本的数据。</p></blockquote><ol start="5"><li>校验和</li></ol><blockquote><p>对于一个很长的字符串来说，我们会通过某种算法来计算一个较短的值来代表这个很长的字符串，这个较短的值就被称为校验和。</p><p>在比较两个很长的字符串时，先比较这两个字符串的校验和，如果校验和都不一样，那么证明这两个字符串一定不等，所以省去了比较两个长字符串的时间消耗。</p></blockquote><ul><li>文件尾部信息</li></ul><ol><li>校验和</li></ol><blockquote><p>这个部分是为了与文件头中的校验和形成一一对应关系</p></blockquote><ol start="2"><li>页面被最后修改时对应的日志序列位置</li></ol><blockquote><p>这个部分也是为了校验页面完整性的，与文件头的 LSN 形成一一对应。</p></blockquote><h3 id="2、记录"><a href="#2、记录" class="headerlink" title="2、记录"></a>2、记录</h3><blockquote><p>第二部分是记录部分，页的主要作用就是存储记录，所以<strong>最大最小记录</strong>和<strong>用户记录</strong>部分占了页结构的主要空间。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165301.png" alt="image.png"></p><ul><li>空闲空间（Free Space）</li></ul><blockquote><p>我们自己存储的记录会按照指定的<strong>行格式</strong>存储到 <code>User Records</code> 部分。但是在一开始生成页的时候并没有 <code>User Records</code> 部分，<strong>每当我们插入一条记录，都会从空闲空间（Free Space），也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分</strong>。</p><p>当空闲空间完全被 <code>User Records</code> 部分替代了后，也就意味着这个页使用完了，此时如果还有新纪录插入的话，就需要去申请新的页了。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165304.png" alt="image.png"></p><ul><li>用户记录（User Records）</li></ul><blockquote><p>User Records 中的这些记录按照指定的行格式一条一条地摆放在 User Records 部分，<strong>相互之间形成单链表</strong></p></blockquote><h3 id="3、页目录和页面头部"><a href="#3、页目录和页面头部" class="headerlink" title="3、页目录和页面头部"></a>3、页目录和页面头部</h3><ul><li>为什么需要目录？</li></ul><blockquote><p>在页中，<strong>记录是以单链表的形式进行存储的</strong>。单向链表的特点是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能检索。</p><p><strong>因此在页结构中设计了页目录这个模块，用于专门给记录做一个目录，通过二分查找法的方式进行检索，提高效率</strong>。</p></blockquote><ul><li>页面头部</li></ul><blockquote><p>为了能得到一个数据页中存储的记录的状态信息，比如说本页以及存储了多少条记录，第一条记录的地址是什么，特意在页中定义了一个页面头部，用于记录信息。</p></blockquote><h3 id="4、COMPACT-行格式"><a href="#4、COMPACT-行格式" class="headerlink" title="4、COMPACT 行格式"></a>4、COMPACT 行格式</h3><blockquote><p>COMPACT 行格式由 <strong>变长字段长度列表</strong> 、 <strong>NULL 值列表</strong> 、 <strong>记录头信息</strong> 和 <strong>记录真实数据</strong> 组成</p></blockquote><ul><li>记录头信息</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165308.png" alt="image.png"></p><blockquote><p>这些记录头信息中各个属性如下：</p></blockquote><table><thead><tr><th align="center">名称</th><th align="center">大小（单位：bit）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">delete_mask</td><td align="center">1</td><td align="center">标记该记录是否被删除</td></tr><tr><td align="center">min_rec_mask</td><td align="center">1</td><td align="center">B+ 树每层非叶子节点的最小记录都会添加该标记</td></tr><tr><td align="center">n_owned</td><td align="center">4</td><td align="center">表示当前记录拥有的记录数</td></tr><tr><td align="center">heap_no</td><td align="center">13</td><td align="center">表示当前记录在记录堆的位置信息</td></tr><tr><td align="center">record_type</td><td align="center">3</td><td align="center">表示当前记录的类型，0 表示普通记录，1 表示 B+ 树种非叶子节点记录，2 表示最小记录，3 表示最大记录</td></tr><tr><td align="center">next_record</td><td align="center">16</td><td align="center">表示下一条记录的相对位置</td></tr></tbody></table><ol><li>delete_mask （删除标记）</li></ol><p>这个属性标记着当前记录是否被删除，占用 1 bit （值为 0 ，代表记录没有被删除；值为 1 ，代表记录被删除掉了）</p><p>被删除的记录为何还在页中存储？</p><blockquote><p>这些被删除的记录之所以不立即从磁盘上移除，是<strong>因为移除它们后其他的记录在磁盘上需要进行重新排列，导致性能消耗</strong>。</p><p>所以只是打一个删除标记，所有被删除掉的记录会组成一个所谓的<strong>垃圾链表</strong>，在这个链表中的记录占用的空间被称之为<strong>可重用空间</strong>，之后如果有新纪录插入到表中的话，可能将这些被删除的记录占用的存储空间覆盖掉。</p></blockquote><ol start="2"><li>heap_no</li></ol><p>这个属性表示当前记录在本页中的位置。</p><p>MySQL 会自动为每个页里加两条记录，这两条记录不是我们自己插入的，所以也被称为伪记录或者虚拟记录。</p><ol start="3"><li>next_record</li></ol><blockquote><p><strong>它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量</strong></p></blockquote><h1 id="六、优化相关"><a href="#六、优化相关" class="headerlink" title="六、优化相关"></a>六、优化相关</h1><h2 id="6-1、索引的设计原则"><a href="#6-1、索引的设计原则" class="headerlink" title="6.1、索引的设计原则"></a>6.1、索引的设计原则</h2><h3 id="1、适合创建索引的-11-种情况"><a href="#1、适合创建索引的-11-种情况" class="headerlink" title="1、适合创建索引的 11 种情况"></a>1、适合创建索引的 11 种情况</h3><ul><li>字段的数值有唯一性的限制</li></ul><ol><li>索引本身可以起到约束的作用，比如说<strong>唯一索引和主键索引都是可以起到唯一性约束的。</strong></li><li><strong>如果某个字段的值是唯一的，那么就可以直接为其创建一个唯一性索引，或者主键索引，这样可以更快速地通过该索引来确定某条记录</strong>。</li></ol><blockquote><p>比如说学生表中学号是具有唯一性的字段，为学号字段创建唯一性索引可以很快地确定某个学生的信息；</p><p>唯一索引对 insert 速度的损耗可以忽略，但是对查找速度的提高是明显的。</p></blockquote><ul><li>频繁作为 WHERE 查询条件的字段</li></ul><blockquote><p>如果某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要对这个字段创建索引。</p><p>在数据量大的情况下，创建普通索引就可以大幅度提高数据查询的效率。</p></blockquote><ul><li>经常用于 GROUP BY 和 ORDER BY 的列</li></ul><blockquote><p>索引就是让数据按照某些顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序时，就需要<strong>对分组或者排序的字段进行索引</strong>。如果待排序的列有多个，那么可以在这些列上创建<strong>组合索引</strong></p></blockquote><ul><li>UPDATE、 DELETE 的 WHERE 条件列</li></ul><blockquote><p>当我们对某条数据进行 UPDATE 或者 DELETE 操作时，可以针对 WHERE 条件列建立索引。</p><p>对数据按照某个条件进行查询后再进行 UPDATE 或者 DELETE 的操作，如果对 WHERE 字段创建索引，那么就能大幅提高效率。</p><p>原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或者删除。</p><p><strong>如果进行更新时，更新的字段是非索引字段，那么提升的效率会更明显，这是因为非索引字段的更新不需要对索引进行维护</strong></p></blockquote><ul><li>DISTINCT 字段需要创建索引</li></ul><blockquote><p>有时候我们需要对某个字段进行去重，使用 DISTINCT ，那么对这个字段创建索引也会提升查询效率。</p></blockquote><ul><li>多表 JOIN 连接操作时，创建索引注意事项</li></ul><ol><li><strong>连接表的数量尽量不要超过 3 张</strong>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增加会非常快，严重影响查询效率</li><li><strong>对 WHERE 条件创建索引</strong>， 因为 WHERE 才是数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</li><li><strong>对用于连接的字段创建索引</strong>，并且在多张表中该字段的<strong>类型必须一致</strong></li></ol><blockquote><p>因为如果连接字段的类型不一致，那么<strong>在进行连接时会使用函数进行数据类型转换，也就不会使用索引</strong>。</p></blockquote><ul><li>使用列的类型小的创建索引</li></ul><blockquote><p>这里所说的<strong>类型大小</strong>指的就是该类型表示的数据范围的大小。</p><p>如果我们希望对某个整数列创建索引的话，那么在表示的整数范围允许的情况下，尽量让索引使用较小的类型，比如说能使用 INT 就别用 BIGINT ，能用 TINYINT 就别用 INT</p></blockquote><ol><li>数据类型越小，在查询时进行的比较操作越快。</li><li><strong>数据类型越小，索引占用的存储空间就越少，在一个数据页中就可以放下更多的记录</strong>，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，加快读写效率。</li></ol><blockquote><p>这个建议对于表的<strong>主键来说更加实用</strong>，如果主键使用更小的数据类型，就可以节省更多的存储空间。</p></blockquote><ul><li>使用字符串前缀创建索引</li></ul><ol><li><strong>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间</strong>。</li><li><strong>我们可以通过截取字段的前面一部分内容建立索引，这个索引称为前缀索引</strong>。</li></ol><blockquote><p>这样在查找记录时虽然不能精确地定位到记录的位置，但是能定位到响应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串，既<strong>节约空间</strong>，又<strong>减少了字符串的比较时间</strong>。</p></blockquote><ol start="3"><li>索引的长度和区分度是一对矛盾体，可以使用 <code>count(distinct left (列名, 索引长度)) / count(*)</code> 的区分度来确定。</li></ol><blockquote><p>区分度越接近于 1 越好，而在区分度相同的条件下，索引长度越低越好。</p></blockquote><ul><li><p>区分度高（散列性高）的列适合创建索引</p></li><li><p>使用最频繁的列放到联合索引的左侧</p></li><li><p>在多个字段都要创建索引的情况下，联合索引高于单值索引</p></li></ul><h3 id="2、不适合创建索引的-7-种情况"><a href="#2、不适合创建索引的-7-种情况" class="headerlink" title="2、不适合创建索引的 7 种情况"></a>2、不适合创建索引的 7 种情况</h3><ul><li>WHERE 中使用不到的字段不要设置索引</li></ul><blockquote><p>索引的价值是快速定位，如果起不到定位的字段通常不需要创建索引。</p></blockquote><ul><li>数据量小的表最好不要使用索引</li></ul><blockquote><p><strong>表记录太小，是否创建索引对查询效率影响并不大</strong>。甚至说，查询花费的时间可能要比遍历索引的时间还要短，这种情况下，索引起不到优化效果。</p></blockquote><ul><li>有大量重复数据的列上不要创建索引</li></ul><blockquote><p>比如说学生表的性别字段上只有男与女两个不同值，因此没必要创建索引。如果创建索引，<strong>不但不会提高查询效率，反而会严重降低数据更新速度</strong>。</p></blockquote><ul><li>避免对经常更新的表创建过多的索引</li></ul><ol><li>频繁更新的字段不一定要创建索引。因为更新数据时，也要更新索引，如果索引太多，那么在更新索引时也会造成负担，从而影响效率。</li><li>避免对经常更新的表创建过多索引，同时索引中的列要尽可能少。此时虽然索引提高了查询速度，但是也增加了更新负担。</li></ol><ul><li>不建议使用无序的值作为索引</li></ul><blockquote><p>例如身份证、UUID（在索引比较时需要转换为 ASCII ，并且插入时可能造成页分裂）、MD5、HASH</p></blockquote><ul><li><p>删除不再使用或者很少使用的索引</p></li><li><p>不要定义冗余或者重复的索引</p></li></ul><h3 id="3、限制索引的数目"><a href="#3、限制索引的数目" class="headerlink" title="3、限制索引的数目"></a>3、限制索引的数目</h3><blockquote><p><strong>建议单张表的索引不超过 6 个</strong></p></blockquote><ul><li><strong>每个索引都需要占用磁盘空间，索引越多，需要占用的磁盘空间就越大</strong>。</li><li>索引会影响 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等语句的性能，因为表中数据更改的同时，索引也可能进行相应的调整和更新，会造成负担</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<strong>索引来进行评估</strong>，以生成一个最好的执行计划，如果同时有很多个索引都可以用于查询，那么会增加 MySQL 优化器</li></ul><h2 id="6-2、JOIN-语句原理"><a href="#6-2、JOIN-语句原理" class="headerlink" title="6.2、JOIN 语句原理"></a>6.2、JOIN 语句原理</h2><ul><li>对于内连接来说，查询优化器可以决定哪张表作为驱动表，哪张表作为被驱动表。</li></ul><ol><li>对于内连接来说，如果表的连接条件中只有一个字段有索引，那么<strong>有索引字段所在的表会被作为被驱动表</strong></li><li>对于内连接来说，如果两个表的连接条件都存在索引，那么会<strong>选择小表作为驱动表</strong>（小表驱动大表）</li></ol><ul><li><strong>JOIN 方式连接多个表，本质就是各个表之间数据的循环匹配。</strong></li></ul><blockquote><p>在 MySQL 5.5 之前，MySQL 只支持一种表间关联方式，那就是<strong>嵌套循环</strong>（Nested Loop Join）。如果关联表的数据量很大，那么 JOIN 关联的执行时间就会非常长。</p><p><strong>在 MySQL 5.5 以后的版本中，MySQL 引入了 BNLJ （Block Nested Loop Join） 算法来优化嵌套执行</strong></p></blockquote><ul><li>在连接查询中，驱动表和被驱动表不是根据 SQL 语句中表的出现顺序决定的，查询优化器可能会帮我们重新划定驱动表和被驱动表。</li></ul><h3 id="1、Simple-Nested-Loop-Join（简单嵌套循环连接）"><a href="#1、Simple-Nested-Loop-Join（简单嵌套循环连接）" class="headerlink" title="1、Simple Nested-Loop Join（简单嵌套循环连接）"></a>1、Simple Nested-Loop Join（简单嵌套循环连接）</h3><blockquote><p>这个算法十分简单，即从表 A 中取出一条数据 1 ，然后遍历表 B ，将匹配到的数据放到 result 中，以此类推，驱动表的每一条记录都需要与被驱动表的记录进行判断。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165318.png" alt="image.png"></p><blockquote><p>这种方式的效率是非常低的，如果 A 表中有 100 条，B 表中有 1000 条数据，那么扫描次数为 100000 次</p></blockquote><h3 id="2、Index-Nested-Loop-Join（索引嵌套循环连接）"><a href="#2、Index-Nested-Loop-Join（索引嵌套循环连接）" class="headerlink" title="2、Index Nested-Loop Join（索引嵌套循环连接）"></a>2、Index Nested-Loop Join（索引嵌套循环连接）</h3><blockquote><p>Index Nested-Loop Join 的优化思路是为了减少<strong>内层表数据的匹配次数</strong>，所以要求被驱动表上<strong>必须有索引</strong>才行。</p><p><strong>通过外层表匹配条件直接与内层表索引进行比较</strong>，避免与内层表的每条记录去进行比较，这样极大地减少了对内层表的匹配次数。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165321.png" alt="image.png"></p><h3 id="3、Block-Nested-Loop-Join"><a href="#3、Block-Nested-Loop-Join" class="headerlink" title="3、Block Nested-Loop Join"></a>3、Block Nested-Loop Join</h3><blockquote><p>如果存在索引，那么会使用 Index 的方式进行 Join ，如果 Join 的列没有索引，被驱动表要扫描的次数太多了。</p><p>Simple Nested Loop Join IO 的次数非常多，所以为了减少被驱动表的 IO 次数，就出现了 Block Nested Loop Join。</p><p>与前者相比，Block Nested Loop Join 不再是逐条获取驱动表中的数据，而是一块一块的获取，它引入了 <strong>join buffer</strong> 缓冲区，<strong>将驱动表 join 相关的部分数据列缓存到 join buffer 中，然后全表扫描被驱动表，被驱动表的每一条记录一次性与 join buffer 中的所有驱动表记录进行匹配</strong>，将简单嵌套循环中的多次比较合并为一次，降低了被驱动表的访问频率。</p></blockquote><ul><li><strong>这里缓存的不只是关联表的列， select 后面的列也会缓存起来</strong>。</li><li>在一个有 N 个 Join 关联的 SQL 中会分配 N - 1 个 join buffer。所以查询的时候尽量减少不必要的字段，可以让 join buffer 中存放更多的列。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165326.png" alt="image.png"></p><h3 id="4、Join-小结"><a href="#4、Join-小结" class="headerlink" title="4、Join 小结"></a>4、Join 小结</h3><ul><li>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ</li><li>永远用小结果集驱动大结果集</li><li>为驱动表匹配的条件字段添加索引</li><li>增大 <code>join buffer size</code> 的大小（一次缓存的数据越多，那么内层表的扫描次数就越少）</li><li>减少驱动表不必要的查询字段</li></ul><h3 id="5、Hash-Join"><a href="#5、Hash-Join" class="headerlink" title="5、Hash Join"></a>5、Hash Join</h3><blockquote><p>从 MySQL 8.0.20 版本开始将废弃 <strong>BNLJ</strong>，因为从 8.0.18 版本开始就加入了 <code>Hash Join</code></p></blockquote><ul><li>Nested Loop：对于被连接的数据子集较小的情况，Nested Loop 是一个较好的选择</li><li>Hash Join ：对于<strong>大数据集连接</strong>时的常见方式，<strong>优化器使用两个表中较小（相对较小）的表利用 Join Key 在内存中建立散列表，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行</strong>。<ul><li>这种方式适用于较小的表完全可以放到内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大不能完全放入内存的情况下，优化器会将其分割为若干个不同的分区，不能放入内存的部分就将该分区写入磁盘的临时段，此时要求有较大的临时段从而提高 IO 的性能。</li><li>它能够很好地工作于没有索引的大表和并行查询的环境中，并提供最好的性能。<strong>Hash Join</strong> 只能应用于等值连接。</li></ul></li></ul><table><thead><tr><th align="center">类别</th><th align="center">Nested Loop</th><th align="center">Hash Join</th></tr></thead><tbody><tr><td align="center">使用条件</td><td align="center">任何条件</td><td align="center">等值连接</td></tr><tr><td align="center">相关资源</td><td align="center">CPU、磁盘 IO</td><td align="center">内存、临时空间</td></tr><tr><td align="center">特点</td><td align="center">当有高选择性索引或者限制性搜索时效率比较高，能够快速返回第一次的搜索结果</td><td align="center">当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Join 有效。在数据仓库环境下，如果表记录数多，效率高。</td></tr><tr><td align="center">缺点</td><td align="center">当索引丢失或者查询条件限制不够时，效率很低；当表记录数较多时，效率低。</td><td align="center">建立哈希表需要大量内存。第一次的结果返回较慢，仅适用于等值连接。</td></tr></tbody></table><h2 id="6-3、SQL-优化"><a href="#6-3、SQL-优化" class="headerlink" title="6.3、SQL 优化"></a>6.3、SQL 优化</h2><h3 id="1、子查询优化"><a href="#1、子查询优化" class="headerlink" title="1、子查询优化"></a>1、子查询优化</h3><ul><li>子查询执行效率不高的原因：</li></ul><ol><li><strong>执行子查询时，MySQL 需要为内层查询语句的查询结果建立一张临时表</strong>，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销临时表。这样会消耗大量 CPU 和 IO 资源，产生大量的慢查询。</li><li>子查询的结果集存储的<strong>临时表</strong>，无论是内存临时表还是物理临时表都<strong>不会存在索引</strong>，所以查询性能会受到影响。</li><li>对于返回结果集较大的子查询，其对查询性能的影响也就越大。</li></ol><blockquote><p>在 MySQL 中，<strong>可以使用连接查询来代替子查询</strong>。<strong>连接查询不需要建立临时表</strong>，速度比子查询快，如果使用索引的话，性能就会更好。</p></blockquote><h3 id="2、排序优化"><a href="#2、排序优化" class="headerlink" title="2、排序优化"></a>2、排序优化</h3><ul><li>为什么要在 ORDER BY 字段上添加索引呢？</li></ul><blockquote><p>在 MySQL 中，支持两种排序方式，分别是 <code>FileSort</code> 和 <code>Index</code> 排序</p></blockquote><ol><li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，<strong>效率更高</strong></li><li>FileSort 排序则一般在<strong>内存</strong>中进行排序，占用 CPU 较多。如果待排序结果集较大，那么会产生临时文件 IO 到磁盘进行排序的情况，效率低</li></ol><h3 id="3、分页查询优化"><a href="#3、分页查询优化" class="headerlink" title="3、分页查询优化"></a>3、分页查询优化</h3><blockquote><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能，一个常见有非常头疼地问题就是 <code>limit 2000000, 10</code> ，此时需要 MySQL 排序前 2000010 条数据，然后仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p></blockquote><ul><li>优化思路一：</li></ul><blockquote><p>在索引上完成排序分页操作，最后<strong>根据主键关联回原表查询所需的其他列内容</strong>。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">as</span> t , (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>, <span class="number">10</span>) <span class="keyword">as</span> a <span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><ul><li>优化思路二：</li></ul><blockquote><p>该方案适用于主键自增的表，可以把 LIMIT 查询转换为某个位置的查询。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">2000000</span> LIMIT <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="七、锁"><a href="#七、锁" class="headerlink" title="七、锁"></a>七、锁</h1><blockquote><p><strong>事务的隔离性由锁来实现</strong></p></blockquote><h2 id="7-1、概述"><a href="#7-1、概述" class="headerlink" title="7.1、概述"></a>7.1、概述</h2><blockquote><p><strong>锁</strong> 是计算机协调多个进程或线程<strong>并发访问某一资源</strong>的机制，<strong>它由于保证这个资源在任何时刻最多只有一个线程访问，保证资源的一致性和完整性</strong>。</p></blockquote><ul><li>锁机制为实现 MySQL 的各个隔离级别提供了保证</li><li>锁冲突是影响数据库并发访问性能的一个重要因素</li></ul><h2 id="7-2、MySQL-并发事务访问相同的记录"><a href="#7-2、MySQL-并发事务访问相同的记录" class="headerlink" title="7.2、MySQL 并发事务访问相同的记录"></a>7.2、MySQL 并发事务访问相同的记录</h2><h3 id="1、读-读情况"><a href="#1、读-读情况" class="headerlink" title="1、读 - 读情况"></a>1、读 - 读情况</h3><blockquote><p>读 - 读情况，即并发事务相机<strong>读取相同的记录</strong>。读取操作本身不会对记录产生任何影响，所以这种情况是允许的。</p></blockquote><h3 id="2、写-写情况"><a href="#2、写-写情况" class="headerlink" title="2、写 - 写情况"></a>2、写 - 写情况</h3><blockquote><p>写 - 写情况，<strong>即并发事务相继对相同的记录做出改动</strong>。</p></blockquote><ul><li>在这种情况下会发生<strong>脏写</strong>的问题，任何一种隔离级别 都不允许这种问题的发生。</li></ul><blockquote><p>在多个未提交事务相继对一条记录做改动时，需要让它们<strong>排队执行</strong>，这个排队过程其实就是通过<strong>锁</strong>来执行的。</p><p>这个所谓的锁其实是一个<strong>内存中的结构</strong>，在事务执行前本来是没有所得，也就是说<strong>一开始没有锁结构与记录进行关联</strong>的，如图</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165334.png" alt="image.png"></p><blockquote><p><strong>当一个事务相对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，如果没有，那么会创建一个锁结构与之关联</strong>。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165336.png" alt="image.png"></p><ul><li>我们来看看锁结构中两个比较重要的属性：</li></ul><ol><li><code>trx</code> 信息：代表这个锁结构是由哪个事务生成的。</li><li><code>is_waiting</code>：代表当前事务是否在等待</li></ol><blockquote><p>当事务 t1 改动这条记录后，就生成一个锁结构与之关联，因为之前没有其他事务对记录加锁，所以 <code>is_waiting</code> 为 false ，我们把这个场景称为获取锁成功，然后就可以继续执行操作。</p><p>在事务 t1 提交前，另一个事务 t2 也想对这个记录做改动，那么先看看有没有<strong>锁结构</strong>与这条记录相关联，发现有一个锁结构与之关联后，t2 也会生成一个锁结构与之关联，不过这个锁结构的 <code>is_waiting</code> 为 true 。表示当前事务需要等待，我们称这个现象为获取锁失败。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165340.png" alt="image.png"></p><blockquote><p><strong>t1 提交事务后，会将该事务生成的锁结构释放</strong>，然后看看有没有其他事务在等待获取锁，如果有，那么会将对应事务生成的锁结构的 <code>is_waiting</code> 值为 false ，然后将该事务对应的线程唤醒，让它继续执行，此时 t2 就获取到锁了。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165343.png" alt="image.png"></p><h3 id="3、读-写或者写-读情况"><a href="#3、读-写或者写-读情况" class="headerlink" title="3、读 - 写或者写 - 读情况"></a>3、读 - 写或者写 - 读情况</h3><blockquote><p>这种情况下，可能会产生<strong>脏读</strong>、<strong>不可重复读</strong> 和 <strong>幻读</strong> 现象</p></blockquote><h2 id="7-3、锁的不同角度分类"><a href="#7-3、锁的不同角度分类" class="headerlink" title="7.3、锁的不同角度分类"></a>7.3、锁的不同角度分类</h2><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165346.png" alt="image.png"></p><h2 id="7-4、读锁与写锁"><a href="#7-4、读锁与写锁" class="headerlink" title="7.4、读锁与写锁"></a>7.4、读锁与写锁</h2><blockquote><p>对于数据库中并发事务的 <strong>读 - 读</strong> 情况并不会引起什么问题，对于 <strong>写 - 写</strong> 或 <strong>写 - 读</strong> 这些情况可能会引起一些问题，需要使用 <strong>MVCC</strong> 或者<strong>加锁</strong>的方式来解决。</p><p>由于既要允许<strong>读 - 读</strong>情况不会受到影响，又要使<strong>写 - 写</strong>、<strong>写 - 读</strong>情况中的操作<strong>相互阻塞</strong>，MySQL 实现了一个由两种类型的锁组成的所系统来解决。</p><p>这两类的锁通常被称为<strong>共享锁</strong>和<strong>排他锁</strong>，也就是<strong>读锁</strong>和<strong>写锁</strong></p></blockquote><ul><li>读锁：也称为共享锁，英文用 S 表示。<strong>针对同一份数据，多个事务的读操作可以同时进行而不相互影响，不相互阻塞</strong>。</li><li>写锁：也称为排他锁，英文用 X 表示。<strong>当前写操作没有完成前，它会阻断其他写锁和读锁</strong>。这样就能确保在给定的时间内，只有一个事务能执行写入，并防止其他用户正在写入的同一资源</li></ul><blockquote><p>对于 InnoDB 存储引擎来说，读锁和写锁既可以加在表上，也可以加在行上。</p></blockquote><table><thead><tr><th></th><th align="center">X 锁</th><th align="center">S 锁</th></tr></thead><tbody><tr><td>X 锁</td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td>S 锁</td><td align="center">不兼容</td><td align="center"><strong>兼容</strong></td></tr></tbody></table><ul><li>锁定读</li></ul><blockquote><p>对于读行为（SELECT 语句），既可以加共享锁，也可以加排他锁。</p></blockquote><ol><li>加共享锁</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><ol start="2"><li>加排他锁</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><ul><li>写操作</li></ul><blockquote><p>平时用到的写操作无非是 <strong>DELETE</strong> 、 <strong>UPDATE</strong> 和 <strong>INSERT</strong> 三种</p></blockquote><ol><li>DELETE</li></ol><blockquote><p>对一条记录的 delete 操作其实是现在 B+ 树种定位到这条记录的位置，然后获取这条记录的 X 锁，再执行修改 <code>delete mark</code> 操作。</p><p><strong>我们可以将这个定位待删除记录在 B+ 树中位置的过程看为一个获取 X 锁的锁定读。</strong></p></blockquote><ol start="2"><li>UPDATE<ol><li>未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生改变；这种情况下则先在 B+ 树种定位该记录的位置，然后再获取一下记录的 X 锁，最后在原纪录的位置执行修改操作即可。</li><li>未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化；这种情况则先在 B+ 树中定位该记录的位置，然后获取记录的 X 锁，将该记录彻底删除，最后再插入一条新纪录。</li><li>修改了该记录的键值；则相当于再原纪录做 DELETE 后再执行一次 INSERT 操作，加锁操作就按照 DELETE 和 INSERT 规则进行</li></ol></li><li>INSERT</li></ol><blockquote><p>一般情况下，新插入一条记录的操作并不加锁，而是通过一种称为 <strong>隐式锁</strong> 的结构来保护这条新插入的数据在本事务提交前不被别的事务访问。</p></blockquote><h2 id="7-5、表级锁、页级锁和行锁"><a href="#7-5、表级锁、页级锁和行锁" class="headerlink" title="7.5、表级锁、页级锁和行锁"></a>7.5、表级锁、页级锁和行锁</h2><ul><li>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案可以得到最大的并发，但是管理锁是非常消耗资源的事情。</li><li>所以数据库系统在<strong>高并发响应</strong>和<strong>系统平衡</strong>两方面进行平衡，也就产生了<strong>锁粒度</strong>的概念。</li></ul><h3 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h3><blockquote><p>表锁会锁定整张表，是 MySQL 中最基本的所策略，它<strong>并不依赖于存储引擎</strong>，而且<strong>表锁是开销最小的策略，但同时也是并发性能最差</strong>的情况。</p></blockquote><ul><li>意向锁</li></ul><blockquote><p>InnoDB 支持<strong>多粒度锁</strong>，它允许<strong>行级锁</strong>和<strong>表级锁</strong>共存，而<strong>意向锁就是其中一种表锁</strong></p></blockquote><ol><li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度锁共存</li><li><strong>意向锁是一种不与行级锁冲突的表级锁</strong></li><li><strong>它表示某个事务正在某些行持有了锁或者该事务准备去持有锁</strong></li></ol><blockquote><p>意向锁分为<strong>意向共享锁</strong>和<strong>意向排他锁</strong>，意向锁主要解决如下问题：现在有两个事务，分别是 t1 和 t2，其中 t2 试图在该表级别上应用共享或排他锁，<strong>如果没有意向锁存在，那么 t2 就需要去检查各个页或行是否存在锁</strong>；如果存在意向锁，那么此时就会收到由 t1 控制的表级别意向锁的阻塞。t2 在锁定该表之前不必再去检查各个页或者行锁，而只需检查表上的意向锁。</p></blockquote><ol start="4"><li>简单来说：<strong>就是给更大一级的空间示意里面是否已经加过锁</strong>。</li></ol><blockquote><p><strong>如果我们给某一行数据添加了排他锁，那么数据库会自动给更大一级的空间，比如说数据页或者数据表加上意向锁，来告诉其他人这个数据页或者数据表已经有人加过排他锁了</strong>。这样当其他人想要获取数据表排他锁时，就只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p></blockquote><ol start="5"><li>意向锁之间是兼容的，如下表</li></ol><table><thead><tr><th align="center"><br></th><th align="center">意向共享锁</th><th align="center">意向排他锁</th></tr></thead><tbody><tr><td align="center">意向共享锁</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center">意向排他锁</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><ol start="6"><li>意向锁和普通锁的关系如下表</li></ol><table><thead><tr><th align="center"><br></th><th align="center">意向共享锁</th><th align="center">意向排他锁</th></tr></thead><tbody><tr><td align="center">共享锁</td><td align="center"><strong>兼容</strong></td><td align="center">互斥</td></tr><tr><td align="center">排他锁</td><td align="center">互斥</td><td align="center">互斥</td></tr></tbody></table><ol start="7"><li>意向锁是表锁，不会与普通的行级锁（共享、排他）发生冲突，只会和普通的表级锁发生冲突（共享、排他）</li></ol><ul><li>自增锁</li></ul><blockquote><p>在使用 MySQL 的过程中，我们可以为表的某个列添加 <code>AUTO_INCREMENT</code> 属性，这意味着在插入语句中可以不需要为该列赋值。</p><p>插入数据总共由三种方式，分别为 <strong>简单插入</strong> 、 <strong>批量插入</strong> 和 <strong>混合模式插入</strong></p></blockquote><ol><li>简单插入</li></ol><blockquote><p>可以<strong>预先确定要插入的行数</strong> 的语句</p></blockquote><ol start="2"><li>批量插入</li></ol><blockquote><p><strong>事先不知道要插入的行数的语句</strong>，比如说 <code>insert ... select</code>,<code>replace ... select</code> 和 <code>load data</code> 语句，但不包含纯 insert ，InooDB 在每一处一行，都会为 AUTO_INCREMENT 列分配一个新的值</p></blockquote><ol start="3"><li>混合模式插入</li></ol><blockquote><p>这些是简单插入语句但是指定部分新行的自动递增列，比如说 <code>insert into teacher (id,name) values(1,&#39;a&#39;), (null, &#39;b&#39;)...</code></p><p>另一种混合类型插入是 <code>insert ... on duplicate key update</code></p></blockquote><p>对于上面数据插入的案例，MySQL 采用了<strong>自增锁</strong>的方式来实现，<code>AUTO-INC</code> 锁是当含有 <code>AUTO_INCREMENT</code> 列的表中插入记录时需要获取的一种特殊的表级锁，执行插入语句时就往表中添加一个 AUTO-INC 锁，然后为每条待插入记录的 <code>AUTO_INCREMENT</code> 的列分配递增的值，语句执行结束后再释放锁。</p><p><strong>一个事务在持有 AUTO-INC 锁时，其他事务的插入都会被阻塞，这样可以保证一个语句中分配的递增值是连续的</strong>。</p><p>这样的并发潜力是很低下的，所以 InnoDB 提供了 <strong>innodb_autoinc_lock_mode</strong> 的不同取值来提供不同的锁定机制。</p><ol><li><p><strong>innodb_autoinc_lock_mode = 0</strong>（传统锁定模式）</p></li><li><p><strong>innodb_autoinc_lock_mode = 1</strong>（连续锁定模式）</p></li><li><p><strong>innodb_autoinc_lock_mode =</strong> <strong>2</strong>（交错锁定模式）</p></li></ol><ul><li>元数据锁（MDL 锁）</li></ul><blockquote><p>它的作用是保证读写的正确性。</p><p>比如说，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程正在变更这个表的结构，那么查询线程拿到的结果可能与表结构对不上。</p></blockquote><ol><li><strong>当对一个表进行 CRUD 时，加 MDL 读锁</strong>；</li><li><strong>当对表做结构性变更时，加 MDL 写锁</strong>。</li></ol><blockquote><p>MDL 锁保证了 DML 和 DDL 操作之间的一致性问题，<strong>不需要显式使用</strong></p></blockquote><h3 id="2、页锁"><a href="#2、页锁" class="headerlink" title="2、页锁"></a>2、页锁</h3><ul><li>页锁就是在<strong>页的粒度</strong>上进行锁定，锁定粒度和并发度处于行锁和表锁之间，<strong>页锁也会出现死锁</strong></li><li>每个层级的锁数量是有限制的，因为锁会占用内存空间，<strong>锁空间的大小是有限的</strong>。当某个层级的锁数量超过这个层级的阈值时，就会进行<strong>锁升级</strong>。</li></ul><blockquote><p>锁升级就是用更大粒度的锁代替多个小粒度的锁，这样做的好处是占用的锁空间降低，缺点是并发度也会随之下降。</p></blockquote><h3 id="3、行锁介绍"><a href="#3、行锁介绍" class="headerlink" title="3、行锁介绍"></a>3、行锁介绍</h3><blockquote><p>行锁，也称为<strong>记录锁</strong>，顾名思义，就是锁住某条记录。需要注意的是，MySQL 服务器层没有实现行锁机制，<strong>行级锁只在存储引擎层实现</strong></p></blockquote><ul><li>优点：<strong>锁定粒度小，发生所冲突概率低，可以实现的并发度高</strong>。</li><li>缺点：<strong>对于锁的开销比较大，加锁比较慢，容易出现死锁</strong></li></ul><ol><li>记录锁</li></ol><blockquote><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>，<strong>记录锁仅仅对锁住的记录有作用，对周围其他的数据没有影响</strong>。</p></blockquote><ol start="2"><li>间隙锁</li></ol><blockquote><p>MySQL 在<strong>可重复读</strong>隔离级别下可以解决幻读，解决方案有两种，一是 MVCC ，二是使用加锁方式解决。但是在加锁时有个问题需要解决，就是事务在第一次执行读操作时，那些幻影记录尚未存在，所以我们没办法给那些幻影 记录加上记录锁。</p><p>InnoDB 提出了一种名为间隙锁的锁，比如说，将 id 为 8 的记录加一个间隙锁的示意图如下：</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165356.png" alt="image.png"></p><blockquote><p>图中 id 值为 8 的记录加了间隙锁，这意味着<strong>不允许别的事务在 id 为 8 的记录前边的间隙插入新纪录</strong>，也就是 id 列的值为（3，8）这个区间的新纪录是不允许立即插入的，只有这个拥有间隙锁的事务提交了之后，该区间内的新纪录才允许被插入。</p><p><strong>间隙锁仅仅是为了防止插入幻影记录而提出的</strong>，虽然有共享间隙锁和排他间隙锁的说法，但是二者起到的作用是相同的。而且<strong>如果对一条记录加了间隙锁，并不会限制其他事务对这条记录加记录锁或者继续加间隙锁</strong>。</p></blockquote><ol start="3"><li>临键锁（Next-key-lock）</li></ol><blockquote><p><strong>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新纪录</strong>，所以 InnoDB 就提出了一种称为临键锁的锁</p><p><strong>临键锁的本质就是一个记录锁 + 间隙锁的合体。</strong></p></blockquote><ol start="4"><li>插入意向锁</li></ol><blockquote><p>我们说一个事务在插入一条记录时需要判断一下插入位置是否被其他事务加锁了，如果有的话，那么插入操作需要等待，直到拥有间隙锁的事务提交。</p><p><strong>但是 InnoDB 规定事务在等待的时候也需要在内存中生成一个锁结构，表明该事务想在某个间隙中插入新纪录，但是现在在等待</strong>。</p><p>InnoDB 就将这种类型的锁命名为<strong>插入意向锁</strong>。这个锁用于表示插入意向，和多个事务在同意区间插入位置不同的多条数据时，事务之间不需要互相等待。</p></blockquote><p>假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的锁前，都会获取 （4，7）之间的间隙锁，但由于数据之间并不冲突，所以两个事务之间不会产生冲突。</p><blockquote><p><strong>插入意向锁是一种特殊的间隙锁 – 间隙锁可以锁定开区间内的部分记录。</strong></p><p><strong>插入意向锁之间并不排斥</strong>，所以即使多个事务在同一区间插入多条记录，只要记录本身（主键、唯一索引）不冲突，那么事务之间就不会出现冲突。</p></blockquote><p><strong>插入意向锁是行锁。</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165359.png" alt="image.png"></p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>MySQL高级学习（五）-MySQL学习补充</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/1528548504.html">https://sutianxin.top/posts/1528548504.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2022-02-17</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2022-02-17</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%F0%9F%A4%93%E6%95%B0%E6%8D%AE%E5%BA%93/">🤓数据库</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217165848.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/405834138.html"><img class="prev-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220318184629.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java面试总结（五）</div></div></a></div><div class="next-post pull-right"><a href="/posts/3795621089.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220217164531.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis学习手册（五）--Redis 学习补充</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2904493033.html" title="MySQL高级学习（四）-MySQL日志和主从复制"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504190201.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-12</div><div class="title">MySQL高级学习（四）-MySQL日志和主从复制</div></div></a></div><div><a href="/posts/1389856525.html" title="MySQL高级学习（一）-初识索引、复习视图、存储过程和函数以及触发器的学习"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504191217.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-07</div><div class="title">MySQL高级学习（一）-初识索引、复习视图、存储过程和函数以及触发器的学习</div></div></a></div><div><a href="/posts/2442351397.html" title="MySQL高级学习（三）-MySQL锁问题、常用技巧和内存优化"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504190245.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-11</div><div class="title">MySQL高级学习（三）-MySQL锁问题、常用技巧和内存优化</div></div></a></div><div><a href="/posts/1929898991.html" title="Redis学习手册（四）"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210425220116.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-25</div><div class="title">Redis学习手册（四）</div></div></a></div><div><a href="/posts/2827403991.html" title="Java应用学习（九）-Spring Security学习笔记（一）"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504185916.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-08</div><div class="title">Java应用学习（九）-Spring Security学习笔记（一）</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81MySQL-%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-text">一、MySQL 的日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97"><span class="toc-text">1.1、错误日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-text">1.2、二进制日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">2、日志的位置和格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81mysqlbinlog-%E5%B7%A5%E5%85%B7"><span class="toc-text">3、mysqlbinlog 工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%97%A5%E5%BF%97%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-text">4、日志的读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81binlog-%E7%9A%84%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-text">5、binlog 的刷盘时机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">1.3、查询日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E3%80%81%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">1.4、慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-1"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE%E5%8F%8A%E6%A0%BC%E5%BC%8F"><span class="toc-text">2、文件位置及格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%97%A5%E5%BF%97%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-text">3、日志的读取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81InnoDB-%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-text">二、InnoDB 的事务日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81redo-log-%E5%92%8C-binlog-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.2、redo log 和 binlog 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81redo-log"><span class="toc-text">2.3、redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81redo-log-%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">1、redo log 的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">2、持久化的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86-binlog-%E8%BF%98%E9%9C%80%E8%A6%81-redo-log-%EF%BC%9F"><span class="toc-text">3、为什么有了 binlog 还需要 redo log ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81InnoDB-%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">4、InnoDB 的两阶段提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81MySQL-%E5%BC%82%E5%B8%B8%E9%87%8D%E5%90%AF%E5%90%8E%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%EF%BC%9F"><span class="toc-text">5、MySQL 异常重启后如何保证数据完整？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81undo-log"><span class="toc-text">2.4、undo log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-2"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81undo-log-%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">2、undo log 的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">3、工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E3%80%81MySQL-%E8%84%8F%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-text">2.5、MySQL 脏读、幻读和不可重复读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%87%BA%E7%8E%B0%E5%9C%BA%E6%99%AF"><span class="toc-text">1、脏读、不可重复读、幻读的区别和出现场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">2、事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-text">3、数据库并发场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81MVCC"><span class="toc-text">三、MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">3.2、快照读和当前读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">1、当前读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-text">2、快照读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81MVCC-%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3、MVCC 和快照读的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81MVCC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">3.3、MVCC 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-text">1、版本链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81undo-log"><span class="toc-text">2、undo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Read-View"><span class="toc-text">3、Read View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96"><span class="toc-text">4、读已提交的数据提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96"><span class="toc-text">5、可重复读的数据提取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MySQL-%E5%AD%A6%E4%B9%A0%E8%A1%A5%E5%85%85"><span class="toc-text">四、MySQL 学习补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%A1%A5%E5%85%85"><span class="toc-text">4.1、存储引擎补充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.2、存储引擎介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81InnoDB-%E5%BC%95%E6%93%8E"><span class="toc-text">1、InnoDB 引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81MyISAM-%E5%BC%95%E6%93%8E"><span class="toc-text">2、MyISAM 引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Archive-%E5%BC%95%E6%93%8E"><span class="toc-text">3、Archive 引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Memory-%E5%BC%95%E6%93%8E"><span class="toc-text">4、Memory 引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">4.3、联合索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81InnoDB-%E7%9A%84-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">4.4、InnoDB 的 B+ 树索引的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A0%B9%E9%A1%B5%E9%9D%A2%E4%BD%8D%E7%BD%AE%E4%B8%87%E5%B9%B4%E4%B8%8D%E5%8A%A8"><span class="toc-text">1、根页面位置万年不动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%86%85%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-text">2、内节点中目录项记录的唯一性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%80%E4%B8%AA%E9%A1%B5%E6%9C%80%E5%B0%91%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E4%B8%A4%E6%9D%A1%E6%95%B0%E6%8D%AE"><span class="toc-text">3、一个页最少可以存储两条数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E3%80%81MyISAM-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">4.5、MyISAM 索引的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81MyISAM-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">1、MyISAM 索引的原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81InnoDB-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">五、InnoDB 数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E2%80%93-%E9%A1%B5"><span class="toc-text">5.1、数据库的存储结构 – 页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D-%E2%80%93-%E9%A1%B5"><span class="toc-text">1、磁盘与内存交互的基本单位 – 页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-text">2、页结构概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">3、页的上层结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">5.2、页的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B4%E5%92%8C%E6%96%87%E4%BB%B6%E5%B0%BE"><span class="toc-text">1、文件头和文件尾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AE%B0%E5%BD%95"><span class="toc-text">2、记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%A1%B5%E7%9B%AE%E5%BD%95%E5%92%8C%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8"><span class="toc-text">3、页目录和页面头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81COMPACT-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">4、COMPACT 行格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3"><span class="toc-text">六、优化相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">6.1、索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84-11-%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">1、适合创建索引的 11 种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84-7-%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">2、不适合创建索引的 7 种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%99%90%E5%88%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-text">3、限制索引的数目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81JOIN-%E8%AF%AD%E5%8F%A5%E5%8E%9F%E7%90%86"><span class="toc-text">6.2、JOIN 语句原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Simple-Nested-Loop-Join%EF%BC%88%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-text">1、Simple Nested-Loop Join（简单嵌套循环连接）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Index-Nested-Loop-Join%EF%BC%88%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-text">2、Index Nested-Loop Join（索引嵌套循环连接）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Block-Nested-Loop-Join"><span class="toc-text">3、Block Nested-Loop Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Join-%E5%B0%8F%E7%BB%93"><span class="toc-text">4、Join 小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Hash-Join"><span class="toc-text">5、Hash Join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81SQL-%E4%BC%98%E5%8C%96"><span class="toc-text">6.3、SQL 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">1、子查询优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-text">2、排序优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">3、分页查询优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%94%81"><span class="toc-text">七、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">7.1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81MySQL-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-text">7.2、MySQL 并发事务访问相同的记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AF%BB-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-text">1、读 - 读情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%86%99-%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-text">2、写 - 写情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%AF%BB-%E5%86%99%E6%88%96%E8%80%85%E5%86%99-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-text">3、读 - 写或者写 - 读情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81%E9%94%81%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A7%92%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="toc-text">7.3、锁的不同角度分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E3%80%81%E8%AF%BB%E9%94%81%E4%B8%8E%E5%86%99%E9%94%81"><span class="toc-text">7.4、读锁与写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E3%80%81%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81"><span class="toc-text">7.5、表级锁、页级锁和行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%A1%A8%E9%94%81"><span class="toc-text">1、表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%A1%B5%E9%94%81"><span class="toc-text">2、页锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A1%8C%E9%94%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">3、行锁介绍</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init({el:"#twikoo-wrap",envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai"})},e=()=>{twikoo.getCommentsCount({envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then(function(o){t.innerText=o[0].count}).catch(function(o){console.error(o)})};var n;n=!0,"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" data-lrctype="0" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_yegv7kt2bj.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.js"></script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><script src="https://www.luckyclover.top/rain.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"]):not([href="/contact/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>