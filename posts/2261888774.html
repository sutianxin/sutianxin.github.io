<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构与算法学习（二十一）-动态规划 | Arno</title><meta name="keywords" content="☕Java,💻后端学习"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="刷题笔记，小孩子不懂事刷着玩的"><meta property="og:type" content="article"><meta property="og:title" content="数据结构与算法学习（二十一）-动态规划"><meta property="og:url" content="https://sutianxin.top/posts/2261888774.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="刷题笔记，小孩子不懂事刷着玩的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319220441.jpg"><meta property="article:published_time" content="2022-03-19T14:01:48.879Z"><meta property="article:modified_time" content="2022-03-19T14:05:18.390Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="☕Java"><meta property="article:tag" content="💻后端学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319220441.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/2261888774"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-03-19 22:05:18"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,a={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(a)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">85</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/blogImage/raw/master/img/20220319220441.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法学习（二十一）-动态规划</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-19T14:01:48.879Z" title="发表于 2022-03-19 22:01:48">2022-03-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-19T14:05:18.390Z" title="更新于 2022-03-19 22:05:18">2022-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25.1k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、反转链表"><a href="#1、反转链表" class="headerlink" title="1、反转链表"></a>1、反转链表</h2><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p></blockquote><h3 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>由于递归反转链表的空间复杂度为 O(n)，故本题使用迭代的方式来完成反转链表</li><li>在遍历链表时，将当前节点的 next 指针指向前一个节点，由于单链表中的节点无法得知前一个节点，所以我们需要使用一个 <code>prev</code> 变量存储当前节点的前一个结点，同时，由于我们需要将当前节点的 <code>next</code> 指向前一个节点，那么为了防止当前节点后续节点丢失，所以我们需要用一个变量来保存当前节点的下一个节点。</li></ul><h3 id="3、解题代码"><a href="#3、解题代码" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// prev 表示当前遍历节点的前一个节点，初始化为 null ，因为 head 的前一个节点为 null，而 cur 表示当前正在遍历的节点</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用一个临时变量保存当前节点的下一个节点</span></span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        <span class="comment">// 让当前节点的next指向前一个节点</span></span><br><span class="line">        cur.next = prev;</span><br><span class="line">        <span class="comment">// 让 prev 移动到当前节点的位置</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        <span class="comment">// 让 cur 指向链表的下一个位置，继续遍历</span></span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后返回 prev ，因为退出循环时 cur 为空</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、K-个一组反转链表"><a href="#2、K-个一组反转链表" class="headerlink" title="2、K 个一组反转链表"></a>2、K 个一组反转链表</h2><h3 id="1、题目描述-1"><a href="#1、题目描述-1" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表，<em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p></blockquote><ul><li>示例一</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215621.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215631.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-1"><a href="#2、解题思路-1" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>先反转以 <code>head</code> 为开头的前 k 个元素</li><li>然后以第 <code>k + 1</code> 个元素作为 <code>head</code> ，继续递归调用 <code>reverseGroup</code> 函数</li><li>将上述结果连接起来</li><li>如果剩下的元素不足 k 个，那么就保持不变</li></ul><h3 id="3、解题代码-1"><a href="#3、解题代码-1" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">// 我们反转区间 [begin, end) 的节点</span></span><br><span class="line">       ListNode begin = head, end = head;</span><br><span class="line">       <span class="comment">// 如果节点不足 k 个，那么就不需要反转</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (end == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">           end = end.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 反转前 k 个元素，即 [begin, end)</span></span><br><span class="line"><span class="comment">// 反转后，得到的链表以 newHead 为头，以 begin 为尾</span></span><br><span class="line">       ListNode newHead = reverseInRange(begin, end);</span><br><span class="line"><span class="comment">// 所以让 尾部节点的 next 指向后续链表</span></span><br><span class="line">       <span class="comment">// 递归反转后将后续链表连接起来</span></span><br><span class="line">       begin.next = reverseKGroup(end, k);</span><br><span class="line">       <span class="keyword">return</span> newHead;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在范围内反转链表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseInRange</span><span class="params">(ListNode begin, ListNode end)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (begin == end || begin.next == end) <span class="keyword">return</span> begin;</span><br><span class="line">       ListNode prev = <span class="keyword">null</span>, cur = begin;</span><br><span class="line">       <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">           ListNode next = cur.next;</span><br><span class="line">           cur.next = prev;</span><br><span class="line">           prev = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> prev;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3、两两交换链表中的节点"><a href="#3、两两交换链表中的节点" class="headerlink" title="3、两两交换链表中的节点"></a>3、两两交换链表中的节点</h2><h3 id="1、题目描述-2"><a href="#1、题目描述-2" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p></blockquote><ul><li>示例一</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215635.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-2"><a href="#2、解题思路-2" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>在这道题中，由于我们需要将相邻节点两两交换，那么最终得到的链表的头节点将会与题目所给的头节点不同，对于这种头节点会发生改变的问题，我们可以创建一个虚拟头节点，即 <code>ListNode virtual = head.next</code></li><li>创建一个 ListNode 类型的变量 now ，我们记 <code>now</code> 与 <code>now</code> 之前的链表为已经翻转完毕的链表</li><li>创建一个 ListNode 类型的变量 left ，它表示 now 的下一个节点，同时创建一个 ListNode 类型的变量 right ，它表示 now 的下下个节点</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215639.png" alt="image.png"></p><ul><li>接下来我们进行节点的交换，让 now.next = right ，然后 让 left.next = right.next ，最后让 right.next = left</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215643.png" alt="image.png"></p><ul><li>这样做完之后，我们重新按照指针编排链表，就可以看到链表已经变为了 x -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 ，然后我们更新 now 指针，将 now 移动到 left 的位置，然后重复上面的步骤即可。</li><li>最后返回 virtualHead.next 即可。</li></ul><h3 id="3、解题代码-2"><a href="#3、解题代码-2" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 创建一个虚拟头节点，让它的 next 域指向 head</span></span><br><span class="line">    ListNode virtualHead = <span class="keyword">new</span> ListNode(Integer.MAX_VALUE);</span><br><span class="line">    virtualHead.next = head;</span><br><span class="line">    <span class="comment">// 其中 left 表示 now 的下一个节点，而 right 表示 now 下下个节点，这里不再这里赋值，因为可能会报空指针</span></span><br><span class="line">    ListNode now = virtualHead, left = <span class="keyword">null</span>, right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (now.next != <span class="keyword">null</span> &amp;&amp; now.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        left = now.next;</span><br><span class="line">        right = now.next.next;</span><br><span class="line">        <span class="comment">// 进行交换</span></span><br><span class="line">        <span class="comment">//1 让 now 的 next 指向 right </span></span><br><span class="line">        now.next = right;</span><br><span class="line">        <span class="comment">//2 让 left 的 next 指向 right 的下一个节点，因为最后的关系是 now -&gt; right -&gt; left -&gt; xxx</span></span><br><span class="line">        left.next = right.next;</span><br><span class="line">        <span class="comment">//3 让 right 的 next 指向 left</span></span><br><span class="line">        right.next = left;</span><br><span class="line">        <span class="comment">//4 最后让 now 指向 left </span></span><br><span class="line">        now = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后返回虚拟头节点的下一个节点</span></span><br><span class="line">    <span class="keyword">return</span> virtualHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、合并二叉树"><a href="#4、合并二叉树" class="headerlink" title="4、合并二叉树"></a>4、合并二叉树</h2><h3 id="1、题目描述-3"><a href="#1、题目描述-3" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p></blockquote><ul><li>示例一</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215650.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>], root2 = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [<span class="number">1</span>], root2 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-3"><a href="#2、解题思路-3" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>递归 + 前序遍历来解决这个问题，其实这道题使用什么顺序的递归都没有问题</li><li>确定终止条件</li></ul><blockquote><p>当传入的树有一棵为空时，就应该结束递归</p></blockquote><ol><li>如果 root1 为空，那么合并的结果就是 root2</li><li>如果 root2 为空，那么合并的结果就是 root1</li></ol><ul><li>让 root2 的 val 合并到 root1 的 val 中</li><li>最后分别递归左右子树，让 root1 的左子树、右子树与 root2 的左子树、右子树合并</li></ul><h3 id="3、解题代码-3"><a href="#3、解题代码-3" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 root1 为空，那么当前两棵树的合并结果为 root2</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">    <span class="comment">// 同理</span></span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">    <span class="comment">// 执行本层的合并逻辑，这里我们以 root1 为主</span></span><br><span class="line">    root1.val += root2.val;</span><br><span class="line">    <span class="comment">// 让 root1 的左子树为两棵树左子树的合并结果</span></span><br><span class="line">    root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">    root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">    <span class="comment">// 返回 root1 ，它是合并结果</span></span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、最长回文子串"><a href="#5、最长回文子串" class="headerlink" title="5、最长回文子串"></a>5、最长回文子串</h2><h3 id="1、题目描述-4"><a href="#1、题目描述-4" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-4"><a href="#2、解题思路-4" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用动态规划解题</li></ul><ol><li>明确 dp 数组的含义</li></ol><blockquote><p>我们需要创建一个二维的 boolean 数组，它的长度和宽度均为 <code>s.length()</code> ，其中 <code>dp[i][j]</code> 表示子串 <code>s[i, j]</code> 是否为回文串</p></blockquote><ol start="2"><li>初始化 dp 数组</li></ol><blockquote><p>字符串中任意一个字符都可以看为一个回文字符串，即 <code>dp[i][i] = true</code></p></blockquote><ol start="3"><li>状态转移方程</li></ol><blockquote><p>对于 <code>dp[i][j]</code> ，当 <code>s.charAt(i) == s.charAt(j)</code> 时，有 <code>dp[i][j] = dp[i + 1][j - 1]</code> ；</p><p>当 <code>s.charAt(i) != s.charAt(j)</code> 时，有 <code>dp[i][j] = false</code> ；</p></blockquote><ol start="4"><li>我们需要使用一个变量来保存最长回文子串</li></ol><h3 id="3、解题代码-4"><a href="#3、解题代码-4" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><ul><li>使用动态规划求解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">    String result = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; len;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charArray[i] == charArray[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果 j == i + 1 且 i , j 指针指向的字符相等，那么直接可以将 dp[i][j] 置为 true</span></span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLength) &#123;</span><br><span class="line">                maxLength = j - i + <span class="number">1</span>;</span><br><span class="line">                result = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、求最大公共前缀"><a href="#6、求最大公共前缀" class="headerlink" title="6、求最大公共前缀"></a>6、求最大公共前缀</h2><h3 id="1、题目描述-5"><a href="#1、题目描述-5" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-5"><a href="#2、解题思路-5" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>我们以字符串数组中的第一个字符串为准，使用一个全局变量保存最长公共前缀长度的值，然后循环遍历字符串数组，然后获取第一个字符串与后续字符串的公共前缀长度，然后更新全局变量的值。</li></ul><h3 id="3、解题代码-5"><a href="#3、解题代码-5" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">char</span>[] firstCharArray = strs[<span class="number">0</span>].toCharArray();</span><br><span class="line">    <span class="keyword">int</span> longestCommonPrefixLength = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; strs.length;i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] tempArray = strs[i].toCharArray();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; firstCharArray.length &amp;&amp; index &lt; tempArray.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstCharArray[index] != tempArray[index]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        longestCommonPrefixLength = Math.min(longestCommonPrefixLength, index);</span><br><span class="line">        <span class="keyword">if</span> (longestCommonPrefixLength == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, longestCommonPrefixLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、链表排序"><a href="#7、链表排序" class="headerlink" title="7、链表排序"></a>7、链表排序</h2><h3 id="1、题目描述-6"><a href="#1、题目描述-6" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p></blockquote><h3 id="2、解题思路-6"><a href="#2、解题思路-6" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用<strong>归并排序</strong>解决这道题</li></ul><blockquote><p>按照归并排序的思路进行操作，使用快慢指针来寻找链表的中点</p></blockquote><ul><li>使用小顶堆来解决这个问题</li></ul><blockquote><p>使用一个小顶堆，将链表节点依次加入到小顶堆中，然后再将节点逐个从堆中弹出。</p></blockquote><h3 id="3、解题代码-6"><a href="#3、解题代码-6" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><ul><li>使用小顶堆来解决这个问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.val - o2.val);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        minHeap.add(head);</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode result = <span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode cur = result;</span><br><span class="line">    <span class="keyword">while</span> (minHeap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur.next = minHeap.poll();</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用归并排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 寻找中点</span></span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时，慢指针指向中点位置</span></span><br><span class="line">    ListNode temp = slow.next;</span><br><span class="line">    <span class="comment">// 将链表分为两部分，即[head, mid(slow)] 和 [temp, ...]</span></span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 向下递归，分治</span></span><br><span class="line">    ListNode left = sortList(head);</span><br><span class="line">    ListNode right = sortList(temp);</span><br><span class="line">    <span class="comment">// 向上合并</span></span><br><span class="line">    <span class="comment">// 虚拟头节点</span></span><br><span class="line">    ListNode virtualHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode cur = virtualHead;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">            cur.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时一定有一个指针为空（left、right），同时另外一截不为空的链表一定也是有序的，所以直接接在后面就可以了</span></span><br><span class="line">    cur.next = (left == <span class="keyword">null</span>) ? right : left;</span><br><span class="line">    <span class="keyword">return</span> virtualHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、验证回文字符串-II"><a href="#8、验证回文字符串-II" class="headerlink" title="8、验证回文字符串 II"></a>8、验证回文字符串 II</h2><h3 id="1、题目描述-7"><a href="#1、题目描述-7" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;aba&quot;</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-7"><a href="#2、解题思路-7" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用双指针解决这道题</li></ul><blockquote><p>一个指针从头开始，一个指针从尾巴开始，当两个指针指向的字符不等时，此时我们再给它一次机会</p></blockquote><ul><li>创建一个方法，这个方法用于判断字符串下标范围处于 <code>[left, right]</code> 的那部分子串是否为严格的回文串</li><li>当 <code>s.charAt(left) == s.charAt(right)</code> 时，此时让左指针右移动，右指针左移</li><li>当 <code>s.charAt(left) != s.charAt(right)</code> 时，此时我们再给它一次机会，判断 <code>s[left + 1,right]</code> 或者 <code>s[left, right - 1]</code> 中是否有一个为回文串，如果有，那么返回 true ，否则返回 false</li></ul><h3 id="3、解题代码-7"><a href="#3、解题代码-7" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><ul><li>判断某个子串是否为严格回文串的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">          <span class="comment">// 如果两个指针指向的字符相等，那么让左指针右移，右指针左移</span></span><br><span class="line">          <span class="keyword">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">              left++;</span><br><span class="line">              right--;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果不等，那么再给它一次机会。</span></span><br><span class="line">              <span class="keyword">return</span> isPalindrome(s, left + <span class="number">1</span>, right) || isPalindrome(s, left, right - <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">1</span> || left &gt;= right) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">          <span class="keyword">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">              left++;</span><br><span class="line">              right--;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="9、回文链表"><a href="#9、回文链表" class="headerlink" title="9、回文链表"></a>9、回文链表</h2><h3 id="1、题目描述-8"><a href="#1、题目描述-8" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个链表的头节点 <strong><code>head</code> ，</strong> 请判断其是否为回文链表。</p><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-8"><a href="#2、解题思路-8" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>找到链表中点</li><li>反转后半部分链表</li><li>判断前半段链表和后半段链表是否相等</li></ul><h3 id="3、解题代码-8"><a href="#3、解题代码-8" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 找到链表中点，使用快慢指针</span></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时，slow的下一个节点就是后半部分链表的头节点。</span></span><br><span class="line">    ListNode temp = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    temp = reverseList(temp);</span><br><span class="line">    slow.next = temp;</span><br><span class="line">    <span class="comment">// 进行比较</span></span><br><span class="line">    fast = head;</span><br><span class="line">    slow = temp;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow.val != fast.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于反转链表的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>, cur = node;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、有效的山脉数组"><a href="#10、有效的山脉数组" class="headerlink" title="10、有效的山脉数组"></a>10、有效的山脉数组</h2><h3 id="1、题目描述-9"><a href="#1、题目描述-9" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个整数数组 <code>arr</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p><p>让我们回顾一下，如果 <code>arr</code> 满足下述条件，那么它是一个山脉数组：</p></blockquote><ul><li><code>arr.length &gt;= 3</code></li><li>在 <code>0 &lt; i &lt; arr.length - 1</code> 条件下，存在 <code>i</code> 使得：<ul><li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i]</code></li><li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul></li></ul><h3 id="2、解题思路-9"><a href="#2、解题思路-9" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用双指针，一个从左往右找最高点，一个从右往左找最高点，然后判断两个指针找到的最高点是不是同一个，如果是，返回 true，否则返回 false</li></ul><h3 id="3、解题代码-9"><a href="#3、解题代码-9" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当满足 arr[left] 小于 arr[left + 1] 时，不是证明此时的 left 不是最高峰的下标，所以 left++</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= arr.length - <span class="number">2</span> &amp;&amp; arr[left] &lt; arr[left + <span class="number">1</span>]) &#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理，所以 right--;</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt;= <span class="number">1</span> &amp;&amp; arr[right] &lt; arr[right - <span class="number">1</span>]) &#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里需要判断 left 和 right 是否越界，比如说 [0,1,2,3,4,5,6,7,8,9] ，这种情况下，它不是山脉数组，但 left == right == len - 1</span></span><br><span class="line">    <span class="keyword">return</span> left &gt; <span class="number">0</span> &amp;&amp; right &lt; arr.length - <span class="number">1</span> &amp;&amp; left == right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、数组中的最长山脉"><a href="#11、数组中的最长山脉" class="headerlink" title="11、数组中的最长山脉"></a>11、数组中的最长山脉</h2><h3 id="1、题目描述-10"><a href="#1、题目描述-10" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>把符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：</p></blockquote><ul><li><code>arr.length &gt;= 3</code></li><li>在 <code>0 &lt; i &lt; arr.length - 1</code> 条件下，存在 <code>i</code> 使得：<ul><li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i]</code></li><li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul></li></ul><blockquote><p>给出一个整数数组 <code>arr</code>，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 <code>0</code> 。</p></blockquote><ol><li>示例一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：最长的山脉子数组是 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>]，长度为 <span class="number">5</span>。</span><br></pre></td></tr></table></figure><ol start="2"><li>示例二</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在山脉子数组。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-10"><a href="#2、解题思路-10" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用动态规划求解这道题，这道题其实与接雨水差不多</li><li>我们创建两个数组，即从左到右依次升高的数组，称为 <code>increase</code> ，其中 <code>increase[i]</code> 表示数组元素 <code>arr[i]</code> 左边小于它且连续的元素个数，比如说 <code>[1,2,3,4,3,2,1]</code> 中 <code>increase[3]</code> 的值为 3 ，它表示数组元素 4 左边有<strong>三个</strong>递增且连续小于它的数</li><li>同理，我们创建一个从左往右依次递减的数组 <code>decrease</code> ，其中 <code>decrease[i]</code> 表示数组元素 <code>arr[i]</code> 右边小于它且连续的元素个数。</li><li>遍历数组中的元素，我们遍历的范围为 [1, len - 2] ，因为和接雨水差不多，第一个和最后一个元素不可能作为山峰的顶点存在。</li></ul><blockquote><p>当 <code>increase[i]</code> 与 <code>decrease[i]</code> 均不为 0 时，我们才计算 <code>arr[i]</code> 作为顶点的山脉长度，以 <code>arr[i]</code> 作为顶点的山脉长度 <code>len</code> 为 <code>decrease[i] + increase[i] + 1</code> ，其中 1 表示 arr[i] 这个元素的固有长度。</p><p>当这两个值有一个为空时，直接值为 0 即可。</p></blockquote><h3 id="3、解题代码-10"><a href="#3、解题代码-10" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="comment">// 创建一个数组，其中第一个为从左往右依次递增的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] increase = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// 第二个数组为从左往右依次递减的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] decrease = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// 初始化 increase 数组和 decrease 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素的上一个元素小于当前元素，那么可以将当前元素放到以 arr[i - 1] 为结尾的递增序列中</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &lt; arr[i]) &#123;</span><br><span class="line">            increase[i] = increase[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            decrease[i] = decrease[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历数组元素，寻找最长山脉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len - <span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> curSize = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 只有当 increase[i] 和 decrease[i] 均不为空时，山脉长度才有效</span></span><br><span class="line">        <span class="keyword">if</span> (increase[i] != <span class="number">0</span> &amp;&amp; decrease[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            curSize = decrease[i] + increase[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(curSize, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12、买卖股票的最佳时机-III"><a href="#12、买卖股票的最佳时机-III" class="headerlink" title="12、买卖股票的最佳时机 III"></a>12、买卖股票的最佳时机 III</h2><h3 id="1、题目描述-11"><a href="#1、题目描述-11" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：在第 <span class="number">4</span> 天（股票价格 = <span class="number">0</span>）的时候买入，在第 <span class="number">6</span> 天（股票价格 = <span class="number">3</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">3</span>-<span class="number">0</span> = <span class="number">3</span> 。</span><br><span class="line">     随后，在第 <span class="number">7</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">8</span> 天 （股票价格 = <span class="number">4</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">4</span>-<span class="number">1</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。   </span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-11"><a href="#2、解题思路-11" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>确定 dp 数组的含义</li></ul><blockquote><p><code>dp[i][j]</code> 中 i 表示第 i 天，j 为 [0 - 4] 五个状态，<code>dp[i][j]</code> 表示第 i 天状态 j 所剩的最大现金。</p></blockquote><ol><li>0 没有操作</li><li>第一次买入</li><li>第一次卖出</li><li>第二次买入</li><li>第二次卖出</li></ol><ul><li>确定递推公式</li></ul><ol><li>达到 dp[i][1] 状态，有两个具体操作</li></ol><blockquote><p>操作一：第 i 天第一次买入股票，那么 <code>dp[i][1] = dp[i - 1][0] - prices[i]</code></p><p>操作二：第 i 天没有操作，在第 i - 1 天已经买入了，那么 <code>dp[i][1] = dp[i - 1][1]</code></p></blockquote><ol start="2"><li>达到 dp[i][2] 状态，有两个操作：</li></ol><blockquote><p>操作一：第 i 天卖出股票，此时 <code>dp[i][2] = dp[i - 1][1] + prices[i]</code></p><p>操作二：第 i 天不操作，在第 i - 1 天已经卖出了，那么 <code>dp[i][2] = dp[i - 1][2]</code></p></blockquote><ol start="3"><li>同理有 <code>dp[i][3] = Math.max(dp[i - 1][3], dp[i][2] - prices[i])</code>，<code>dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]</code></li></ol><ul><li>初始化 dp 数组</li></ul><blockquote><p>初始化 <code>dp[0][0] = 0</code> ，<code>dp[0][1] = -prices[0]</code> ，<code>dp[0][3] = -prices[0]</code></p></blockquote><h3 id="3、解题代码-11"><a href="#3、解题代码-11" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length = prices.length;</span><br><span class="line">    <span class="comment">// 创建 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用滚动变量进行优化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length = prices.length;</span><br><span class="line">    <span class="comment">// 创建 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] - prices[i]);</span><br><span class="line">        dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[<span class="number">3</span>] = Math.max(dp[<span class="number">3</span>], dp[<span class="number">2</span>] - prices[i]);</span><br><span class="line">        dp[<span class="number">4</span>] = Math.max(dp[<span class="number">4</span>], dp[<span class="number">3</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13、买卖股票的最佳时机-IV"><a href="#13、买卖股票的最佳时机-IV" class="headerlink" title="13、买卖股票的最佳时机 IV"></a>13、买卖股票的最佳时机 IV</h2><h3 id="1、题目描述-12"><a href="#1、题目描述-12" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">2</span>, prices = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：在第 <span class="number">1</span> 天 (股票价格 = <span class="number">2</span>) 的时候买入，在第 <span class="number">2</span> 天 (股票价格 = <span class="number">4</span>) 的时候卖出，这笔交易所能获得利润 = <span class="number">4</span>-<span class="number">2</span> = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">2</span>, prices = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天 (股票价格 = <span class="number">2</span>) 的时候买入，在第 <span class="number">3</span> 天 (股票价格 = <span class="number">6</span>) 的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span>-<span class="number">2</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">5</span> 天 (股票价格 = <span class="number">0</span>) 的时候买入，在第 <span class="number">6</span> 天 (股票价格 = <span class="number">3</span>) 的时候卖出, 这笔交易所能获得利润 = <span class="number">3</span>-<span class="number">0</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-12"><a href="#2、解题思路-12" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>我们可以按照上题的思路来解，初始化一个 <code>prices.length</code> 行 <code>2 * k + 1</code> 列的二维数组</li><li>初始化 dp 数组，当列数 j 满足 <code>j % 2 == 1</code> 时， dp[0][j] 初始化为 <code>-prices[0]</code> ，否则初始化为 0</li><li>状态转移数组，当列数 j 满足 <code>j % 2 == 1</code> 时，此时证明我们需要买入股票，此时 <code>dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i])</code>；当列数 <code>j % 2 == 0</code> 时，此时证明我们要卖出股票，此时 <code>dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i])</code></li></ul><blockquote><p>最后我们返回二维数组中最后一个元素，表示我们进行了 k 次交易后所能获取的最大收益。</p></blockquote><h3 id="3、解题代码-12"><a href="#3、解题代码-12" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，我们需要初始化 dp[0][1]、 dp[0][3] ... dp[2 * k + 1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span> * k + <span class="number">1</span>;i += <span class="number">2</span>) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; <span class="number">2</span> * k + <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 买入</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 卖出</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化空间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="comment">// 创建一个 dp 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，我们初始化 dp[i] 的值（i % 2 == 1）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span> * k + <span class="number">1</span>;i += <span class="number">2</span>) &#123;</span><br><span class="line">        dp[i] = -prices[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; <span class="number">2</span> * k + <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 买入</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 卖出</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span> * k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14、圆圈中最后剩下的数字"><a href="#14、圆圈中最后剩下的数字" class="headerlink" title="14、圆圈中最后剩下的数字"></a>14、圆圈中最后剩下的数字</h2><h3 id="1、题目描述-13"><a href="#1、题目描述-13" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>0,1,···,n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">5</span>, m = <span class="number">3</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">10</span>, m = <span class="number">17</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-13"><a href="#2、解题思路-13" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>构造环形链表解决这道题</li><li>使用一个 ArrayList 来模拟约瑟夫问题</li></ul><ol><li><p>创建一个 ArrayList，将 [0, n - 1] 放入到 ArrayList 中</p></li><li><p>使用公式计算出当前需要剔除出列表中的元素下标 index ，其中 <code>index = (index + m - 1) % size</code> ，其中 size 为当前列表中的元素个数</p></li><li><p>将列表中下标为 index 的元素剔除，反复执行 2 直到列表只剩下最后一个元素</p></li><li><p>返回最后一个元素即可</p></li></ol><h3 id="3、解题代码-13"><a href="#3、解题代码-13" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList ，存放 [0, n - 1] </span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第一个人开始</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当 list 中剩余元素大于一时，根据公式剔除列表中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算要删除的下标 index</span></span><br><span class="line">        <span class="comment">// 计算公式为 (index + m - 1) % list.size()</span></span><br><span class="line">        index = (index + m - <span class="number">1</span>) % list.size();</span><br><span class="line">        <span class="comment">// 移除待删除的下标</span></span><br><span class="line">        list.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后返回列表中仅存的一个元素即可</span></span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15、使用队列实现栈"><a href="#15、使用队列实现栈" class="headerlink" title="15、使用队列实现栈"></a>15、使用队列实现栈</h2><h3 id="1、题目描述-14"><a href="#1、题目描述-14" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p></blockquote><ul><li>实现 <code>MyStack</code> 类：<ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul></li><li><strong>注意：</strong><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul></li></ul><h3 id="2、解题思路-14"><a href="#2、解题思路-14" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用两个队列实现栈</li></ul><blockquote><p>这道题与使用两个栈实现队列不一样，当我们将一个队列的数据导入另外一个队列时，数据的顺序没有发生改变，这是因为队列是先进先出的数据结构。</p><p><strong>如果使用两个队列来模拟栈，那么第一个栈是用于模拟栈，而第二个栈是用于临时存储元素的</strong></p></blockquote><ol><li>向栈中加入元素</li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215712.png" alt="image.png"></p><blockquote><p>当我们要向栈中加入元素时，我们直接将新元素添加到队列二中，比如说我们要向栈中加入 3 ，<strong>然后如果此时队列一不为空，那么我们需要更新 top 指向的值为新加入的值，而后依次从队列一弹出元素，然后加入到队列二中，最后调换队列一和队列二，此时队列一中就模拟了栈的元素顺序。</strong></p><p>如果加入元素后队列一为空，那么直接交换队列一和队列二的引用即可。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215720.png" alt="image.png"></p><ol start="2"><li>向栈中弹出元素</li></ol><blockquote><p>我们直接从队列一中弹出队首元素即可，然后我们需要更新一下 top 的值为队列的首部元素。</p></blockquote><ol start="3"><li>查看栈顶元素 <code>top()</code></li></ol><blockquote><p>直接返回 top 值即可</p></blockquote><ol start="4"><li>查看队列是否为空 <code>isEmpty()</code></li></ol><blockquote><p>直接查看当前队列一是否为空即可。</p></blockquote><ul><li>使用一个队列来模拟栈</li></ul><ol><li>添加元素</li></ol><blockquote><p>如果此时队列为空，那么直接将元素加入到队列中</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215727.png" alt="image.png"></p><blockquote><p>如果此时队列不为空，那么先将元素 x 从尾部加入到队列中，然后将 x 之前的所有元素依次从队列中弹出，然后按照顺序从尾部加入到队列中</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215730.png" alt="image.png"></p><ol start="2"><li>弹出元素：直接弹出队列首部的元素即可</li><li>查看栈顶元素：直接返回队列首部元素即可</li></ol><h3 id="3、解题代码-14"><a href="#3、解题代码-14" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><ul><li>使用两个队列模拟栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; firstQueue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; secondQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        firstQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        secondQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 将新元素直接加入到队列二中</span></span><br><span class="line">        secondQueue.add(x);</span><br><span class="line">        <span class="comment">//2 如果队列一不为空，那么需要从队列一中的元素依次弹出，然后放入到队列二中</span></span><br><span class="line">        <span class="keyword">while</span> (!firstQueue.isEmpty()) &#123;</span><br><span class="line">            secondQueue.add(firstQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3 不论如何都需要交换队列一和队列二的引用</span></span><br><span class="line">        Queue&lt;Integer&gt; temp = firstQueue;</span><br><span class="line">        firstQueue = secondQueue;</span><br><span class="line">        secondQueue = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于队列一此时模拟了栈的元素顺序，所以只需要弹出队列一的队首即可</span></span><br><span class="line">        <span class="keyword">return</span> firstQueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用一个队列来模拟栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 先将元素直接入列</span></span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="comment">// 如果队列此时只有一个元素，那么直接返回，什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> (queue.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则需要将新元素之前的所有元素依次弹出放入，然后按照顺序放入到尾部</span></span><br><span class="line">        <span class="comment">// 这里需要先记录队列的值，我们需要用这个值来判断本次需要调整多少个值</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16、最长无重复子串"><a href="#16、最长无重复子串" class="headerlink" title="16、最长无重复子串"></a>16、最长无重复子串</h2><h3 id="1、题目描述-15"><a href="#1、题目描述-15" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-15"><a href="#2、解题思路-15" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>当我们遍历到第 i 个字符时，我们设 <code>dp[i]</code> 表示以第 i 个位置为结尾的最长无重复子串的长度</li><li><code>dp[i]</code> 取决于什么？它取决为以 i - 1 个字符为结尾最长无重复子串的长度与 char[i] 的上一次出现的位置，这两个条件我们需要求一个最大值，也就是离 i 更近的情况。</li></ul><blockquote><p>我们使用一个哈希表来记录当前字符 char[i] 在字符串中上一次出现的位置</p></blockquote><ul><li>由于 <code>dp[i]</code> 只与 <code>dp[i - 1]</code> 有关，所以我们可以用一个变量来滚动更新即可。</li></ul><h3 id="3、解题代码-15"><a href="#3、解题代码-15" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> pre = -<span class="number">1</span>, cur = <span class="number">0</span>, maxLength = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="keyword">char</span>[] array = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = map.getOrDefault(array[i], -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 求 pre 的值</span></span><br><span class="line">        pre = Math.max(index, pre);</span><br><span class="line">        <span class="comment">// 求当前以第 i 个字符为结尾的最长无重复子串长度</span></span><br><span class="line">        cur = i - pre;</span><br><span class="line">        <span class="comment">// 更新最大长度</span></span><br><span class="line">        maxLength = Math.max(maxLength, cur);</span><br><span class="line">        <span class="comment">// 还要更新哈希表中第 i 个字符的最新位置</span></span><br><span class="line">        map.put(array[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17、对称二叉树"><a href="#17、对称二叉树" class="headerlink" title="17、对称二叉树"></a>17、对称二叉树</h2><h3 id="1、题目描述-16"><a href="#1、题目描述-16" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p></blockquote><ul><li>示例</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215739.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-16"><a href="#2、解题思路-16" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>如果当前传入的 root 为空，那么直接返回 true</li><li>如果当前 root 的左右子树均为空，那么返回 true ，如果左右子树不全为空，那么返回 false</li><li>然后我们需要分别递归判断左子树的右子树和右子树的左子树是否对称，左子树的左子树和右子树的右子树是否对称</li></ul><h3 id="3、解题代码-16"><a href="#3、解题代码-16" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两个节点均为空，返回 true </span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 递归判断左子树的右子树和右子树的左子树是否对称，然后判断右子树的右子树和左子树的左子树是否对称</span></span><br><span class="line">    <span class="keyword">return</span> isSymmetric(left.right, right.left) &amp;&amp; isSymmetric(left.left, right.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18、树的子结构"><a href="#18、树的子结构" class="headerlink" title="18、树的子结构"></a>18、树的子结构</h2><h3 id="1、题目描述-17"><a href="#1、题目描述-17" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构)</p><p>B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。</p></blockquote><h3 id="2、解题思路-17"><a href="#2、解题思路-17" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>如果 B 是 A 的子结构，那么必须满足以下三种情况其中之一</p></blockquote><ul><li><p>A 的根节点的值和 B 的根节点的值相等，同时 B 的左子树是 A 的左子树的子结构且 B 的右子树是 A 的右子树的子结构</p></li><li><p>A 的根节点的值与 B 的根节点的值不相等，但是 B 是 A 的左子树或者 A 的右子树的子结构</p></li></ul><h3 id="3、解题代码-17"><a href="#3、解题代码-17" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 A 树和 B 树有一个为空，那么直接返回 false ，因为题目约定空树不是任何一棵树的子结构</span></span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1 A 的根节点和 B 的根节点相同的情况，这种情况下依次比较它们的子节点</span></span><br><span class="line">    <span class="comment">//2 A 的根节点和 B 的根节点不相同的情况，这个时候使用 A 的左子树与 B 树进行对比</span></span><br><span class="line">    <span class="comment">//3 A 的根节点和 B 的根节点不相同的情况，这个时候使用 A 的右子树与 B 树进行对比</span></span><br><span class="line">    <span class="keyword">return</span> isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 B 为空，那么此时证明 B 中的节点已经完全匹配完毕</span></span><br><span class="line">    <span class="keyword">if</span> (B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果遍历过程中 B 还没为空，而 A 已经为空了，那么直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果 A 和 B 均不为空，但是此时 A B 节点的值不同，那么证明不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果当前 A 和 B 两个节点的值是匹配的，那么我们还需要递归判断左子树和右子树是否匹配</span></span><br><span class="line">    <span class="keyword">return</span> isSub(A.left, B.left) &amp;&amp; isSub(A.right, B.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19、回文子串"><a href="#19、回文子串" class="headerlink" title="19、回文子串"></a>19、回文子串</h2><h3 id="1、题目描述-18"><a href="#1、题目描述-18" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="number">6</span>个回文子串: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-18"><a href="#2、解题思路-18" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>确定 dp 数组的含义</li></ul><blockquote><p>我们定义一个二维的 dp 数组，其中 <code>dp[i][j]</code> 表示字符串 s[i, j] 是否为回文子串</p></blockquote><ul><li>初始化 dp 数组</li></ul><blockquote><p>每一个字符都是一个回文字符串</p></blockquote><ul><li>状态转移方程</li></ul><ol><li><code>s.charAt(i) == s.charAt(j)</code> ，如果此时 <code>j - i == 1</code>，那么 <code>dp[i][j] = true</code> ，此时我们就找到了一个回文子串，否则 <code>dp[i][j] = dp[i + 1][j - 1]</code></li><li><code>s.charAt(i) != s.charAt(j)</code>，<code>dp[i][j] = false</code></li></ol><ul><li>遍历顺序</li></ul><blockquote><p>由于 <code>dp[i][j]</code> 与 <code>dp[i + 1][j - 1]</code> 有关，所以对于 i ，我们需要从后往前遍历，而对于 j 我们需要正向遍历。</p></blockquote><ul><li>结果统计</li></ul><blockquote><p>使用一个 result 变量统计结果，当 <code>dp[i][j] = true</code> 时，result +=1</p></blockquote><h3 id="3、解题代码-18"><a href="#3、解题代码-18" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; len;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 此时让 result ++</span></span><br><span class="line">                    result++;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20、O-1-时间插入、删除和获取随机元素-允许重复"><a href="#20、O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="20、O(1) 时间插入、删除和获取随机元素 - 允许重复"></a>20、O(1) 时间插入、删除和获取随机元素 - 允许重复</h2><h3 id="1、题目描述-19"><a href="#1、题目描述-19" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p><code>RandomizedCollection</code> 是一种包含数字集合(可能是重复的)的数据结构。它应该支持插入和删除特定元素，以及删除随机元素。</p><p>实现 <code>RandomizedCollection</code> 类:</p></blockquote><ul><li><code>RandomizedCollection()</code> 初始化空的 <code>RandomizedCollection</code> 对象。</li><li><code>bool insert(int val)</code> 将一个 <code>val</code> 项插入到集合中，即使该项已经存在。如果该项不存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。</li><li><code>bool remove(int val)</code> 如果存在，从集合中移除一个 <code>val</code> 项。如果该项存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。注意，如果 <code>val</code> 在集合中出现多次，我们只删除其中一个。</li><li><code>int getRandom()</code> 从当前的多个元素集合中返回一个随机元素。每个元素被返回的概率与集合中包含的相同值的数量 <strong>线性相关</strong> 。</li></ul><blockquote><p>您必须实现类的函数，使每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p><p><strong>注意：</strong> 生成测试用例时，只有在 <code>RandomizedCollection</code> 中 <strong>至少有一项</strong> 时，才会调用 <code>getRandom</code> 。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;RandomizedCollection&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;getRandom&quot;</span>, <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;getRandom&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">2</span>], [], [<span class="number">1</span>], []]</span><br><span class="line">输出</span><br><span class="line">[<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="number">2</span>, <span class="keyword">true</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedCollection collection = <span class="keyword">new</span> RandomizedCollection();<span class="comment">// 初始化一个空的集合。</span></span><br><span class="line">collection.insert(<span class="number">1</span>);<span class="comment">// 向集合中插入 1 。返回 true 表示集合不包含 1 。</span></span><br><span class="line">collection.insert(<span class="number">1</span>);<span class="comment">// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span></span><br><span class="line">collection.insert(<span class="number">2</span>);<span class="comment">// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span></span><br><span class="line">collection.getRandom();<span class="comment">// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</span></span><br><span class="line">collection.remove(<span class="number">1</span>);<span class="comment">// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span></span><br><span class="line">collection.getRandom();<span class="comment">// getRandom 应有相同概率返回 1 和 2 。</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-19"><a href="#2、解题思路-19" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>为了使得在 O(1) 时间内随机获取一个元素，我们可以讲数放在一个列表中，这样获取随机元素时，就可以通过随机生成下标，从而随机得到一个元素</li><li>但列表的随机删除不是 O(1) 的，但元素在列表中的顺序是无关紧要的，所以在删除元素时，我们可以讲被删除的元素与列表中的最后一个元素交换位置，然后就可以在 O(1) 时间内，从列表中删除元素</li><li>所以我们需要维护数值在列表中的下标集合，对于数组 num 来说，它在 nums 中的下标集合为 Set（num）</li><li>在删除时，我们找出 num 出现的其中一个下标 i ，并将 <code>nums[i]</code> 与 <code>nums[nums.length - 1]</code> 交换位置，随后讲 i 从 Set（num） 中移除，并将原有的 nums[nums.length - 1] 替换为 i 。</li></ul><h3 id="3、解题代码-19"><a href="#3、解题代码-19" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放值与其在 nums 中的下标集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; ids;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放元素 num </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ids = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 讲元素加入到 nums 中</span></span><br><span class="line">        nums.add(val);</span><br><span class="line">        <span class="comment">// 添加该元素在nums中的下标</span></span><br><span class="line">        Set&lt;Integer&gt; indexSet = ids.getOrDefault(val, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        indexSet.add(nums.size() - <span class="number">1</span>);</span><br><span class="line">        ids.put(val, indexSet);</span><br><span class="line">        <span class="comment">// 第二次添加一样的数时返回 false</span></span><br><span class="line">        <span class="keyword">return</span> indexSet.size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 ids 中没有对应的 key ，那么证明没有该元素，直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (!ids.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 使用迭代器遍历 val 的所有下标</span></span><br><span class="line">        Set&lt;Integer&gt; indexSet = ids.get(val);</span><br><span class="line">        <span class="comment">// 获取 val 的第一个下标</span></span><br><span class="line">        <span class="keyword">int</span> firstIndex = indexSet.iterator().next();</span><br><span class="line">        <span class="comment">// 获取 nums 中的最后一个数</span></span><br><span class="line">        <span class="keyword">int</span> lastNum = nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 讲最后一个数放在 i 位置，实际上这样已经讲 val 移除</span></span><br><span class="line">        nums.set(firstIndex, lastNum);</span><br><span class="line">        <span class="comment">// 由于 firstIndex 位置不再是 val ，那么 val 下标应该讲 firstIndex 移除</span></span><br><span class="line">        Set&lt;Integer&gt; lastNumIndexSet = ids.get(lastNum);</span><br><span class="line">        indexSet.remove(firstIndex);</span><br><span class="line">        lastNumIndexSet.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果 firstIndex 不是最后一个位置，那么把它加入到集合中</span></span><br><span class="line">        <span class="keyword">if</span> (firstIndex &lt; nums.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            lastNumIndexSet.add(firstIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (indexSet.isEmpty()) &#123;</span><br><span class="line">            ids.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后移除最后一个元素</span></span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get((<span class="keyword">int</span>)(Math.random() * nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21、岛屿数量"><a href="#21、岛屿数量" class="headerlink" title="21、岛屿数量"></a>21、岛屿数量</h2><h3 id="1、题目描述-20"><a href="#1、题目描述-20" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-20"><a href="#2、解题思路-20" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>本题题解来自于 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">岛屿类问题的通用解法、DFS 遍历框架 - 岛屿数量 - 力扣（LeetCode） (leetcode-cn.com)</a></li><li>首先我们需要明确一下岛屿问题中的岛屿是怎么定义的</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215750.png" alt="image.png"></p><ul><li>二叉树的 DFS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问两个相邻结点：左子结点、右子结点</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，二叉树的 DFS 有两个要素，即<strong>访问子节点</strong>与<strong>判断终止条件</strong></p></blockquote><ol><li>访问子节点：二叉树本身就是一个递归定义的节奏，它的左右子树也是一颗二叉树</li><li>判断终止条件：当前节点为空时，递归结束</li></ol><ul><li>网格的 DFS</li></ul><blockquote><p>对于网格的 DFS ，我们可以对照着二叉树的 DFS 写出它的两个要素：</p></blockquote><ol><li>相邻节点：一个网格一般来说有上下左右四个相邻节点，即格子 <code>(r, c)</code> 拥有 <code>(r - 1, c)</code> 、 <code>(r + 1, c)</code> 、 <code>(r, c - 1)</code> 和 <code>(r, c + 1)</code></li></ol><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215753.png" alt="image.png"></p><ol start="2"><li>终止条件</li></ol><blockquote><p>当当前所处位置处于网格边界时，此时我们需要停止搜索，我们可以写出网格递归的框架代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, row, column)) &#123;</span><br><span class="line">        <span class="comment">// 到达终止条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前节点不是陆地节点，直接返回，证明岛屿已经遍历完毕</span></span><br><span class="line"> <span class="keyword">if</span> (grid[row][column] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在本层逻辑中加入避免重复遍历的判断语句，将当前格子设置为已遍历</span></span><br><span class="line">    grid[row][column] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 访问相邻节点</span></span><br><span class="line">    dfs(grid, row - <span class="number">1</span>, column);</span><br><span class="line">    dfs(grid, row + <span class="number">1</span>, column);</span><br><span class="line">    dfs(grid, row, column - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, row, column + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (row &gt; -<span class="number">1</span> &amp;&amp; row &lt; grid.length) &amp;&amp; </span><br><span class="line">           (column &gt; -<span class="number">1</span> &amp;&amp; column &lt; grid[<span class="number">0</span>].length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如何避免重复遍历？</li></ul><blockquote><p>在这道题中，我们需要在所有值为 1 的陆地格子上进行遍历，当我们遍历到陆地格子时，将对应的值改为 2 ，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：</p></blockquote><ol><li>0 —— 海洋格子</li><li>1 —— 陆地格子（未遍历过）</li><li>2 —— 陆地格子（已遍历过）</li></ol><blockquote><p>在代码中，我们在当前层处理逻辑中加入避免重复判断的语句：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, row, column)) &#123;</span><br><span class="line">        <span class="comment">// 到达终止条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前节点不是陆地节点，直接返回，证明岛屿已经遍历完毕</span></span><br><span class="line"> <span class="keyword">if</span> (grid[row][column] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在本层逻辑中加入避免重复遍历的判断语句，将当前格子设置为已遍历</span></span><br><span class="line">    grid[row][column] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 访问相邻节点</span></span><br><span class="line">    dfs(grid, row - <span class="number">1</span>, column);</span><br><span class="line">    dfs(grid, row + <span class="number">1</span>, column);</span><br><span class="line">    dfs(grid, row, column - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, row, column + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于这道题，我们循环遍历 grid 数组，当我们发现有一个格子的值为 <code>1</code> 时，我们就让岛屿数量 +1，因为每一次 dfs 都会将同一个岛屿的所有陆地都值为 2 ，所以每遍历到一个 1 ，就证明找到了一个新岛屿</li></ul><h3 id="3、解题代码-20"><a href="#3、解题代码-20" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; grid.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当遍历到一个值为 1 的格子时，直接让岛屿数目 ++ ，因为 dfs 算法会将该岛屿的全部 1 均遍历过一次且变为 2 </span></span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!inArea(grid, row, column)) &#123;</span><br><span class="line">            <span class="comment">// 到达终止条件</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点不是陆地节点，直接返回，证明岛屿已经遍历完毕</span></span><br><span class="line">	    <span class="keyword">if</span> (grid[row][column] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在本层逻辑中加入避免重复遍历的判断语句，将当前格子设置为已遍历</span></span><br><span class="line">        grid[row][column] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 访问相邻节点</span></span><br><span class="line">        dfs(grid, row - <span class="number">1</span>, column);</span><br><span class="line">        dfs(grid, row + <span class="number">1</span>, column);</span><br><span class="line">        dfs(grid, row, column - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, row, column + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (row &gt; -<span class="number">1</span> &amp;&amp; row &lt; grid.length) &amp;&amp; </span><br><span class="line">               (column &gt; -<span class="number">1</span> &amp;&amp; column &lt; grid[<span class="number">0</span>].length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22、缺失的第一个正数"><a href="#22、缺失的第一个正数" class="headerlink" title="22、缺失的第一个正数"></a>22、缺失的第一个正数</h2><h3 id="1、题目描述-21"><a href="#1、题目描述-21" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>示例三</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-21"><a href="#2、解题思路-21" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><h3 id="3、解题代码-21"><a href="#3、解题代码-21" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="23、全排列"><a href="#23、全排列" class="headerlink" title="23、全排列"></a>23、全排列</h2><h3 id="1、题目描述-22"><a href="#1、题目描述-22" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: [ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-22"><a href="#2、解题思路-22" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用回溯算法解决这道题，我们使用一个 <code>used</code> 数组来标志 <code>nums</code> 中的某个元素已经被用过</li><li>在我们遍历到某个元素时，如果 <code>used[i]</code> 为 true ，那么直接跳过本次循环，在回溯时需要将 <code>used[i]</code> 置为 false</li></ul><h3 id="3、解题代码-22"><a href="#3、解题代码-22" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtracking(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 base case ，创建递归推出条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == path.size()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2 遍历 nums 中的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素已经用过，那么跳过本次循环</span></span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前元素加入到结果中</span></span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            <span class="comment">// 将当前元素置为已使用过</span></span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 继续进行递归</span></span><br><span class="line">            backtracking(nums);</span><br><span class="line">            <span class="comment">// 撤销</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24、组合总和"><a href="#24、组合总和" class="headerlink" title="24、组合总和"></a>24、组合总和</h2><h3 id="1、题目描述-23"><a href="#1、题目描述-23" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span></span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">7</span>]]</span><br><span class="line">解释：</span><br><span class="line"><span class="number">2</span> 和 <span class="number">3</span> 可以形成一组候选，<span class="number">2</span> + <span class="number">2</span> + <span class="number">3</span> = <span class="number">7</span> 。注意 <span class="number">2</span> 可以使用多次。</span><br><span class="line"><span class="number">7</span> 也是一个候选， <span class="number">7</span> = <span class="number">7</span> 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-23"><a href="#2、解题思路-23" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用回溯算法</li></ul><ol><li>确定递归结束条件：当 <code>path</code> 中的和为 target 时，我们将当前结果 <code>path</code> 放入到最终结果中</li><li>每遍历到一个数组中的元素，我们都将其放入到 path 中，案后让 sum += nums[i] ，然后继续往下一层进行递归，然后我们需要撤销，让 <code>sum -= nums[i]</code> ，同时将 <code>nums[i]</code> 从 path 中移除。</li></ol><h3 id="3、解题代码-23"><a href="#3、解题代码-23" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 需要对数组进行排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="comment">// 进行递归</span></span><br><span class="line">        backtracking(candidates, <span class="number">0</span>, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> target, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="comment">// 如果 sum 等于 target ，那么证明我们就找到了一个答案</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历数组，进行递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex;i &lt; candidates.length;i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 选择第 i 个元素加入到 path 中</span></span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            <span class="comment">// 进行递归，这里从 i 开始，表示当前选中的元素在下一次遍历中依然可以被使用</span></span><br><span class="line">            backtracking(candidates, i, target, sum);</span><br><span class="line">            <span class="comment">// 撤销</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25、判断一棵二叉树是否为搜索二叉树和完全二叉树"><a href="#25、判断一棵二叉树是否为搜索二叉树和完全二叉树" class="headerlink" title="25、判断一棵二叉树是否为搜索二叉树和完全二叉树"></a>25、判断一棵二叉树是否为搜索二叉树和完全二叉树</h2><h3 id="1、题目描述-24"><a href="#1、题目描述-24" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一棵二叉树，已知其中的节点没有重复值，请判断该二叉树是否为<strong>搜索二叉树</strong>和<strong>完全二叉树</strong>。</p></blockquote><h3 id="2、解题思路-24"><a href="#2、解题思路-24" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>判断二叉树是否为搜索二叉树，可以使用递归或者判断中序遍历序列来判断</li><li>判断一棵树是否为完全二叉树，可以使用层序遍历的方式来解答，在层序遍历中保存一个 <code>pre</code> 指针指向当前遍历节点 <code>cur</code> 的前一个节点，如果 <code>pre</code> 为空且当前遍历节点 <code>cur</code> 不为空，那么直接返回 false</li><li>我们不需要判断当前节点的左右节点是否存在，因为我们需要将二叉树中的 <code>null</code> 节点保存</li></ul><h3 id="3、解题代码-24"><a href="#3、解题代码-24" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span>[] judgeIt (TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[] &#123;<span class="keyword">true</span>, <span class="keyword">true</span>&#125;;</span><br><span class="line">    <span class="keyword">boolean</span>[] result = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">0</span>] = isBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    result[<span class="number">1</span>] = isComplete(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(TreeNode root, Integer min, Integer max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果最小值大于等于当前根节点的值，那么直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; min &gt;= root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; max &lt;= root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 分别向左向右进行递归，将 root 的值作为 左子树递归的最大值传递进去，同时将 root 的值作为右子树递归的最大值传入</span></span><br><span class="line">    <span class="keyword">return</span> isBST(root.left, min, root.val) &amp;&amp; isBST(root.right, root.val, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否为完全二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isComplete</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pre = root;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="comment">// 如果 pre 为空且 cur 不为空</span></span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span> &amp;&amp; cur != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果 cur 不为空，那么将 cur 的左右子树加入到队列中</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 让 pre 移动到下一个位置</span></span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26、二叉树的直径"><a href="#26、二叉树的直径" class="headerlink" title="26、二叉树的直径"></a>26、二叉树的直径</h2><h3 id="1、题目描述-25"><a href="#1、题目描述-25" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树：</span><br><span class="line">          <span class="number">1</span></span><br><span class="line">         / \</span><br><span class="line">        <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">       / \   </span><br><span class="line">      <span class="number">4</span>   <span class="number">5</span> </span><br><span class="line">输出：返回 <span class="number">3</span>, 它的长度是路径 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 或者 [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-25"><a href="#2、解题思路-25" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>以某个点为中心的直径就是这个点左右子树的深度之和，使用一个 <code>result</code> 全局变量保存最大直径</li><li>创建一个方法，这个方法用于求解某棵树的深度，然后在方法中，我们要更新 <code>result</code> 的值</li></ul><h3 id="3、解题代码-25"><a href="#3、解题代码-25" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="comment">// 最后结果需要减去一</span></span><br><span class="line">        <span class="keyword">return</span> result - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="comment">// 在这里，更新 result 的最大值</span></span><br><span class="line">        result = Math.max(result, left + right + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27、最长公共前缀"><a href="#27、最长公共前缀" class="headerlink" title="27、最长公共前缀"></a>27、最长公共前缀</h2><h3 id="1、题目描述-26"><a href="#1、题目描述-26" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-26"><a href="#2、解题思路-26" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>我们以第一个字符串为基准，然后分别获取其他字符串与第一个字符串的公共前缀</li><li>然后使用一个变量来保存所有字符串的最长公共前缀长度，需要与 <code>strs[i]</code> 与 <code>strs[0]</code> 的最长公共前缀长度取最小值</li></ul><h3 id="3、解题代码-26"><a href="#3、解题代码-26" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">char</span>[] firstCharArray = strs[<span class="number">0</span>].toCharArray();</span><br><span class="line">    <span class="keyword">int</span> maxPrefixLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">char</span>[] tempCharArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; strs.length;i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化 index </span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        tempCharArray = strs[i].toCharArray();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; tempCharArray.length &amp;&amp; index &lt; firstCharArray.length) &#123;</span><br><span class="line">            <span class="comment">// 如果有字符不相等，那么直接退出</span></span><br><span class="line">            <span class="keyword">if</span> (firstCharArray[index] != tempCharArray[index]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新当前最大的最长公共前缀，这里需要取最小值</span></span><br><span class="line">        maxPrefixLen = Math.min(maxPrefixLen, index);</span><br><span class="line">        <span class="comment">// 如果 maxPrefixLen 为 0 ，那么证明此时数组内的最长公共前缀为 &quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (maxPrefixLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则返回最长公共前缀</span></span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, maxPrefixLen);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28、-逆序打印不可变链表"><a href="#28、-逆序打印不可变链表" class="headerlink" title="28、 逆序打印不可变链表"></a>28、 逆序打印不可变链表</h2><h3 id="1、题目描述-27"><a href="#1、题目描述-27" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给您一个不可变的链表，使用下列接口逆序打印每个节点的值：</p><p><strong>ImmutableListNode</strong> : 描述不可变链表的接口，链表的头节点已给出。<br>您需要使用以下函数来访问此链表（ <strong>您 不能 直接访问 ImmutableListNode</strong> ）：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImmutableListNode.printValue()：打印当前节点的值。</span><br><span class="line">ImmutableListNode.getNext()：返回下一个节点。</span><br></pre></td></tr></table></figure><blockquote><p>输入只用来内部初始化链表。您不可以通过修改链表解决问题。也就是说，您只能通过上述 API 来操作链表。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-27"><a href="#2、解题思路-27" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用递归来解决这道题</li></ul><ol><li>当当前结点存在 next 结点时，直接进行递归，将当前结点的 next 传入</li><li>当当前结点不存在 next 结点时，直接打印当前结点即可</li></ol><ul><li>不可变的 Node 结点定义如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the ImmutableListNode&#x27;s API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation.</span></span><br><span class="line"><span class="comment"> * interface ImmutableListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public void printValue(); // print the value of this node.</span></span><br><span class="line"><span class="comment"> *     public ImmutableListNode getNext(); // return the next node.</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="3、解题代码-27"><a href="#3、解题代码-27" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLinkedListInReverse</span><span class="params">(ImmutableListNode head)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 当 head 存在下一个结点时，标识当前 head 不是最后一个结点，此时进行递归</span></span><br><span class="line">        <span class="keyword">if</span>(head.getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printLinkedListInReverse(head.getNext());</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// 如果是最后一个结点，那么会直接输出</span></span><br><span class="line">	<span class="comment">// 其他结点在跳出递归后，会执行这里的输出语句</span></span><br><span class="line">        head.printValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the ImmutableListNode&#x27;s API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation.</span></span><br><span class="line"><span class="comment"> * interface ImmutableListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public void printValue(); // print the value of this node.</span></span><br><span class="line"><span class="comment"> *     public ImmutableListNode getNext(); // return the next node.</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="29、最接近-target-的值"><a href="#29、最接近-target-的值" class="headerlink" title="29、最接近 target 的值"></a>29、最接近 <code>target</code> 的值</h2><h3 id="1、题目描述-28"><a href="#1、题目描述-28" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给出一个数组，在数组中找到两个数，使得它们的和最接近目标值但不超过目标值，返回它们的和</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: target = <span class="number">15</span> 和 array = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">14</span></span><br><span class="line">解释: <span class="number">11</span>+<span class="number">3</span>=<span class="number">14</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: target = <span class="number">16</span> 和 array = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">16</span></span><br><span class="line">解释: <span class="number">11</span>+<span class="number">5</span>=<span class="number">16</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-28"><a href="#2、解题思路-28" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用双指针解决这道题，我们先将数组进行排序，然后右指针指向数组的最后一个元素，左指针指向第一个元素</li><li>我们使用一个变量 <code>diff</code> 来表示当前指针指向元素之和与 target 的差值，当 <code>nums[left] + nums[right] &lt;= target</code> 时，我们更新 diff 的值，然后让 left++ 。</li><li>当 <code>nums[right] &gt; target</code> 时，让 right– ，此时我们不更新 diff 的值</li><li>最后返回 <code>target - diff</code> 即可。</li></ul><h3 id="3、解题代码-28"><a href="#3、解题代码-28" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestTargetValue</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    Arrays.sort(array);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = array.length - <span class="number">1</span>, diff = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[left] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[left] + array[right] &lt;= target) &#123;</span><br><span class="line">            diff = Math.min(diff, target - (array[left] + array[right]));</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] + array[right] &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (diff == Integer.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target - diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30、小于-n-的最大数"><a href="#30、小于-n-的最大数" class="headerlink" title="30、小于 n 的最大数"></a>30、小于 n 的最大数</h2><h3 id="1、题目描述-29"><a href="#1、题目描述-29" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个数 n，如 23121，给定一组数 A，{2, 4, 9}，返回用 A 可以组成的小于 n 的最大数，A 不为空，答案 22999，</p></blockquote><h3 id="2、解题思路-29"><a href="#2、解题思路-29" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用贪心完成这道题，我们创建一个 <code>flag</code> 标识用于标识当前结果的前 n 位是否小于所给值得前 n 位，从最高位开始计算，<code>flag</code> 初始化为 false</li><li>我们使用两层循环来解决这个问题，如果此时 <code>flag</code> 为 true ，那么证明当前结果已经小于所给值，此时我们只需要当前结果剩下的位数中全部拼接上数组中的最大值即可。</li></ul><blockquote><p>比如说所给数为 100 ，数组为 {2,4,9} ，当 flag 为 true 时，我们直接组装两次 9 ，即返回 99</p></blockquote><ul><li>当所给值的某一位在数组中出现时，那么直接用数组中的那一个数</li></ul><blockquote><p>当所给书为 23121 ，所给数组为 {2,4,9} 时，由于所给的第一位在数组中有出现，所以直接用数组中的数</p></blockquote><h3 id="3、解题代码-29"><a href="#3、解题代码-29" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minValue</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    String valueStr = String.valueOf(value);</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; valueStr.length();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = valueStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// 如果已经确定当前结果小于 value ，那么剩下的几位全部使用最大值</span></span><br><span class="line">                result.append(nums[nums.length - <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 直接退出，因为不用与数组其他的元素进行对比了，可以比较下一位了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == nums[j]) &#123;</span><br><span class="line">                <span class="comment">// 如果发现当前结果的第 i 位刚好等于 nums[j] ，那么直接将 nums[j] 拼接到结果中</span></span><br><span class="line">                result.append(nums[j]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current &lt; nums[j]) &#123;</span><br><span class="line">                <span class="comment">// 如果发现当前位小于 nums[j] ，那么尝试拼接前一位，并将 flag 置为 true</span></span><br><span class="line">                <span class="comment">// 这里的 nums[j - 1] 一定小于 current </span></span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    result.append(nums[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31、盛最多水的容器"><a href="#31、盛最多水的容器" class="headerlink" title="31、盛最多水的容器"></a>31、盛最多水的容器</h2><h3 id="1、题目描述-30"><a href="#1、题目描述-30" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p></blockquote><ul><li>示例</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215809.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span> </span><br><span class="line">解释：图中垂直线代表输入数组 [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="number">49</span>。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-30"><a href="#2、解题思路-30" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用双指针来解决这道题</li><li>我们初始化左指针和右指针，其中左指针初始化为 0 ，右指针指向数组最后一个元素，使用一个变量用于存储最大水量</li><li>计算当前能存储的水量，计算公式为 <code>water = Math.min(nums[left], nums[right]) * (right - left)</code>，然后判断当前水量是否大于最大水量，如果是，那么更新</li><li>判断 <code>nums[left]</code> 和 <code>nums[right]</code> 的关系，如果 <code>nums[left] &gt; nums[right]</code> ，那么让 right 左移，以期找到一个更大的 right ，反之亦然</li></ul><h3 id="3、解题代码-30"><a href="#3、解题代码-30" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>, maxWater = Integer.MIN_VALUE, curWater = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        curWater = Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">        maxWater = Math.max(curWater, maxWater);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWater == Integer.MIN_VALUE ? <span class="number">0</span> : maxWater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32、删除排序链表中的重复元素-II"><a href="#32、删除排序链表中的重复元素-II" class="headerlink" title="32、删除排序链表中的重复元素 II"></a>32、删除排序链表中的重复元素 II</h2><h3 id="1、题目描述-31"><a href="#1、题目描述-31" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p></blockquote><ul><li>示例</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215813.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-31"><a href="#2、解题思路-31" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>由于链表是有序的，那么我们其实只需要用一次遍历即可解决这个问题</li><li>由于链表的头节点也可能是待删除元素，所以我们可以创建一个虚拟头节点</li><li>使用一个 <code>cur</code> 结点遍历链表，当发现 <code>cur.next.val == cur.next.next.val</code> 时，这个时候我们需要删除，此时证明 cur.next 和 cur.next.next 都是需要删除的结点，此时我们记录 cur.next.val 的值为 <code>nextVal</code> ，然后循环遍历，删除所有值为 nextVal 的结点</li><li>如果 <code>cur.next.val != cur.next.next.val</code> 时，直接让 cur 后移即可。</li></ul><h3 id="3、解题代码-31"><a href="#3、解题代码-31" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 创建一个虚拟头节点指向 head </span></span><br><span class="line">    ListNode virtualHead = <span class="keyword">new</span> ListNode(Integer.MIN_VALUE, head);</span><br><span class="line">    <span class="comment">// 创建一个结点用于遍历链表</span></span><br><span class="line">    ListNode cur = virtualHead;</span><br><span class="line">    <span class="comment">// 当 cur 的下一个结点与下下个结点存在时进行循环</span></span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">            <span class="comment">// 如果下一个结点的 val 与下下个结点的 val 相等，表示此时我们需要进行删除</span></span><br><span class="line">            <span class="comment">// 获取下一个结点的值</span></span><br><span class="line">            <span class="keyword">int</span> nextVal = cur.next.val;</span><br><span class="line">            <span class="comment">// 当 cur.next 不为空且 cur.next 的值为 nextVal 时，那么代表这个 cur.next 是要删除的结点</span></span><br><span class="line">            <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == nextVal) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则我们直接让 cur 右移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后返回虚拟节点的下一个结点即可</span></span><br><span class="line">    <span class="keyword">return</span> virtualHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33、长度最小的子数组"><a href="#33、长度最小的子数组" class="headerlink" title="33、长度最小的子数组"></a>33、长度最小的子数组</h2><h3 id="1、题目描述-32"><a href="#1、题目描述-32" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 连续子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-32"><a href="#2、解题思路-32" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用滑动窗口解决这个问题，我们使用一个 for 循环遍历数组，将 for 循环中的循环变量称为右边界 right，同时我们在数组最左边划定一个左边界 left ，称 [left, right] 为滑动窗口，而 [left, right] 中的和记为 sum</li><li>当 sum 小于 target 时，此时我们需要让 right 右移，扩充窗口的大小，从而让数组中的元素和符合题意</li><li>当 sum 大于等于 target 时，此时我们就找到了一个解，这个解实际上就是滑动窗口的大小 <code>right - left + 1</code> ，我们将这个值与全局最优解作比较，选一个小的，然后我们需要保持右边界不动，并尝试缩小 left ，以此达到缩小窗口的目的，可以想一下，比如说当前窗口的元素为 [1, 2, 3] ，而 target 为 5 ，那么如果我们缩小窗口，那么 [2,3] 也是一个答案，且这个答案要比窗口缩小前来得好，所以这一步是一个筛选最优解的过程</li></ul><h3 id="3、解题代码-32"><a href="#3、解题代码-32" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个 left 变量用于划定滑动窗口的左边界</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个变量用于存储最优解</span></span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// sum 用于表示滑动窗口中元素和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用一个 for 循环，这个循环中的循环变量是窗口的右边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>;right &lt; nums.length;right++) &#123;</span><br><span class="line">        <span class="comment">// 当 sum 小于 target 时，此时我们要扩充滑动窗口</span></span><br><span class="line">        <span class="comment">// 当右边界向右扩充时，此时我们要将 right 指向的元素加入到 sum 中，sum 表示当前滑动窗口中的元素和</span></span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            <span class="comment">// 当 sum 大于等于 target 时，此时我们要收集答案</span></span><br><span class="line">            result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 此时我们尝试缩小窗口大小</span></span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="34、二叉树的右视图"><a href="#34、二叉树的右视图" class="headerlink" title="34、二叉树的右视图"></a>34、二叉树的右视图</h2><h3 id="1、题目描述-33"><a href="#1、题目描述-33" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p></blockquote><ul><li>示例</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215818.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="keyword">null</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-33"><a href="#2、解题思路-33" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>除了使用 BFS 之外，还使用 DFS 解决这道题</li><li>我们按照 <strong>根节点</strong> -&gt; <strong>右子树</strong> -&gt; <strong>左子树</strong> 的顺序访问，可以保证每层都是最先访问最右边的结点，那么我们只需要在进入到树的新一层的时候，收集该层我们遍历到的第一个结点即可。</li><li>我们使用一个 depth 全局变量来表示我们当前遍历的深度，当 <code>depth == result.size()</code> 时，我们就可以进行收集。</li></ul><h3 id="3、解题代码-33"><a href="#3、解题代码-33" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; result;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dfs(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行 dfs 的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 遍历的顺序是：根右左，如果满足这个条件，那么证明我们此时正在访问本层的第一个结点</span></span><br><span class="line">    <span class="comment">// 比如说 depth 为 1 ，此时 result 集合的长度也为 1 ，当我们加入第二层的第一个结点后，集合长度就变为 2 ，此时 depth 和 result 长度就不等了。</span></span><br><span class="line">    <span class="keyword">if</span> (depth == result.size()) &#123;</span><br><span class="line">        <span class="comment">// 将当前 root 的值加入</span></span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要将 depth 的值 + 1，表示我们进到下一层</span></span><br><span class="line">    depth++;</span><br><span class="line">    <span class="comment">// 按照右左的顺序进行 dfs</span></span><br><span class="line">    dfs(root.right, depth);</span><br><span class="line">    dfs(root.left, depth);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35、简化路径"><a href="#35、简化路径" class="headerlink" title="35、简化路径"></a>35、简化路径</h2><h3 id="1、题目描述-34"><a href="#1、题目描述-34" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 **绝对路径 ** （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’//‘）都被视为单个斜杠 ‘/‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件/目录名称</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p></blockquote><ul><li>始终以斜杠 <code>&#39;/&#39;</code> 开头。</li><li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。</li><li>最后一个目录名（如果存在）**不能 **以 <code>&#39;/&#39;</code> 结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）。</li></ul><blockquote><p>返回简化后得到的 <strong>规范路径</strong> 。</p></blockquote><ol><li>示例一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = <span class="string">&quot;/home/&quot;</span></span><br><span class="line">输出：<span class="string">&quot;/home&quot;</span></span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。 </span><br></pre></td></tr></table></figure><ol start="2"><li>示例二</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = <span class="string">&quot;/../&quot;</span></span><br><span class="line">输出：<span class="string">&quot;/&quot;</span></span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-34"><a href="#2、解题思路-34" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>将所给的字符串通过 <code>split</code> 函数进行分割，这里以 <code>/</code> 作为分割符，当我们进行分割后，我们会得到一个字符串列表，这个字符串列表中只存在以下几种元素</li></ul><ol><li>空字符串，当出现多个连续的 <code>/</code> 时，就会分割出空字符串</li><li>一个点 <code>.</code>：表示当前路径</li></ol><blockquote><p>对于空字符串和一个点的情况，我们实际上可以直接跳过，因为空字符串没有意义，而 <code>.</code> 代表当前目录</p></blockquote><ol start="3"><li>两个点 <code>..</code>：表示上一个路径</li><li>只包含英文字母、数字或 <code>_</code> 的目录名</li></ol><blockquote><p>对于两个点及目录名的情况，我们需要使用一个栈来维护路径中的每一个目录名。</p><p>当我们遇到 <code>..</code> 时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录。当我们遇到目录名时，就直接将其压入栈中。</p><p>这样一来，我们只需要遍历字符串列表并进行上述操作即可，在所有操作完成后，我们将从栈底到栈顶的字符串用 <code>/</code> 链接，再加上最前面的 <code>/</code> 表示根目录，就可以得到简化后的路径。</p></blockquote><h3 id="3、解题代码-34"><a href="#3、解题代码-34" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//1 将字符串通过 / 分割符进行分割，得到一个 String 数组</span></span><br><span class="line">    String[] array = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="comment">//2 创建一个栈，这里使用双端队列来模拟栈</span></span><br><span class="line">    Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">//3 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (String item : array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.equals(item)) &#123;</span><br><span class="line">            <span class="comment">//4 如果遇到 &quot;..&quot; ，那么如果此时栈不为空，就将栈顶元素弹出，表示回退到上一级</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                stack.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.length() &gt; <span class="number">0</span> &amp;&amp; !(<span class="string">&quot;.&quot;</span>.equals(item))) &#123;</span><br><span class="line">            stack.offerLast(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6 使用一个 StringBuilder 用于返回最后结果</span></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//7 如果栈为空，那么直接返回 &quot;/&quot; 即可</span></span><br><span class="line">        result.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//8 如果栈不为空，那么我们需要将栈中元素从栈底依次拼接起来，每个元素之间使用 / 分割，这里可以让元素从双端队列头部弹出</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            result.append(<span class="string">&quot;/&quot;</span>).append(stack.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36、全排列-II"><a href="#36、全排列-II" class="headerlink" title="36、全排列 II"></a>36、全排列 II</h2><h3 id="1、题目描述-35"><a href="#1、题目描述-35" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个可包含重复数字的序列 <code>nums</code> ，**<em>按任意顺序**</em> 返回所有不重复的全排列。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-35"><a href="#2、解题思路-35" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>与全排列的思路差不多，但我们要在进行递归时判断，当前 <code>nums[i]</code> 是否与 <code>nums[i - 1]</code> 相等，如果满足 <code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1]</code> ，那么直接跳过，因为这个数字在前面已经使用过</li><li>在进行全排列之前需要对数组进行排序。</li></ul><h3 id="3、解题代码-35"><a href="#3、解题代码-35" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == path.size()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 当 used[i] 为 false 时进行回溯</span></span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                path.addLast(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(nums);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37、-36-进制加法"><a href="#37、-36-进制加法" class="headerlink" title="37、 36 进制加法"></a>37、 36 进制加法</h2><h3 id="1、题目描述-36"><a href="#1、题目描述-36" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>36 进制由 0-9，a-z，共 36 个字符表示。</p><p>要求按照加法规则计算出任意两个 36 进制正整数的和，如 1b + 2x = 48 （解释：47+105=152）</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1b + 2x</span><br><span class="line">输出: <span class="number">48</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-36"><a href="#2、解题思路-36" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>这道题类似于大数相加，本质上就是 36 进制的大数相加。</li><li>我们从后往前遍历两个字符串，然后进行相加，最后将数组翻转即可</li></ul><h3 id="3、解题代码-36"><a href="#3、解题代码-36" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ch - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>) (n + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>) (n - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">add36String</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 进位数</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftPoint = num1.length() - <span class="number">1</span>, rightPoint = num2.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (leftPoint &gt;= <span class="number">0</span> || rightPoint &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = (leftPoint &gt;= <span class="number">0</span>) ? getInt(num1.charAt(leftPoint)) : <span class="number">0</span>;</span><br><span class="line">        y = (rightPoint &gt;= <span class="number">0</span>) ? getInt(num2.charAt(rightPoint)) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x + y + carry;</span><br><span class="line">        result.append(getChar(temp % <span class="number">36</span>));</span><br><span class="line">        carry = temp / <span class="number">36</span>;</span><br><span class="line">        leftPoint--;</span><br><span class="line">        rightPoint--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="38、掷骰子的-N-种方法"><a href="#38、掷骰子的-N-种方法" class="headerlink" title="38、掷骰子的 N 种方法"></a>38、掷骰子的 N 种方法</h2><h3 id="1、题目描述-37"><a href="#1、题目描述-37" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>这里有 <code>n</code> 个一样的骰子，每个骰子上都有 <code>k</code> 个面，分别标号为 <code>1</code> 到 <code>k</code> 。</p><p>给定三个整数 <code>n</code> , <code>k</code> 和 <code>target</code> ，<strong>返回可能的方式(从总共 kn 种方式中)滚动骰子的数量，使正面朝上的数字之和等于 target 。</strong></p><p>答案可能很大，你需要对 <code>10^9 + 7</code> <strong>取模</strong> 。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">6</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你扔一个有<span class="number">6</span>张脸的骰子。</span><br><span class="line">得到<span class="number">3</span>的和只有一种方法。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">6</span>, target = <span class="number">7</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：你扔两个骰子，每个骰子有<span class="number">6</span>个面。</span><br><span class="line">得到<span class="number">7</span>的和有<span class="number">6</span>种方法<span class="number">1</span>+<span class="number">6</span> <span class="number">2</span>+<span class="number">5</span> <span class="number">3</span>+<span class="number">4</span> <span class="number">4</span>+<span class="number">3</span> <span class="number">5</span>+<span class="number">2</span> <span class="number">6</span>+<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-37"><a href="#2、解题思路-37" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用动态规划解决这个问题，这个问题是一个背包问题</li><li>创建一个二维的 <code>dp</code> 数组，我们设 <code>dp[i][j]</code> 表示，用 i 个骰子掷出总和为 j 的方案数</li><li>对于前 i 个骰子而言，可能决策的方案有：<ul><li>第 i 个骰子的结果为 1 ，那么此时有 <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>第 i 个骰子的结果为 2 ，那么此时有 <code>dp[i][j] = dp[i - 1][j - 2]</code></li><li>…</li><li>第 i 个骰子的结果为 m ，那么此时有 <code>dp[i][j] = dp[i - 1][j - m]</code></li></ul></li></ul><blockquote><p>而 <code>dp[i][j]</code> 为以上所有方案的总和</p></blockquote><ul><li>初始化 <code>dp[0][0] = 1</code></li></ul><h3 id="3、解题代码-37"><a href="#3、解题代码-37" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = (<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="comment">// 创建一个二维的 dp 数组，其中 dp[i][j] 表示对于前 i 个骰子，有 dp[i][j] 种掷出和为 j 的方案</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= target;j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= k;x++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= x) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - x];</span><br><span class="line">                    dp[i][j] %= mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39、二叉树中的最大路径和"><a href="#39、二叉树中的最大路径和" class="headerlink" title="39、二叉树中的最大路径和"></a>39、二叉树中的最大路径和</h2><h3 id="1、题目描述-38"><a href="#1、题目描述-38" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 至少包含一个 节点，且不一定经过根节点</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p></blockquote><ul><li>示例一</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215828.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最优路径是 <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> ，路径和为 <span class="number">2</span> + <span class="number">1</span> + <span class="number">3</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215832.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [-<span class="number">10</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">42</span></span><br><span class="line">解释：最优路径是 <span class="number">15</span> -&gt; <span class="number">20</span> -&gt; <span class="number">7</span> ，路径和为 <span class="number">15</span> + <span class="number">20</span> + <span class="number">7</span> = <span class="number">42</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-38"><a href="#2、解题思路-38" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li><p>使用递归解决这道题，当传入的 root 为空时，直接返回 0</p></li><li><p>当我们处于 root 时，我们希望左子树告诉我们以左子节点开始的路径和最大值为多少，同样，我们希望右子树告诉我们以右子节点开始的路径和最大值为多少。</p></li><li><p>对于 root 来说，有 4 种可能得到最大值</p></li></ul><ol><li>我自己为一个路径</li><li>我只和左子树合并成为一条路径</li><li>我只和右子树合并成为一条路径</li><li>我同时链接左子树和右子树的路径</li></ol><h3 id="3、解题代码-38"><a href="#3、解题代码-38" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pathSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> pathSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">        <span class="comment">//四种选择</span></span><br><span class="line">        <span class="comment">//1 独立成线</span></span><br><span class="line">        <span class="comment">//2 和左子树成为一条路径、</span></span><br><span class="line">        <span class="comment">//3 和右子树称为一条路径</span></span><br><span class="line">        <span class="keyword">int</span> res = Math.max(root.val, root.val + Math.max(left, right));</span><br><span class="line">        <span class="comment">//4 以自己为桥梁，同时与左右子树合并</span></span><br><span class="line">        pathSum = Math.max(pathSum, Math.max(res, root.val + left + right));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40、单词拆分"><a href="#40、单词拆分" class="headerlink" title="40、单词拆分"></a>40、单词拆分</h2><h3 id="1、题目描述-39"><a href="#1、题目描述-39" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p><strong>注意：</strong> 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;leetcode&quot;</span>, wordDict = [<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 返回 <span class="keyword">true</span> 因为 <span class="string">&quot;leetcode&quot;</span> 可以由 <span class="string">&quot;leet&quot;</span> 和 <span class="string">&quot;code&quot;</span> 拼接成。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;applepenapple&quot;</span>, wordDict = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 返回 <span class="keyword">true</span> 因为 <span class="string">&quot;applepenapple&quot;</span> 可以由 <span class="string">&quot;apple&quot;</span> <span class="string">&quot;pen&quot;</span> <span class="string">&quot;apple&quot;</span> 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-39"><a href="#2、解题思路-39" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用动态规划解决这道题，我们令 <code>dp[i]</code> 表示 <code>s[0, i - 1]</code> 子串是否能被空格拆分为若干个字典中出现的单词。</li><li>状态转移方程：<code>dp[i] = dp[j] &amp;&amp; check(s[j, i - 1])</code> ，也就当 <code>dp[j] = true</code> 时，那我们只需要判断 <code>s[j, i - 1]</code> 是否也在 wordDict 中即可。</li><li>初始化 dp 数组，我们令 <code>dp[0] = true</code></li></ul><h3 id="3、解题代码-39"><a href="#3、解题代码-39" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，其中 dp[i] 表示 s[0, i - 1] 是否能被 wordDict 中的单词拼接出来</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="41、从根节点到叶节点的路径数字之和"><a href="#41、从根节点到叶节点的路径数字之和" class="headerlink" title="41、从根节点到叶节点的路径数字之和"></a>41、从根节点到叶节点的路径数字之和</h2><h3 id="1、题目描述-40"><a href="#1、题目描述-40" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</p><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> ，<strong>叶节点</strong> 是指没有子节点的节点。</p></blockquote><ul><li>示例一</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215837.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">2</span> 代表数字 <span class="number">12</span></span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">3</span> 代表数字 <span class="number">13</span></span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215841.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1026</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">5</span> 代表数字 <span class="number">495</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">1</span> 代表数字 <span class="number">491</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">0</span> 代表数字 <span class="number">40</span></span><br><span class="line">因此，数字总和 = <span class="number">495</span> + <span class="number">491</span> + <span class="number">40</span> = <span class="number">1026</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-40"><a href="#2、解题思路-40" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用深度优先算法解决这个问题，如果遇到一个叶子节点，那么将叶子节点对应的数加到数字之和中。</li><li>如果当前节点不是叶子节点，那么计算它子节点对应的数字，然后对子节点进行递归</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215844.png" alt="image.png"></p><h3 id="3、解题代码-40"><a href="#3、解题代码-40" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 DFS 进行搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经到了叶子节点，那么此时直接返回 0 </span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 否则我们要计算和，就是传入的 val * 10 然后再上根节点的值</span></span><br><span class="line">    <span class="keyword">int</span> sum = value * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="comment">// 如果该节点为叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 那么直接返回 sum 即可。</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(root.left, sum) + process(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="42、二叉树中和为某一值的路径"><a href="#42、二叉树中和为某一值的路径" class="headerlink" title="42、二叉树中和为某一值的路径"></a>42、二叉树中和为某一值的路径</h2><h3 id="1、题目描述-41"><a href="#1、题目描述-41" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p></blockquote><ul><li>示例一</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215847.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="keyword">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215854.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-41"><a href="#2、解题思路-41" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用回溯算法解决这道题，每当我们经过一个叶子节点，我们就让 target 的值减去对应 root 节点的值，这样当 root 为叶子节点且 target 的值为 0 时，此时就可以收集答案</li><li>配合前序遍历解决这道题</li></ul><h3 id="3、解题代码-41"><a href="#3、解题代码-41" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    process(root, target, result, path);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode root, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果此时遍历到的 root 为空，那么证明我们越过了叶子节点，此时直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让 target 减去 root 的值</span></span><br><span class="line">    target -= root.val;</span><br><span class="line">    <span class="comment">// 将 root 的值放入 path 中</span></span><br><span class="line">    path.addLast(root.val);</span><br><span class="line">    <span class="comment">// 当 target 等于 0 且 root 为叶子节点时，收集答案</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行前序遍历</span></span><br><span class="line">    process(root.left, target, result, path);</span><br><span class="line">    process(root.right, target, result, path);</span><br><span class="line">    <span class="comment">// 移除本层做的事，进行回溯</span></span><br><span class="line">    target += root.val;</span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43、最接近的三数之和"><a href="#43、最接近的三数之和" class="headerlink" title="43、最接近的三数之和"></a>43、最接近的三数之和</h2><h3 id="1、题目描述-42"><a href="#1、题目描述-42" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p><p>返回这三个数的和，假定每组输入只存在恰好一个解。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">4</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：与 target 最接近的和是 <span class="number">2</span> (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>) 。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-42"><a href="#2、解题思路-42" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>这道题与三数之和类似，我们将数组排序后，先确定一个数的值，然后再在 [i + 1, end] 中使用双指针选出两个数</li></ul><h3 id="3、解题代码-42"><a href="#3、解题代码-42" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> left = -<span class="number">1</span>, right = -<span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length - <span class="number">2</span>;i++) &#123;</span><br><span class="line">        left = i + <span class="number">1</span>;</span><br><span class="line">        right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(target - result) &gt; Math.abs(target - sum)) &#123;</span><br><span class="line">                result = sum;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="44、删除字符串中的所有相邻重复项"><a href="#44、删除字符串中的所有相邻重复项" class="headerlink" title="44、删除字符串中的所有相邻重复项"></a>44、删除字符串中的所有相邻重复项</h2><h3 id="1、题目描述-43"><a href="#1、题目描述-43" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">&quot;abbaca&quot;</span></span><br><span class="line">输出：<span class="string">&quot;ca&quot;</span></span><br><span class="line">解释：</span><br><span class="line">例如，在 <span class="string">&quot;abbaca&quot;</span> 中，我们可以删除 <span class="string">&quot;bb&quot;</span> 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 <span class="string">&quot;aaca&quot;</span>，其中又只有 <span class="string">&quot;aa&quot;</span> 可以执行重复项删除操作，所以最后的字符串为 <span class="string">&quot;ca&quot;</span>。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-43"><a href="#2、解题思路-43" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用一个栈来解决这个问题，当遍历到的字符与栈顶字符相同时，直接弹出栈顶字符，否则将该字符入栈</li><li>最后自底而上收集栈中元素</li></ul><h3 id="3、解题代码-43"><a href="#3、解题代码-43" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peekLast() == ch) &#123;</span><br><span class="line">            stack.pollLast();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.addLast(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        result.append(stack.pollFirst());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="45、柠檬水找零"><a href="#45、柠檬水找零" class="headerlink" title="45、柠檬水找零"></a>45、柠檬水找零</h2><h3 id="1、题目描述-44"><a href="#1、题目描述-44" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p></blockquote><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">3</span> 位顾客那里，我们按顺序收取 <span class="number">3</span> 张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">第 <span class="number">4</span> 位顾客那里，我们收取一张 <span class="number">10</span> 美元的钞票，并返还 <span class="number">5</span> 美元。</span><br><span class="line">第 <span class="number">5</span> 位顾客那里，我们找还一张 <span class="number">10</span> 美元的钞票和一张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 <span class="keyword">true</span>。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-44"><a href="#2、解题思路-44" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><blockquote><p>我们需要维护三种金额的数量，5， 10 和 20，有以下三种情况</p></blockquote><ul><li>情况一：账单是 5，直接收下。</li><li>情况二：账单是 10，消耗一个 5，增加一个 10</li><li>情况三：<strong>账单是 20，优先消耗一个 10 和一个 5，如果不够，再消耗三个 5</strong></li></ul><blockquote><p>由于 10 元只能给 20 找零，所以 5 元更通用。由于 20 元不可能花出去，所以我们只需要在代码中维护 5 元和 10 元的钱数即可，在一次找零后，如果发现 5 元和 10 元的钱数有一个小于 0 ，那么直接返回 false ，整个数组遍历完后，如果钱数均不小于 0 ，则返回 true</p></blockquote><h3 id="3、解题代码-44"><a href="#3、解题代码-44" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们维护 5 元和 10 元的数量即可</span></span><br><span class="line">    <span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> bill : bills) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bill == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果遇到 5 元，那么直接让 5 元钱数 ++</span></span><br><span class="line">            five++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果遇到 10 元，那么 10 元钱数 + 1，同时5元钱数 - 1</span></span><br><span class="line">            five--;</span><br><span class="line">            ten++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果遇到 20 元，那么优先消耗 10 + 5，如果 10 小于 0 ，那么消耗 3 * 5</span></span><br><span class="line">            <span class="keyword">if</span> (ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ten--;</span><br><span class="line">                five--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                five -= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在一次找零后看看有没有钱数小于 0 ，如果有，那么直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (ten &lt; <span class="number">0</span> || five &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46、最长有效括号"><a href="#46、最长有效括号" class="headerlink" title="46、最长有效括号"></a>46、最长有效括号</h2><h3 id="1、题目描述-45"><a href="#1、题目描述-45" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(()&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">&quot;()&quot;</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;)()())&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">&quot;()()&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-45"><a href="#2、解题思路-45" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用一个栈来解决这个问题</li></ul><ol><li>将 -1 入栈，用于处理边界条件</li><li>遍历字符串，如果遇到左括号时，就将左括号对应的索引值入栈</li><li>如果遇到右括号时，我们弹出栈顶元素表示匹配了当前右括号<ol><li>如果栈为空，那么说明当前的右括号为没有被匹配的右括号，我们将它的下标放入栈中来更新我们之前提到的<strong>最后一个没有被匹配的右括号的下标</strong></li><li>如果栈不为空，那么使用当前右括号的下标减去栈顶元素即为<strong>以该右括号为结尾的最长有效括号的长度</strong></li></ol></li></ol><blockquote><p>需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 −1 的元素。</p></blockquote><h3 id="3、解题代码-45"><a href="#3、解题代码-45" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    stack.addLast(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.removeLast();</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                stack.addLast(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxLength = Math.max(i - stack.peekLast(), maxLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="47、下一个更大元素-II"><a href="#47、下一个更大元素-II" class="headerlink" title="47、下一个更大元素 II"></a>47、下一个更大元素 II</h2><h3 id="1、题目描述-46"><a href="#1、题目描述-46" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 nums 中每个元素的 <strong>下一个更大元素</strong> 。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: [<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释: 第一个 <span class="number">1</span> 的下一个更大的数是 <span class="number">2</span>；</span><br><span class="line">数字 <span class="number">2</span> 找不到下一个更大的数； </span><br><span class="line">第二个 <span class="number">1</span> 的下一个最大的数需要循环搜索，结果也是 <span class="number">2</span>。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-46"><a href="#2、解题思路-46" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用单调栈和循环数组来解决这个问题，当栈为空或者栈顶元素下标对应的值小于当前遍历到的值时，直接将当前元素的下标入栈，否则循环弹出栈顶小于当前值的下标，计算该下标对应的值</li></ul><h3 id="3、解题代码-46"><a href="#3、解题代码-46" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span> * len - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peekLast()] &lt; nums[i % len]) &#123;</span><br><span class="line">            <span class="comment">// 此时可以结算 nums[stack.peek()] 的下一个最大元素</span></span><br><span class="line">            result[stack.pollLast()] = nums[i % len];</span><br><span class="line">        &#125;</span><br><span class="line">        stack.addLast(i % len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="48、二叉树最大宽度"><a href="#48、二叉树最大宽度" class="headerlink" title="48、二叉树最大宽度"></a>48、二叉树最大宽度</h2><h3 id="1、题目描述-47"><a href="#1、题目描述-47" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p><p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的 <code>null</code> 节点也计入长度）之间的长度。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">           <span class="number">1</span></span><br><span class="line">         /   \</span><br><span class="line">        <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">       / \     \  </span><br><span class="line">      <span class="number">5</span>   <span class="number">3</span>     <span class="number">9</span> </span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 最大值出现在树的第 <span class="number">3</span> 层，宽度为 <span class="number">4</span> (<span class="number">5</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">9</span>)。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">          <span class="number">1</span></span><br><span class="line">         /  </span><br><span class="line">        <span class="number">3</span>  </span><br><span class="line">       / \   </span><br><span class="line">      <span class="number">5</span>   <span class="number">3</span>   </span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 最大值出现在树的第 <span class="number">3</span> 层，宽度为 <span class="number">2</span> (<span class="number">5</span>,<span class="number">3</span>)。</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-47"><a href="#2、解题思路-47" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用层序遍历来解决这道题，我们使用一个双向队列来保存节点，同时以节点的值来记录节点在二叉树上的位置</li><li>那么每一层的宽度就可以这样计算，使用双端队列中最后一个元素的 val 减去第一个元素的 val ，得到的结果 + 1 就是本层的宽度。</li><li>如果 cur 的左子树不为空，那么将左子树的值置为 2 * cur.val + 1，然后加入到双端队列中</li><li>如果 cur 的右子树不为空，那么将右子树的值置为 2 * cur.val + 2，然后加入到队列中</li><li>我们也可以不改变节点 val 的值，可以通过自定义一个类来解决这个问题，然后使用 position 来保存位置即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTreeNode</span> </span>&#123;</span><br><span class="line">	TreeNode node;</span><br><span class="line">	<span class="keyword">int</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、解题代码-47"><a href="#3、解题代码-47" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用节点的 val 属性记录其在树中的位置</span></span><br><span class="line">    root.val = <span class="number">0</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">// 当前层的宽度的值为最后一个节点的值 - 第一个节点的值 + 1</span></span><br><span class="line">        current = queue.peekLast().val - queue.peekFirst().val + <span class="number">1</span>;</span><br><span class="line">        max = Math.max(current, max);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">            TreeNode cur = queue.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.left.val = <span class="number">2</span> * cur.val + <span class="number">1</span>;</span><br><span class="line">                queue.addLast(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.right.val = <span class="number">2</span> * cur.val + <span class="number">2</span>;</span><br><span class="line">                queue.addLast(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="49、螺旋矩阵"><a href="#49、螺旋矩阵" class="headerlink" title="49、螺旋矩阵"></a>49、螺旋矩阵</h2><h3 id="1、题目描述-48"><a href="#1、题目描述-48" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p></blockquote><ul><li>示例一</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215906.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319215911.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><h3 id="2、解题思路-48"><a href="#2、解题思路-48" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>我们可以将矩阵看为若干层，首先输出最外层的元素，然后输出次外层的元素，直到输出最内层的元素</li><li>对于每层，从左上方开始以顺时针遍历所有元素。假设当前层的左上角位于 （top, left），右下角位于（bottom，right），我们按照以下顺序遍历当前层元素</li></ul><ol><li>从左到右遍历元素，依次为（top，left）到（top，right）</li><li>从上到下遍历元素，依次为（top + 1，right）到（bottom，right）</li><li>如果此时 left &lt; right 且 top &lt; bottom ，则从右到左遍历下侧元素，依次为（bottom，right - 1）到（bottom，left - 1）以及从下到上遍历左侧元素，依次为（bottom，left）到（top + 1，left）</li></ol><ul><li>在遍历完一层元素后，收缩矩阵范围，令 left 与 top + 1，同时让 right 与 bottom - 1</li></ul><h3 id="3、解题代码-48"><a href="#3、解题代码-48" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// 确定左上角与右下角位置</span></span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, column = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>, bottom = row - <span class="number">1</span>, left = <span class="number">0</span>, right = column - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当 left 小于等于 right 且 top 小于等于 bottom 时继续循环</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="comment">//1 从左到右打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left;i &lt;= right;i++) &#123;</span><br><span class="line">            result.add(matrix[top][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2 从上到下打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>;i &lt;= bottom;i++) &#123;</span><br><span class="line">            result.add(matrix[i][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3 当 left &lt; right 且 top &lt; bottom 时，打印</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">            <span class="comment">//4 向右往左打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>;i &gt; left;i--) &#123;</span><br><span class="line">                result.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5 向下往上打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom;i &gt; top;i--) &#123;</span><br><span class="line">                result.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6 收缩矩阵</span></span><br><span class="line">        left++;</span><br><span class="line">        top++;</span><br><span class="line">        right--;</span><br><span class="line">        bottom--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="50、搜索旋转排序数组"><a href="#50、搜索旋转排序数组" class="headerlink" title="50、搜索旋转排序数组"></a>50、搜索旋转排序数组</h2><h3 id="1、题目描述-49"><a href="#1、题目描述-49" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-49"><a href="#2、解题思路-49" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用二分查找解决这个问题，在循环中，我们计算判断 <code>nums[mid]</code> 与 target 值的关系</li></ul><ol><li>如果 <code>nums[mid] == target</code> ，那么直接返回 mid</li><li>如果 <code>nums[0] &lt;= nums[mid]</code> ，此时代表 [0, mid] 不包含旋转，是一个完整的有序数组，当 <code>nums[0] &lt;= target &lt;= nums[mid]</code> 时，我们就可以让 right = mid - 1，否则我们需要在 [mid + 1, right] 中查找，也就是让 left = mid + 1</li><li>如果 <code>nums[mid] &lt;= nums[right]</code> ，那么说明 [mid, right] 是有序数组，当 <code>target</code> 的值满足 <code>nums[mid] &lt;= target &lt;= nums[right]</code> 时，则我们应该将搜索范围缩小至 <code>[mid + 1, right]</code>，否则在 <code>[left, mid - 1]</code> 中寻找。</li></ol><h3 id="3、解题代码-49"><a href="#3、解题代码-49" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51、鸡蛋掉落"><a href="#51、鸡蛋掉落" class="headerlink" title="51、鸡蛋掉落"></a>51、鸡蛋掉落</h2><h3 id="1、题目描述-50"><a href="#1、题目描述-50" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote><p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p><p>已知存在楼层 <code>f</code> ，满足 <code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。</p><p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p></blockquote><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 <span class="number">1</span> 楼掉落。如果它碎了，肯定能得出 f = <span class="number">0</span> 。 </span><br><span class="line">否则，鸡蛋从 <span class="number">2</span> 楼掉落。如果它碎了，肯定能得出 f = <span class="number">1</span> 。 </span><br><span class="line">如果它没碎，那么肯定能得出 f = <span class="number">2</span> 。 </span><br><span class="line">因此，在最坏的情况下我们需要移动 <span class="number">2</span> 次以确定 f 是多少。</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">2</span>, n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-50"><a href="#2、解题思路-50" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>当我们只有一个鸡蛋时，此时我们别无他法，只能一层楼一层楼测试，也就是对 [1, n] 进行线性扫描，所以结果为 n</li><li>当我们有无限个鸡蛋时，这个时候我们可以使用二分查找法来解决这个问题，每次都将扫描的范围减半，所以结果为 <code>log(n)</code></li><li>使用动态规划解决这个问题，假设有 k 个鸡蛋 n 层楼，我们创建一个二维的 dp 数组 <code>dp[n + 1][k + 1]</code></li><li>确定 dp 数组的含义，其中 <code>dp[i][j]</code> 表示有 i 层楼 k 个鸡蛋时，确定 f 所需要的最小操作数</li><li></li></ul><h3 id="3、解题代码-50"><a href="#3、解题代码-50" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 52、多数元素</span><br><span class="line"></span><br><span class="line">### 1、题目描述</span><br><span class="line"></span><br><span class="line">&gt; 给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/<span class="number">2</span> ⌋` 的元素。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">* 示例一</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">输入：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="2、解题思路-51"><a href="#2、解题思路-51" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><ul><li>使用摩尔投票法解决这道题</li></ul><ol><li>维护一个候选众数 target 和它出现的次数 count ，初始化时 target 为任意值，而 count 为 0</li><li>遍历数组中的所有元素，对于每个元素 num ，在判断 num 之前，如果 count 等于 0 ，那么将 target 的值赋为 num ，随后判断 num：<ol><li>如果 num 与 target 的值相等，那么 count ++</li><li>如果 num 与 target 的值不等，那么 count –</li></ol></li><li>遍历完 nums 后，target 即为整个数组中的众数。</li></ol><h3 id="3、解题代码-51"><a href="#3、解题代码-51" class="headerlink" title="3、解题代码"></a>3、解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> target = -<span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            target = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>数据结构与算法学习（二十一）-动态规划</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/2261888774.html">https://sutianxin.top/posts/2261888774.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2022-03-19</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2022-03-19</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%98%95Java/">☕Java</a><a class="post-meta__tags" href="/tags/%F0%9F%92%BB%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/">💻后端学习</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/blogImage/raw/master/img/20220319220441.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/405834138.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/img/20220318184629.jpg" onerror='onerror=null,src="https://gitee.com/sutianxin/blogImage/raw/master/20210430103138.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java面试总结（五）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1128227004.html" title="Java应用学习（七）-回顾Mybatis和Spring MVC"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210430102830.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">Java应用学习（七）-回顾Mybatis和Spring MVC</div></div></a></div><div><a href="/posts/2938255980.html" title="Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210208120213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-12</div><div class="title">Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用</div></div></a></div><div><a href="/posts/913123791.html" title="Spring Cloud学习（七）-Spring Cloud Config"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210516192228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="title">Spring Cloud学习（七）-Spring Cloud Config</div></div></a></div><div><a href="/posts/2863462089.html" title="Spring Cloud学习（二）-OpenFeign微服务调用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/blogImage/raw/master/20210504192527.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-11</div><div class="title">Spring Cloud学习（二）-OpenFeign微服务调用</div></div></a></div><div><a href="/posts/995752607.html" title="Spring Cloud学习（四）-Eureka服务注册中心"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210214225250.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-14</div><div class="title">Spring Cloud学习（四）-Eureka服务注册中心</div></div></a></div><div><a href="/posts/650479038.html" title="在线教育项目总结（二）-用户认证"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210205204706.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-05</div><div class="title">在线教育项目总结（二）-用户认证</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">1、反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81K-%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">2、K 个一组反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-1"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">3、两两交换链表中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-2"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">4、合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-3"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">5、最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-4"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-text">6、求最大公共前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-5"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">7、链表排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-6"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-II"><span class="toc-text">8、验证回文字符串 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-7"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">9、回文链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-8"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84"><span class="toc-text">10、有效的山脉数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-9"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89"><span class="toc-text">11、数组中的最长山脉</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-10"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III"><span class="toc-text">12、买卖股票的最佳时机 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-11"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-11"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV"><span class="toc-text">13、买卖股票的最佳时机 IV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-12"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-12"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-12"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">14、圆圈中最后剩下的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-13"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-13"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-13"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-text">15、使用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-14"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-14"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-14"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-text">16、最长无重复子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-15"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-15"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-15"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">17、对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-16"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-16"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-16"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">18、树的子结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-17"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-17"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-17"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">19、回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-18"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-18"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-18"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81O-1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D"><span class="toc-text">20、O(1) 时间插入、删除和获取随机元素 - 允许重复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-19"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-19"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-19"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">21、岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-20"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-20"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-20"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="toc-text">22、缺失的第一个正数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-21"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-21"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-21"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">23、全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-22"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-22"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-22"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">24、组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-23"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-23"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-23"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">25、判断一棵二叉树是否为搜索二叉树和完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-24"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-24"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-24"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-text">26、二叉树的直径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-25"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-25"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-25"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-text">27、最长公共前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-26"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-26"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-26"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81-%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%93%BE%E8%A1%A8"><span class="toc-text">28、 逆序打印不可变链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-27"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-27"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-27"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E6%9C%80%E6%8E%A5%E8%BF%91-target-%E7%9A%84%E5%80%BC"><span class="toc-text">29、最接近 target 的值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-28"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-28"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-28"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E5%B0%8F%E4%BA%8E-n-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-text">30、小于 n 的最大数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-29"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-29"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-29"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">31、盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-30"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-30"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-30"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="toc-text">32、删除排序链表中的重复元素 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-31"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-31"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-31"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">33、长度最小的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-32"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-32"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-32"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">34、二叉树的右视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-33"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-33"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-33"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84"><span class="toc-text">35、简化路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-34"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-34"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-34"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="toc-text">36、全排列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-35"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-35"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-35"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81-36-%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95"><span class="toc-text">37、 36 进制加法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-36"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-36"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-36"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81%E6%8E%B7%E9%AA%B0%E5%AD%90%E7%9A%84-N-%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">38、掷骰子的 N 种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-37"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-37"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-37"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">39、二叉树中的最大路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-38"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-38"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-38"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-text">40、单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-39"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-39"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-39"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-text">41、从根节点到叶节点的路径数字之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-40"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-40"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-40"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">42、二叉树中和为某一值的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-41"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-41"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-41"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">43、最接近的三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-42"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-42"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-42"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">44、删除字符串中的所有相邻重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-43"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-43"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-43"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-text">45、柠檬水找零</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-44"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-44"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-44"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-text">46、最长有效括号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-45"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-45"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-45"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-II"><span class="toc-text">47、下一个更大元素 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-46"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-46"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-46"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-text">48、二叉树最大宽度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-47"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-47"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-47"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-text">49、螺旋矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-48"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-48"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-48"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">50、搜索旋转排序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-49"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-49"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-49"><span class="toc-text">3、解题代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E3%80%81%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD"><span class="toc-text">51、鸡蛋掉落</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-50"><span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-50"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-50"><span class="toc-text">3、解题代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-51"><span class="toc-text">2、解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-51"><span class="toc-text">3、解题代码</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init({el:"#twikoo-wrap",envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai"})},e=()=>{twikoo.getCommentsCount({envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then(function(o){t.innerText=o[0].count}).catch(function(o){console.error(o)})};var n;n=!0,"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" data-lrctype="0" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_yegv7kt2bj.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.js"></script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><script src="https://www.luckyclover.top/rain.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"]):not([href="/contact/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>