<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL高级学习（二）-MySQL体系结构、SQL优化、索引使用 | Arno</title><meta name="keywords" content="☕Java"><meta name="author" content="天昕"><meta name="copyright" content="天昕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL高级学习笔记二"><meta property="og:type" content="article"><meta property="og:title" content="MySQL高级学习（二）-MySQL体系结构、SQL优化、索引使用"><meta property="og:url" content="https://sutianxin.top/posts/996934066.html"><meta property="og:site_name" content="Arno"><meta property="og:description" content="MySQL高级学习笔记二"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sutianxin/photo/raw/master/20210309230829.jpg"><meta property="article:published_time" content="2021-03-09T15:07:11.000Z"><meta property="article:modified_time" content="2021-03-29T14:01:10.566Z"><meta property="article:author" content="天昕"><meta property="article:tag" content="☕Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sutianxin/photo/raw/master/20210309230829.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sutianxin.top/posts/996934066"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-03-29 22:01:10"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,a={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(a)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css"><link rel="stylesheet" href="/css/cover.css"><link rel="stylesheet" href="/css/copyright.css"><link href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/year.css"><link rel="stylesheet" href="/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/PaddyLin-xum/wenjian@master/css/fontanimation.css"><link href="https://cdn.bootcdn.net/ajax/libs/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/twikoo.css"><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sutianxin/photo/raw/master/20210309230829.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arno</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gucheng"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu1"></use></svg><span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gushu"></use></svg><span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guwan"></use></svg><span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gujianzhu-01"></use></svg><span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofengwenfangsibaoyantaimoyan_huaban_huaban"></use></svg><span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-red_envelope"></use></svg><span>拓展</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/random/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingbaozhu"></use></svg><span>随机文章</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/adjust/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingguadeng"></use></svg><span>更换背景</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/statistics/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingjiutan"></use></svg><span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://sutianxin.gitee.io"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhongguojie"></use></svg><span>国内镜像</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingzhuzi"></use></svg><span>导航栏</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bb/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxinghulu"></use></svg><span>哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshanzi"></use></svg><span>音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaiqiwujiuqijue_huaban_huaban"></use></svg><span>社交</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqixun_huaban_huaban_huaban"></use></svg><span>友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gufengwujianzhongguofenggudaileqibianzhong_huaban_huaban_huaban_huaban"></use></svg><span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guqin"></use></svg><span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL高级学习（二）-MySQL体系结构、SQL优化、索引使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-09T15:07:11.000Z" title="发表于 2021-03-09 23:07:11">2021-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-29T14:01:10.566Z" title="更新于 2021-03-29 22:01:10">2021-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL%E9%AB%98%E7%BA%A7/">MySQL高级</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.6k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、MySQL的体系结构概览"><a href="#一、MySQL的体系结构概览" class="headerlink" title="一、MySQL的体系结构概览"></a>一、MySQL的体系结构概览</h1><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307200516.png" alt="image-20210307200516510"></p><blockquote><p><strong>整个MySQL Server由以下组成</strong></p></blockquote><ul><li><p>Connection Pool : 连接池组件</p></li><li><p>Management Services &amp; Utilities : 管理服务和工具组件</p></li><li><p>SQL Interface : SQL接口组件</p></li><li><p>Parser : 查询分析器组件</p></li><li><p>Optimizer : 优化器组件</p></li><li><p>Caches &amp; Buﬀers : 缓冲池组件</p></li><li><p>Pluggable Storage Engines : 存储引擎</p></li><li><p>File System : 文件系统</p></li></ul><h2 id="1-1、连接层"><a href="#1-1、连接层" class="headerlink" title="1.1、连接层"></a>1.1、连接层</h2><blockquote><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。</p><p>主要完成一些类似于<strong>连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了<strong>线程池</strong>的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p></blockquote><h2 id="1-2、服务层"><a href="#1-2、服务层" class="headerlink" title="1.2、服务层"></a>1.2、服务层</h2><blockquote><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成<strong>缓存的查询（Caches &amp; Buﬀers）</strong>，<strong>SQL的分析和优化（Optimizer）</strong>，部分内置函数的执行。<strong>所有跨存储引擎的功能也在这一层实现，如 过程、函数等</strong>。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是</p><p>select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p></blockquote><h2 id="1-3、引擎层"><a href="#1-3、引擎层" class="headerlink" title="1.3、引擎层"></a>1.3、引擎层</h2><blockquote><p>存储引擎层， <strong>存储引擎真正的负责了MySQL中数据的存储和提取</strong>，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们<strong>可以根据自己的需要，来选取合适的存储引擎</strong>。</p></blockquote><h2 id="1-4、存储层"><a href="#1-4、存储层" class="headerlink" title="1.4、存储层"></a>1.4、存储层</h2><blockquote><p>数据存储层，主要是<strong>将数据存储在文件系统之上</strong>，并完成与存储引擎的交互。</p></blockquote><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h1 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h1><h2 id="2-1、存储引擎概述"><a href="#2-1、存储引擎概述" class="headerlink" title="2.1、存储引擎概述"></a>2.1、存储引擎概述</h2><blockquote><p>和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。</p><p><strong>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式</strong> 。</p><p><strong>存储引擎是基于表</strong>的，而不是基于库的。所以存储引擎也可被称为表类型。</p></blockquote><p>在使用数据库可视化工具创建库时，不会要求你选择存储引擎，而在创建表时，会让你选择存储引擎。</p><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307203200.png" alt="image-20210307203200389"></p><blockquote><p>Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。</p><p>MySQL5.0支持的存储引擎包含 ： <strong>InnoDB（5.5之后，MySQL默认的存储引擎）</strong> 、<strong>MyISAM（5.5之前，MySQL默认的存储引擎）</strong> 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，<strong>其中InnoDB和BDB提供事务安全表</strong>，其他存储引擎是非事务安全表。</p></blockquote><h3 id="1、查看当前数据库支持的存储引擎"><a href="#1、查看当前数据库支持的存储引擎" class="headerlink" title="1、查看当前数据库支持的存储引擎"></a>1、查看当前数据库支持的存储引擎</h3><blockquote><p>使用指令 <code>show engines</code> 来查看</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307203646.png" alt="image-20210307203646293"></p><blockquote><p>从上面搜索到的结果可以看到，MySQL默认支持的存储引擎是 <strong>InnoDB</strong>，在建表时如果不加以指定，那么默认使用 <strong>InnoDB</strong> 作为存储引擎。</p><p><strong>InnoDB</strong> 支持 <strong>事务</strong>、<strong>行级锁</strong> 和 <strong>外键</strong>。</p><p>MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。</p></blockquote><h3 id="2、查看默认的存储引擎"><a href="#2、查看默认的存储引擎" class="headerlink" title="2、查看默认的存储引擎"></a>2、查看默认的存储引擎</h3><blockquote><p>使用指令 <code>show variables like &#39;%storage_engine%&#39;</code> 查看</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%storage_engine%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307204509.png" alt="image-20210307204509575"></p><h2 id="2-2、各种存储引擎特性"><a href="#2-2、各种存储引擎特性" class="headerlink" title="2.2、各种存储引擎特性"></a>2.2、各种存储引擎特性</h2><blockquote><p>下面介绍几种常用的存储引擎，和各引擎间区别，如下表</p></blockquote><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>MERGE</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td><td>没有</td><td>有</td></tr><tr><td>事务安全</td><td><strong>支持</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td><strong>行锁(适合高并发)</strong></td><td><strong>表锁</strong></td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td><td></td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>数据索引</td><td>支持</td><td></td><td>支持</td><td></td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td><td>低</td><td>高</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td><strong>支持</strong></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="1、查看-修改MySQL事务隔离级别"><a href="#1、查看-修改MySQL事务隔离级别" class="headerlink" title="1、查看/修改MySQL事务隔离级别"></a>1、查看/修改MySQL事务隔离级别</h3><ul><li>查看MySQL的事务隔离级别，MySQL默认的事务隔离级别是<strong>可重复读</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%isolation%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307211527.png" alt="image-20210307211527447"></p><ul><li>修改MySQL的事务隔离级别</li></ul><blockquote><p>语法：</p><p>SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL<br>{<br>REPEATABLE READ<br>| READ COMMITTED<br>| READ UNCOMMITTED<br>| SERIALIZABLE<br>}</p></blockquote><h3 id="2、InnoDB"><a href="#2、InnoDB" class="headerlink" title="2、InnoDB"></a>2、InnoDB</h3><blockquote><p>InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p><p>InnoDB存储引擎不同于其他存储引擎的特点 ：<strong>事务控制</strong>、支持外键</p></blockquote><h3 id="3、InnoDB的事务控制"><a href="#3、InnoDB的事务控制" class="headerlink" title="3、InnoDB的事务控制"></a>3、InnoDB的事务控制</h3><ul><li>创建一张表用于演示 <strong>InnoDB</strong> 存储引擎的特性–事务控制。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table goods_innodb</span><br><span class="line">(</span><br><span class="line">    id   int         NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name varchar(20) NOT NULL,</span><br><span class="line">    primary key (id)</span><br><span class="line">) ENGINE &#x3D; innodb</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure><blockquote><p>手动开启事务，打开两个cmd窗口，链接上数据库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p你的密码</span><br></pre></td></tr></table></figure><blockquote><p>在第一个窗口中输入以下命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into goods_innodb(id,name) values (2,&#39;起飞&#39;);</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307211158.png" alt="image-20210307211158447"></p><blockquote><p>此时使用第二个窗口查看表数据，发现没有 <code>id</code> 为2的数据</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307211222.png" alt="image-20210307211222119"></p><blockquote><p>在第一个窗口中提交事务，再次查看第二个窗口中数据库表数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307211308.png" alt="image-20210307211308231"></p><h3 id="4、InnoDB支持外键"><a href="#4、InnoDB支持外键" class="headerlink" title="4、InnoDB支持外键"></a>4、InnoDB支持外键</h3><ul><li>创建两张表用于演示 <strong>InnoDB</strong> 存储引擎的特性–支持外键。</li></ul><blockquote><p>MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， <strong>子表在创建外键的时候， 也会自动的创建对应的索引。</strong></p><p><strong>下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">create table country_innodb</span><br><span class="line">(</span><br><span class="line">    country_id   int          NOT NULL AUTO_INCREMENT,</span><br><span class="line">    country_name varchar(100) NOT NULL,</span><br><span class="line">    primary key (country_id)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line">create table city_innodb</span><br><span class="line">(</span><br><span class="line">    city_id    int         NOT NULL AUTO_INCREMENT,</span><br><span class="line">    city_name  varchar(50) NOT NULL,</span><br><span class="line">    country_id int         NOT NULL,</span><br><span class="line">    primary key (city_id),</span><br><span class="line">    key idx_fk_country_id (country_id),</span><br><span class="line">    CONSTRAINT &#96;fk_city_country&#96; FOREIGN KEY (country_id) REFERENCES country_innodb (country_id) ON DELETE RESTRICT ON UPDATE CASCADE</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br><span class="line">  </span><br><span class="line">insert into country_innodb values(null,&#39;China&#39;),(null,&#39;America&#39;),(null,&#39;Japan&#39;);</span><br><span class="line">insert into city_innodb values(null,&#39;Xian&#39;,1),(null,&#39;NewYork&#39;,2), (null,&#39;BeiJing&#39;,1);  </span><br></pre></td></tr></table></figure><blockquote><p>在删除主表信息时，如果子表中有和待删除数据关联的数据，那么主表不能删除</p><p>试着删除主表中 <code>id</code> 为2的数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from country_innodb where country_id &#x3D; 2;</span><br></pre></td></tr></table></figure><blockquote><p>控制台结果为：</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307213340.png" alt="image-20210307213340193"></p><blockquote><p>在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 <strong>RESTRICT、CASCADE、SET NULL和 NO ACTION。</strong></p></blockquote><ul><li><p>RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新；</p></li><li><p>CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录；</p></li><li><p>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。</p></li></ul><blockquote><p>针对上面创建的两个表， 子表的外键指定是 <strong>ON DELETE RESTRICT ON UPDATE CASCADE</strong> 方式的， <strong>那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。</strong></p></blockquote><ul><li>下面演示 <strong>UPDATE CASCADE</strong> ，将 <code>id</code> 为1的记录的 <code>id</code> 设置为100</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update country_innodb set country_id &#x3D; 100 where country_id &#x3D; 1;</span><br></pre></td></tr></table></figure><blockquote><p>此时再次查看两张表中的数据，发现子表与父表关联的数据也被修改了。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307214342.png" alt="image-20210307214342641"></p><h3 id="5、InnoDB的存储方式"><a href="#5、InnoDB的存储方式" class="headerlink" title="5、InnoDB的存储方式"></a>5、InnoDB的存储方式</h3><blockquote><p><strong>InnoDB</strong> 存储表和索引有以下两种方式：</p></blockquote><ul><li>使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存innodb_data_home_dir 和 innodb_data_ﬁle_path定义的表空间中，可以是多个文件。</li><li>使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在.ibd 中。</li></ul><h3 id="6、MyISAM"><a href="#6、MyISAM" class="headerlink" title="6、MyISAM"></a>6、MyISAM</h3><blockquote><p>MyISAM 不支持事务、也不支持外键，**其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 **。</p><p>有以下两个比较重要的特点：</p></blockquote><ul><li><strong>不支持事务</strong></li></ul><blockquote><p>创建一张表，在建表语句中指定存储引擎为<strong>MyISAM</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table goods_myisam</span><br><span class="line">(</span><br><span class="line">    id   int         NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name varchar(20) NOT NULL,</span><br><span class="line">    primary key (id)</span><br><span class="line">) ENGINE &#x3D; myisam</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure><blockquote><p>同上，使用两个cmd窗口，在第一个窗口中使用 <code>start transaction</code> 开启事务，插入一条数据</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307224114.png" alt="image-20210307224114417"></p><blockquote><p>在第二个窗口查看表数据，发现已经查询到了未提交的数据，故 <code>myisam</code> 不支持事务。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from &#96;index_study&#96;.goods_myisam;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307224221.png" alt="image-20210307224221849"></p><ul><li><strong>文件存储方式</strong></li></ul><blockquote><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是：</p></blockquote><ul><li>.frm (存储表定义)；</li><li>.MYD(MYData , 存储数据)；</li><li>.MYI(MYIndex , 存储索引)；</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307224439.png" alt="image-20210307224439274"></p><h3 id="7、MEMORY"><a href="#7、MEMORY" class="headerlink" title="7、MEMORY"></a>7、MEMORY</h3><blockquote><p>Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。</p></blockquote><h2 id="2-3、存储引擎的选择"><a href="#2-3、存储引擎的选择" class="headerlink" title="2.3、存储引擎的选择"></a>2.3、存储引擎的选择</h2><blockquote><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。<strong>对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</strong></p><p>以下是几种常用的存储引擎的使用环境。</p></blockquote><h3 id="1、InnoDB"><a href="#1、InnoDB" class="headerlink" title="1、InnoDB"></a>1、InnoDB</h3><blockquote><p>Mysql的默认存储引擎，<strong>用于事务处理应用程序，支持外键。</strong></p><p>如果应用对事务的完整性有比较高的要求，<strong>在并发条件下要求数据的一致性</strong>，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p><p>InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于<strong>类似于计费系统或者财务系统等对数据准确性要求比较高的系统</strong>，InnoDB是最合适的选择。</p><p><strong>开发中绝大部分使用的都是InnoDB</strong></p></blockquote><h3 id="2、MyISAM"><a href="#2、MyISAM" class="headerlink" title="2、MyISAM"></a>2、MyISAM</h3><blockquote><p>如果应用是以<strong>读操作和插入操作</strong>为主，<strong>只有很少的更新和删除操作</strong>，并且<strong>对事务的完整性、并发性要求不是很高</strong>，那么选择这个存储引擎是非常合适的。</p></blockquote><h3 id="3、Memory"><a href="#3、Memory" class="headerlink" title="3、Memory"></a>3、Memory</h3><blockquote><p>将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。</p><p><strong>MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中</strong>，其次是要确保表的数据可以恢复，<strong>数据库异常终止后表中的数据是可以恢复的。</strong></p><p>MEMORY表通常用于<strong>更新不太频繁的小表</strong>，用以快速得到访问结果。</p></blockquote><h1 id="三、SQL优化（一）"><a href="#三、SQL优化（一）" class="headerlink" title="三、SQL优化（一）"></a>三、SQL优化（一）</h1><blockquote><p>在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些<strong>有问题的 SQL 语句就成为整个系统性能的瓶颈</strong>，因此我们必须要对它们进行优化。</p><p>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p></blockquote><h2 id="3-1、查看SQL执行频率"><a href="#3-1、查看SQL执行频率" class="headerlink" title="3.1、查看SQL执行频率"></a>3.1、查看SQL执行频率</h2><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和</p><p>global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。</p><h3 id="1、查询当前会话中所有统计参数值"><a href="#1、查询当前会话中所有统计参数值" class="headerlink" title="1、查询当前会话中所有统计参数值"></a>1、查询当前会话中所有统计参数值</h3><blockquote><p>下面的命令显示了当前 session 中所有统计参数的值：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#39;Com_______&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308153514.png" alt="image-20210308153514166"></p><h3 id="2、查询全局统计参数值"><a href="#2、查询全局统计参数值" class="headerlink" title="2、查询全局统计参数值"></a>2、查询全局统计参数值</h3><blockquote><p>上面的命令查询的只是<strong>当前链接</strong>的统计参数，如果要统计全局参数，我们可以在 status 前添加一个 <code>global</code> 参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status like &#39;Com_______&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308154221.png" alt="image-20210308154221306"></p><h3 id="3、查询InnoDB存储引擎的操作数量"><a href="#3、查询InnoDB存储引擎的操作数量" class="headerlink" title="3、查询InnoDB存储引擎的操作数量"></a>3、查询InnoDB存储引擎的操作数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#39;Innodb_rows_%&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果如下</p><p><code>InnoDB</code> 插入的行：8</p><p><code>InnoDB</code> 查询的行：20</p><p><code>InnoDB</code> 更新的行：3</p><p><code>InnoDB</code> 删除的行：0</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308154523.png" alt="image-20210308154523163"></p><blockquote><p>通过上面的几条指令，就可以大致确定当前数据库到底是以读为主还是以写为主。</p></blockquote><h3 id="4、参数说明"><a href="#4、参数说明" class="headerlink" title="4、参数说明"></a>4、参数说明</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>Com_select</td><td>执行 select 操作的次数，一次查询只累加 1。</td></tr><tr><td>Com_insert</td><td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td></tr><tr><td>Com_update</td><td>执行 UPDATE 操作的次数。</td></tr><tr><td>Com_delete</td><td>执行 DELETE 操作的次数。</td></tr><tr><td>Innodb_rows_read</td><td>select 查询返回的行数。</td></tr><tr><td>Innodb_rows_inserted</td><td>执行 INSERT 操作插入的行数。</td></tr><tr><td>Innodb_rows_updated</td><td>执行 UPDATE 操作更新的行数。</td></tr><tr><td>Innodb_rows_deleted</td><td>执行 DELETE 操作删除的行数。</td></tr><tr><td>Connections</td><td>试图连接 MySQL 服务器的次数。</td></tr><tr><td>Uptime</td><td>服务器工作时间。</td></tr><tr><td>Slow_queries</td><td>慢查询的次数。</td></tr></tbody></table><blockquote><p>Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计。</p><p>Innodb_*** : 这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。</p></blockquote><h2 id="3-2、定位低效率执行SQL"><a href="#3-2、定位低效率执行SQL" class="headerlink" title="3.2、定位低效率执行SQL"></a>3.2、定位低效率执行SQL</h2><blockquote><p>可以通过以下两种方式定位执行效率较低的 SQL 语句。</p></blockquote><ul><li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=ﬁle_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。</li><li><strong>show processlist</strong> : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ul><h3 id="1、使用show-processlist-指令连接和执行操作"><a href="#1、使用show-processlist-指令连接和执行操作" class="headerlink" title="1、使用show processlist 指令连接和执行操作"></a>1、使用show processlist 指令连接和执行操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure><blockquote><p>查看执行效果</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308155757.png" alt="image-20210308155757344"></p><blockquote><p>查看 <code>Info</code> 列信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ApplicationName&#x3D;DataGrip 2020.2.2 *&#x2F; 操作数据库的应用，我这里用的是&#96;DATAGRIP&#96;</span><br><span class="line">show processlist;&#x2F;&#x2F;执行的语句</span><br></pre></td></tr></table></figure><blockquote><p>上述参数说明</p></blockquote><ul><li>id列，用户登录mysql时，系统分配的”connection_id”，可以使用函数connection_id()查看</li><li>user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</li><li>host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户</li><li>db列，显示这个进程目前连接的是哪个数据库</li><li>command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接<br>（connect）等</li><li>time列，显示这个状态持续的时间，单位是秒</li><li>state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一<br>个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成</li><li>info列，显示这个sql语句，是判断问题语句的一个重要依据</li></ul><h3 id="2、使用show-processlist实时监控慢查询sql"><a href="#2、使用show-processlist实时监控慢查询sql" class="headerlink" title="2、使用show processlist实时监控慢查询sql"></a>2、使用show processlist实时监控慢查询sql</h3><blockquote><p>在一张大数据表中，执行一条慢查询sql，然后快速使用 <code>show processlist</code> 查看，结果如下</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308161158.png" alt="image-20210308161158303"></p><h2 id="3-3、Explain分析执行计划"><a href="#3-3、Explain分析执行计划" class="headerlink" title="3.3、Explain分析执行计划"></a>3.3、Explain分析执行计划</h2><blockquote><p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p></blockquote><h3 id="1、使用-explain-查询SQL语句的执行计划"><a href="#1、使用-explain-查询SQL语句的执行计划" class="headerlink" title="1、使用 explain 查询SQL语句的执行计划"></a>1、使用 explain 查询SQL语句的执行计划</h3><blockquote><p>explain 要查询的SQL语句;</p><p>这里以视频给的数据库表为例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_item;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308162534.png" alt="image-20210308162533553"></p><blockquote><p>说明</p></blockquote><table><thead><tr><th><strong>字段</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>type</td><td>表示表的连接类型，性能由好到差的连接类型为( system —&gt; const —–&gt; eq_ref ——&gt; ref——-&gt; ref_or_null—-&gt; index_merge —&gt; index_subquery —–&gt; range —–&gt; index ——&gt; all )</td></tr><tr><td>possible_keys</td><td>表示查询时，可能使用的索引</td></tr><tr><td>key</td><td>表示实际使用的索引</td></tr><tr><td>key_len</td><td>索引字段的长度</td></tr><tr><td>rows</td><td>扫描行的数量</td></tr><tr><td>extra</td><td>执行情况的说明和描述</td></tr></tbody></table><h3 id="2、环境准备"><a href="#2、环境准备" class="headerlink" title="2、环境准备"></a>2、环境准备</h3><blockquote><p>准备三张表，表与表之间的关系如下</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308162901.png" alt="image-20210308162901514"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;t_role&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;id&#96;          varchar(32) NOT NULL,</span><br><span class="line">    &#96;role_name&#96;   varchar(255) DEFAULT NULL,</span><br><span class="line">    &#96;role_code&#96;   varchar(255) DEFAULT NULL,</span><br><span class="line">    &#96;description&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">    UNIQUE KEY &#96;unique_role_name&#96; (&#96;role_name&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;t_user&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;id&#96;       varchar(32) NOT NULL,</span><br><span class="line">    &#96;username&#96; varchar(45) NOT NULL,</span><br><span class="line">    &#96;password&#96; varchar(96) NOT NULL,</span><br><span class="line">    &#96;name&#96;     varchar(45) NOT NULL,</span><br><span class="line"></span><br><span class="line">    PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">    UNIQUE KEY &#96;unique_user_username&#96; (&#96;username&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;user_role&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;id&#96;      int(11) NOT NULL auto_increment,</span><br><span class="line">    &#96;user_id&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">    &#96;role_id&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">    KEY &#96;fk_ur_user_id&#96; (&#96;user_id&#96;),</span><br><span class="line">    KEY &#96;fk_ur_role_id&#96; (&#96;role_id&#96;),</span><br><span class="line">    CONSTRAINT &#96;fk_ur_role_id&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;t_role&#96; (&#96;id&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,</span><br><span class="line">    CONSTRAINT &#96;fk_ur_user_id&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;t_user&#96; (&#96;id&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;)</span><br><span class="line">values (&#39;1&#39;, &#39;super&#39;, &#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;, &#39;超级管理员&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;)</span><br><span class="line">values (&#39;2&#39;, &#39;admin&#39;, &#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;, &#39;系统管理员&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;)</span><br><span class="line">values (&#39;3&#39;, &#39;itcast&#39;, &#39;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#39;, &#39;test02&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;)</span><br><span class="line">values (&#39;4&#39;, &#39;stu1&#39;, &#39;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK&#x2F;y&#x2F;spH5rftCpUMZa&#39;, &#39;学生1&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;)</span><br><span class="line">values (&#39;5&#39;, &#39;stu2&#39;, &#39;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr&#x2F;p1FR6ZKgc18u.Tvqm&#39;, &#39;学生2&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;)</span><br><span class="line">values (&#39;6&#39;, &#39;t1&#39;, &#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;, &#39;老师 1&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;)</span><br><span class="line">VALUES (&#39;5&#39;, &#39;学生&#39;, &#39;student&#39;, &#39;学生&#39;);</span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;)</span><br><span class="line">VALUES (&#39;7&#39;, &#39;老师&#39;, &#39;teacher&#39;, &#39;老师&#39;);</span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;)</span><br><span class="line">VALUES (&#39;8&#39;, &#39;教学管理员&#39;, &#39;teachmanager&#39;, &#39;教学管理员&#39;);</span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;)</span><br><span class="line">VALUES (&#39;9&#39;, &#39;管理员&#39;, &#39;admin&#39;, &#39;管理员&#39;);</span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;)</span><br><span class="line">VALUES (&#39;10&#39;, &#39;超级管理员&#39;, &#39;super&#39;, &#39;超级管理员&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO user_role(id, user_id, role_id)</span><br><span class="line">VALUES (NULL, &#39;1&#39;, &#39;5&#39;),</span><br><span class="line">       (NULL, &#39;1&#39;, &#39;7&#39;),</span><br><span class="line">       (NULL, &#39;2&#39;, &#39;8&#39;),</span><br><span class="line">       (NULL, &#39;3&#39;, &#39;9&#39;),</span><br><span class="line">       (NULL, &#39;4&#39;, &#39;8&#39;),</span><br><span class="line">       (NULL, &#39;5&#39;, &#39;10&#39;);</span><br></pre></td></tr></table></figure><h3 id="3、explain-之-id"><a href="#3、explain-之-id" class="headerlink" title="3、explain 之 id"></a>3、explain 之 id</h3><blockquote><p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</p><p>id 情况有三种：</p></blockquote><ul><li>id 相同表示加载表的顺序是从上到下</li></ul><blockquote><p>这里以一条多表查询语句为例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT *</span><br><span class="line">FROM t_user u</span><br><span class="line">	JOIN user_role ur ON u.id &#x3D; ur.user_id</span><br><span class="line">	JOIN t_role tr ON ur.role_id &#x3D; tr.id;</span><br></pre></td></tr></table></figure><blockquote><p>查看结果，可以看到 <code>ur</code> 表的加载顺序高于 <code>tr</code> 表和 <code>u</code> 表，第一列不是 <code>id</code> 。。。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308165156.png" alt="image-20210308165155913"></p><ul><li>id 不同id值越大，优先级越高</li></ul><blockquote><p>越先被执行，这里以一条子查询语句为例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT *</span><br><span class="line">FROM t_role</span><br><span class="line">WHERE id &#x3D; (</span><br><span class="line">	SELECT role_id</span><br><span class="line">	FROM user_role</span><br><span class="line">	WHERE user_id &#x3D; (</span><br><span class="line">		SELECT id</span><br><span class="line">		FROM t_user</span><br><span class="line">		WHERE username &#x3D; &#39;stu1&#39;</span><br><span class="line">	)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>执行语句查看结果，最内层的子查询的执行优先级最高。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308170831.png" alt="image-20210308170831240"></p><ul><li>id 有相同，也有不同，同时存在。</li></ul><blockquote><p>id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</p><p>这里以一条带子查询和连接查询的sql为例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT *</span><br><span class="line">FROM t_role r, (</span><br><span class="line">		SELECT *</span><br><span class="line">		FROM user_role ur</span><br><span class="line">		WHERE ur.&#96;user_id&#96; &#x3D; &#39;2&#39;</span><br><span class="line">	) a</span><br><span class="line">WHERE r.id &#x3D; a.role_id;</span><br></pre></td></tr></table></figure><blockquote><p>查看结果，发现先执行子查询，后执行连接查询。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308171713.png" alt="image-20210308171713304"></p><h3 id="4、explain-之-select-type"><a href="#4、explain-之-select-type" class="headerlink" title="4、explain 之 select_type"></a>4、explain 之 select_type</h3><blockquote><p>表示 SELECT 的类型，常见的取值如下表，从上到下效率越来越低。</p></blockquote><table><thead><tr><th><strong>select_type</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的select查询，查询中不包含子查询或者UNION</td></tr><tr><td>PRIMARY</td><td><strong>查询中若包含任何复杂的子查询，最外层查询标记为该标识</strong></td></tr><tr><td>SUBQUERY</td><td>在SELECT 或 WHERE 列表中包含了子查询</td></tr><tr><td>DERIVED</td><td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><h3 id="5、explain-之-table"><a href="#5、explain-之-table" class="headerlink" title="5、explain 之 table"></a>5、explain 之 table</h3><blockquote><p>展示这一行的数据是关于哪一张表的</p></blockquote><h3 id="6、explain-之-type"><a href="#6、explain-之-type" class="headerlink" title="6、explain 之 type"></a>6、explain 之 type</h3><blockquote><p>type 显示的是访问类型，是较为重要的一个指标，可取值为：</p></blockquote><table><thead><tr><th><strong>type</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>NULL</td><td>MySQL不访问任何表，索引，直接返回结果</td></tr><tr><td>system</td><td>表只有一行记录(等于系统表)，这是<code>const</code>类型的特例，一般不会出现</td></tr><tr><td><code>const</code></td><td>表示通过索引一次就找到了，<code>const</code>用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常亮。<code>const</code>于将”主键” 或 “唯一” 索引的所有部分与常量值进行比较</td></tr><tr><td><code>eq_ref</code></td><td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td></tr><tr><td>ref</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td></tr><tr><td>range</td><td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。</td></tr><tr><td>index</td><td>index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</td></tr><tr><td>all</td><td>将遍历全表以找到匹配的行</td></tr></tbody></table><ul><li>type 为 <code>null</code> 的情况，例如使用 <code>select now()</code>访问当前时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select now();</span><br></pre></td></tr></table></figure><blockquote><p>查看结果</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308191128.png" alt="image-20210308191121013"></p><ul><li>type 为 <code>system</code> 的情况，数据源中只有一条数据时出现</li><li>type 为 <code>const</code> 的情况，使用 <code>t_user</code> 表中的 <strong>主键索引</strong> 和 <strong>唯一索引</strong> 查看</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where username &#x3D; &#39;super&#39;;</span><br><span class="line">explain select * from t_user where id &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308192134.png" alt="image-20210308192134670"></p><ul><li><p>type为 <code>eq_ref</code> 的情况，使用主键的关联查询，关联查询出的记录只有一条；</p></li><li><p>type为 <code>index</code> 的情况，查询整个索引树，效率通常不高</p></li><li><p>type为 <code>all</code> 的情况，遍历整个数据文件。</p></li></ul><blockquote><p>一般来说，我们需要保证查询至少达到 <code>range</code> 级别，最好达到 <code>ref</code>。</p></blockquote><h3 id="7、explain-之-key"><a href="#7、explain-之-key" class="headerlink" title="7、explain 之 key"></a>7、explain 之 key</h3><ul><li>possible_keys : 显示可能应用在这张表的索引， 一个或多个。</li><li>key ： 实际使用的索引， 如果为NULL， 则没有使用索引。</li><li>key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</li><li>possible_keys : 显示可能应用在这张表的索引， 一个或多个。</li><li>key ： 实际使用的索引， 如果为NULL， 则没有使用索引。</li></ul><h3 id="8、explain-之-rows"><a href="#8、explain-之-rows" class="headerlink" title="8、explain 之 rows"></a>8、explain 之 rows</h3><blockquote><p>扫描行的数量。</p></blockquote><h3 id="9、explain-之-extra"><a href="#9、explain-之-extra" class="headerlink" title="9、explain 之 extra"></a>9、explain 之 extra</h3><blockquote><p>其他的额外的执行计划信息，在该列展示 。</p><p>优化前两个，保持第三个。</p></blockquote><table><thead><tr><th>extra</th><th>含义</th></tr></thead><tbody><tr><td><code>using ﬁlesort</code></td><td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为“文件排序”, 效率低。</td></tr><tr><td>using temporary</td><td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和group by； 效率低</td></tr><tr><td>using index</td><td>表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据;当能通过读取索引就可以得到想要的数据，那就不需要读取行了。</td></tr><tr><td>Using where</td><td>表明使用了where过滤</td></tr><tr><td>using join buffer</td><td>使用了连接缓存：</td></tr><tr><td>impossible where</td><td>where子句的值总是false，不能用来获取任何元组</td></tr></tbody></table><h3 id="10、explain之case"><a href="#10、explain之case" class="headerlink" title="10、explain之case"></a>10、explain之case</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210312224222.png" alt="image-20210312224221780"></p><blockquote><p>执行顺序：4-3-2-1-NULL</p></blockquote><ul><li>执行顺序4</li></ul><h2 id="3-4、show-profile分析SQL"><a href="#3-4、show-profile分析SQL" class="headerlink" title="3.4、show profile分析SQL"></a>3.4、show profile分析SQL</h2><blockquote><p>Mysql从5.0.37版本开始增加了对 show proﬁles 和 show proﬁle 语句的支持。show proﬁles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p></blockquote><h3 id="1、查看当前MySQL是否支持profile"><a href="#1、查看当前MySQL是否支持profile" class="headerlink" title="1、查看当前MySQL是否支持profile"></a>1、查看当前MySQL是否支持profile</h3><blockquote><p>通过 have_proﬁling 参数，能够看到当前MySQL是否支持proﬁle：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@have_profiling;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308195521.png" alt="image-20210308195521096"></p><blockquote><p>默认proﬁling是关闭的，可以通过set语句在Session级别开启proﬁling：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set profiling &#x3D; 1;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308200027.png" alt="image-20210308200027227"></p><blockquote><p>此时查看 <code>profiling</code> 的值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@profiling;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308200142.png" alt="image-20210308200142645"></p><h3 id="2、使用-show-profiles-指令查看sql语句和耗时"><a href="#2、使用-show-profiles-指令查看sql语句和耗时" class="headerlink" title="2、使用 show profiles 指令查看sql语句和耗时"></a>2、使用 show profiles 指令查看sql语句和耗时</h3><blockquote><p>其中 <code>Query</code> 为执行的SQL语句，而 <code>Duration</code> 为该SQL执行耗费的时间。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308201914.png" alt="image-20210308201913192"></p><blockquote><p>在上面查询出来的结果之上，可以通过 <code>show profile for query id值</code> 指令来查看某条sql语句的详细信息，例如查看<code>id</code>为5的查询语句的详细信息。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile for query 5;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210308202515.png" alt="image-20210308202515442"></p><blockquote><p>发现 <code>Sending data</code> 阶段花费了最多时间；</p><p>Sending data 状态表示<strong>MySQL线程开始访问数据行并把结果返回给客户端</strong>，而不仅仅是返回个客户端。</p><p><strong>由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。</strong></p></blockquote><h2 id="3-5、trace分析优化器执行计划"><a href="#3-5、trace分析优化器执行计划" class="headerlink" title="3.5、trace分析优化器执行计划"></a>3.5、trace分析优化器执行计划</h2><blockquote><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p></blockquote><h3 id="1、打开trace-并设置格式和内存大小"><a href="#1、打开trace-并设置格式和内存大小" class="headerlink" title="1、打开trace 并设置格式和内存大小"></a>1、打开trace 并设置格式和内存大小</h3><blockquote><p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET  optimizer_trace&#x3D;&quot;enabled&#x3D;on&quot;,end_markers_in_json&#x3D;on;</span><br><span class="line">set  optimizer_trace_max_mem_size&#x3D;1000000;</span><br></pre></td></tr></table></figure><h3 id="2、执行SQL语句"><a href="#2、执行SQL语句" class="headerlink" title="2、执行SQL语句"></a>2、执行SQL语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from  where id &lt; 4;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309143138.png" alt="image-20210309143137932"></p><h3 id="3、查看Mysql如何执行上述的SQL语句"><a href="#3、查看Mysql如何执行上述的SQL语句" class="headerlink" title="3、查看Mysql如何执行上述的SQL语句"></a>3、查看Mysql如何执行上述的SQL语句</h3><blockquote><p>检查 <code>infomation_schema</code>.<code>optimizer_trace</code> 就可以知道<strong>MySQL</strong>是如何执行SQL的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from  information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309143751.png" alt="image-20210309143751852"></p><h1 id="四、索引的使用"><a href="#四、索引的使用" class="headerlink" title="四、索引的使用"></a>四、索引的使用</h1><blockquote><p><strong>索引是数据库优化最常用也是最重要的手段之一</strong>，通过索引通常可以帮助用户<strong>解决大多数的MySQL的性能优化问题。</strong></p></blockquote><h2 id="4-1、验证索引提升查询效率"><a href="#4-1、验证索引提升查询效率" class="headerlink" title="4.1、验证索引提升查询效率"></a>4.1、验证索引提升查询效率</h2><blockquote><p>在我们准备的表结构tb_item 中， 一共存储了 300 万记录；</p></blockquote><h3 id="1、根据ID查询"><a href="#1、根据ID查询" class="headerlink" title="1、根据ID查询"></a>1、根据ID查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_item where id &#x3D; 1999\G;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309160155.png" alt="image-20210309160155777"></p><blockquote><p>查询速度很快， 接近0s ， <strong>主要的原因是因为id为主键</strong>， 有索引；</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309160229.png" alt="image-20210309160229150"></p><h3 id="2、根据title进行精确查询"><a href="#2、根据title进行精确查询" class="headerlink" title="2、根据title进行精确查询"></a>2、根据title进行精确查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_item where title &#x3D; &#39;iphoneX 移动3G 32G941&#39;\G;</span><br></pre></td></tr></table></figure><blockquote><p>执行sql语句，发现返回时间长达9s</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309161840.png" alt="image-20210309161840351"></p><blockquote><p>使用 <code>explain</code> 查看SQL语句的执行计划 ：</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309161912.png" alt="image-20210309161912903"></p><h3 id="3、优化查询，为title添加索引"><a href="#3、优化查询，为title添加索引" class="headerlink" title="3、优化查询，为title添加索引"></a>3、优化查询，为title添加索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create index idx_item_title on tb_item(title);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>创建索引可能会花费一些时间，这是因为MySQL底层正在为3000000条数据创建索引。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309162151.png" alt="image-20210309162151125"></p><blockquote><p>索引创建完成之后，再次进行查询</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309162222.png" alt="image-20210309162222355"></p><blockquote><p>再次通过explain查看SQL语句的执行计划，发现执行SQL时使用了刚才创建的索引</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309162714.png" alt="image-20210309162714413"></p><h2 id="4-2、索引的使用"><a href="#4-2、索引的使用" class="headerlink" title="4.2、索引的使用"></a>4.2、索引的使用</h2><h3 id="1、准备环境"><a href="#1、准备环境" class="headerlink" title="1、准备环境"></a>1、准备环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">use index_study;</span><br><span class="line">create table &#96;tb_seller&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;sellerid&#96;   varchar(100),</span><br><span class="line">    &#96;name&#96;       varchar(100),</span><br><span class="line">    &#96;nickname&#96;   varchar(50),</span><br><span class="line">    &#96;password&#96;   varchar(60),</span><br><span class="line">    &#96;status&#96;     varchar(1),</span><br><span class="line">    &#96;address&#96;    varchar(100),</span><br><span class="line">    &#96;createtime&#96; datetime,</span><br><span class="line">    primary key (&#96;sellerid&#96;)</span><br><span class="line">) engine &#x3D; innodb</span><br><span class="line">  default charset &#x3D; utf8mb4;</span><br><span class="line"></span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;alibaba&#39;, &#39;阿里巴巴&#39;, &#39;阿里小 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;1&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;baidu&#39;, &#39;百度科技有限公司&#39;, &#39;百度小 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;1&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;huawei&#39;, &#39;华为科技有限公司&#39;, &#39;华为小 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;0&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;itcast&#39;, &#39;传智播客教育科技有限公司&#39;, &#39;传智播 客&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;1&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;itheima&#39;, &#39;黑马程序员&#39;, &#39;黑马程序 员&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;0&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;luoji&#39;, &#39;罗技科技有限公司&#39;, &#39;罗技小 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;1&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;oppo&#39;, &#39;OPPO科技有限公司&#39;, &#39;OPPO官方旗舰 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;0&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;ourpalm&#39;, &#39;掌趣科技股份有限公司&#39;, &#39;掌趣小 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;1&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;qiandu&#39;, &#39;千度科技&#39;, &#39;千度小 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;2&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;sina&#39;, &#39;新浪科技有限公司&#39;, &#39;新浪官方旗舰 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;1&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;xiaomi&#39;, &#39;小米科技&#39;, &#39;小米官方旗舰 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;1&#39;, &#39;西安市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;)</span><br><span class="line">values (&#39;yijia&#39;, &#39;宜家家居&#39;, &#39;宜家家居旗舰 店&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, &#39;1&#39;, &#39;北京市&#39;, &#39;2088-01-01 12:00:00&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create index idx_seller_name_sta_addr on tb_seller (name, status, address);</span><br></pre></td></tr></table></figure><h3 id="2、避免索引失效–全值匹配"><a href="#2、避免索引失效–全值匹配" class="headerlink" title="2、避免索引失效–全值匹配"></a>2、避免索引失效–全值匹配</h3><blockquote><p>全值匹配，<strong>对索引中的所有列都指定具体值。</strong></p><p>该情况下，索引生效，执行效率高。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select	from tb_seller where name&#x3D;&#39;小米科技&#39; and status&#x3D;&#39;1&#39; and address&#x3D;&#39;北京市&#39;\G;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>explain</code> 查看上述SQL的执行计划：</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309164955.png" alt="image-20210309164955128"></p><h3 id="3、避免索引失效–最左前缀法则"><a href="#3、避免索引失效–最左前缀法则" class="headerlink" title="3、避免索引失效–最左前缀法则"></a>3、避免索引失效–最左前缀法则</h3><blockquote><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过中间的列，</p><p>如果跳过中间列，那么只会使用最左列的索引。</p><p>上述的索引加在了(name, status, address)中，那么查询就必须从 <code>name</code> 开始且不能跳过 <code>status</code> 直接跳到<code>address</code></p></blockquote><ul><li>匹配最左前缀法则，走索引：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain  select * from tb_seller where name&#x3D;&#39;小米科技&#39; and status&#x3D;&#39;1&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309165331.png" alt="image-20210309165331229"></p><ul><li>违背最左前缀法则，索引失效</li></ul><blockquote><p>跳过name直接查询status/address，索引失效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where status &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309165918.png" alt="image-20210309165918715"></p><blockquote><p>跳过索引列中间的status直接到address，此时只有最左边的索引列（name）生效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name &#x3D; &#39;小米科技&#39; and address &#x3D; &#39;西安市&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309170240.png" alt="image-20210309170240416"></p><blockquote><p>不使用索引的最左列进行查询，索引失效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where status &#x3D; &#39;1&#39; and address &#x3D; &#39;西安市&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309170735.png" alt="image-20210309170735922"></p><blockquote><p>索引失效与否与 <code>where</code> 子句的组装顺序无关。</p></blockquote><h3 id="3、避免索引失效–范围查询右边的列，不能使用索引"><a href="#3、避免索引失效–范围查询右边的列，不能使用索引" class="headerlink" title="3、避免索引失效–范围查询右边的列，不能使用索引"></a>3、避免索引失效–范围查询右边的列，不能使用索引</h3><blockquote><p>范围查询右边的列将不走索引，例如<code>status</code>使用了范围查询，那么只走 <code>name</code> 和 <code>status</code> 的索引，不走 <code>address</code> 的索引。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name &#x3D; &#39;小米科技&#39; and status &gt; &#39;1&#39; and address &#x3D; &#39;西安市&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309173327.png" alt="image-20210309173327169"></p><h3 id="4、避免索引失效–不要在索引列上进行运算操作"><a href="#4、避免索引失效–不要在索引列上进行运算操作" class="headerlink" title="4、避免索引失效–不要在索引列上进行运算操作"></a>4、避免索引失效–不要在索引列上进行运算操作</h3><blockquote><p>如果在索引列上进行运算操作，那么索引将失效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where substring(name,3,2) &#x3D; &#39;科技&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309173718.png" alt="image-20210309173718913"></p><blockquote><p>在status列上进行运算</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name &#x3D; &#39;小米科技&#39; and status + 1 &#x3D; &#39;2&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309173901.png" alt="image-20210309173901729"></p><h3 id="5、避免索引失效–字符串必须加单引号"><a href="#5、避免索引失效–字符串必须加单引号" class="headerlink" title="5、避免索引失效–字符串必须加单引号"></a>5、避免索引失效–字符串必须加单引号</h3><blockquote><p>字符串不加单引号，造成索引失效。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name &#x3D; &#39;小米科技&#39; and status &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309174606.png" alt="image-20210309174606023"></p><blockquote><p>演示不加单引号的情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name &#x3D; &#39;小米科技&#39; and status &#x3D; 1;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309174724.png" alt="image-20210309174724689"></p><blockquote><p>由于，在查询时没有对字符串加单引号，MySQL的查询优化器会自动的进行类型转换，造成索引失效。</p></blockquote><h3 id="6、尽量使用覆盖索引，避免select"><a href="#6、尽量使用覆盖索引，避免select" class="headerlink" title="6、尽量使用覆盖索引，避免select *"></a>6、尽量使用覆盖索引，避免select *</h3><blockquote><p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select *</p><p>如果查询列，超出索引列，也会降低性能。（例如多查询了一个password会导致性能下降）</p><p>TIPS:</p></blockquote><ul><li>using index ：使用覆盖索引的时候就会出现</li><li>using where：在查找使用索引的情况下，需要回表去查询所需的数据</li><li>using index condition：查找使用了索引，但是需要回表查询数据</li><li>using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</li></ul><h3 id="7、or分隔的条件"><a href="#7、or分隔的条件" class="headerlink" title="7、or分隔的条件"></a>7、or分隔的条件</h3><blockquote><p>or分割开的条件， 如果<strong>or前的条件中的列有索引</strong>，而<strong>后面的列中没有索引</strong>，那么<strong>涉及的索引都不会被用到</strong>。</p><p>示例，name字段是索引列 ， 而<code>createtime</code>不是索引列，中间是or进行连接是不走索引的 ：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select	from tb_seller where name&#x3D;&#39;黑马程序员&#39; or createtime &#x3D; &#39;2088-01-01 12:00:00&#39;\G;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309192548.png" alt="image-20210309192547979"></p><h3 id="8、以-开头的Like模糊查询，索引失效。"><a href="#8、以-开头的Like模糊查询，索引失效。" class="headerlink" title="8、以%开头的Like模糊查询，索引失效。"></a>8、以%开头的Like模糊查询，索引失效。</h3><blockquote><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name like &#39;%黑马&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309192904.png" alt="image-20210309192904852"></p><blockquote><p>但右%不会导致索引失效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name like &#39;黑马%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309193636.png" alt="image-20210309193636267"></p><ul><li>解决方法</li></ul><blockquote><p>通过覆盖索引（尽量不要使用select * ，使用索引中的那些列）来解决</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select name,status,address from tb_seller where name like &#39;%黑马%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309194114.png" alt="image-20210309194114849"></p><blockquote><p>如果查询的列中有不含索引的属性，那么索引将失效。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309194214.png" alt="image-20210309194214600"></p><h3 id="9、如果MySQL评估使用索引比全表更慢，则不使用索引。"><a href="#9、如果MySQL评估使用索引比全表更慢，则不使用索引。" class="headerlink" title="9、如果MySQL评估使用索引比全表更慢，则不使用索引。"></a>9、如果MySQL评估使用索引比全表更慢，则不使用索引。</h3><blockquote><p>为 <code>address</code> 创建一个单列索引</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index &#96;idx_address&#96; on tb_seller(address);</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309195218.png" alt="image-20210309195217953"></p><blockquote><p>执行以下的 sql 语句</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where address &#x3D; &#39;北京市&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309195502.png" alt="image-20210309195502240"></p><blockquote><p>将上述的条件修改为 <code>西安市</code>，再次执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where address &#x3D; &#39;西安市&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309200903.png" alt="image-20210309200903109"></p><ul><li>为什么？</li></ul><blockquote><p>因为在tb_seller表中 <code>address</code> 为 北京市 的数据占比非常大，使用索引不如进行全表扫描。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309201819.png" alt="image-20210309201819199"></p><h3 id="10、is-NULL、is-NOT-NULL-有时索引失效。"><a href="#10、is-NULL、is-NOT-NULL-有时索引失效。" class="headerlink" title="10、is NULL、is NOT NULL 有时索引失效。"></a>10、is NULL、is NOT NULL <code>有时</code>索引失效。</h3><blockquote><p>由于上面我们为 <code>address</code> 添加了单列索引，所以我们以 <code>address</code> 为例。</p></blockquote><ul><li>IS NULL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where address is null;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309202349.png" alt="image-20210309202349694"></p><blockquote><p>发现此时走了索引。</p></blockquote><ul><li>IS NOT NULL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where address is not null;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309202621.png" alt="image-20210309202621190"></p><blockquote><p>发现此时不走索引。</p></blockquote><ul><li>原因</li></ul><blockquote><p>这是因为在 tb_seller 表中绝大部分数据的 <code>address</code> 属性都不为空，那么当使用 <strong>IS NOT NULL</strong> 的时候，由于非空的数据太多，还不如直接扫描全表。</p><p>而使用 <strong>is null</strong> 时，由于为空的数据不多，所以使用索引速度快。</p></blockquote><h3 id="11、In、not-In-有时-不使用索引"><a href="#11、In、not-In-有时-不使用索引" class="headerlink" title="11、In、not In 有时 不使用索引"></a>11、In、not In <code>有时</code> 不使用索引</h3><blockquote><p>使用<code>in</code>进行测试</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where sellerid in (&#39;oppo&#39;,&#39;xiaomi&#39;,&#39;sina&#39;);</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309212907.png" alt="image-20210309212906507"></p><blockquote><p>使用 <code>not in</code> 进行测试，发现使用索引。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where sellerid not in (&#39;oppo&#39;,&#39;xiaomi&#39;,&#39;sina&#39;);</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309213506.png" alt="image-20210309213506912"></p><p><strong>In、not in 使不使用索引不是一刀切的。</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309214046.png" alt="image-20210309214046113"></p><h3 id="12、单列索引和复合索引"><a href="#12、单列索引和复合索引" class="headerlink" title="12、单列索引和复合索引"></a>12、单列索引和复合索引</h3><blockquote><p>尽量使用复合索引，而少使用单列索引。</p><p>创建复合索引：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_name_sta_address on tb_seller(name, status, address);</span><br></pre></td></tr></table></figure><blockquote><p>相当于创建了三个索引：</p><p>name<br>name + status<br>name + status + address</p></blockquote><ul><li>创建单列索引，在我们使用多个带索引的字段进行搜索时，不会使用全部索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create index idx_seller_name on tb_seller(name);</span><br><span class="line">create index idx_seller_status on tb_seller(status);</span><br><span class="line">create index idx_seller_address on tb_seller(address);</span><br></pre></td></tr></table></figure><blockquote><p>数据库会选择一个最优索引来使用。</p></blockquote><ul><li>演示单列索引和复合索引的区别</li></ul><blockquote><p>删除上面为 <code>address</code> 创建的单列索引</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index &#96;idx_address&#96; on tb_seller;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309215039.png" alt="image-20210309215039873"></p><blockquote><p>此时使用复合索引进行数据查找</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name &#x3D; &#39;小米科技&#39; and status &#x3D; &#39;1&#39; and address &#x3D; &#39;西安市&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309215250.png" alt="image-20210309215250200"></p><blockquote><p>删除表中的复合索引</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index idx_seller_name_sta_addr on tb_seller;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309215443.png" alt="image-20210309215443870"></p><blockquote><p>创建三个单列索引</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create index idx_seller_name on tb_seller(name);</span><br><span class="line">create index idx_seller_status on tb_seller(status);</span><br><span class="line">create index idx_seller_address on tb_seller(address);</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309215558.png" alt="image-20210309215558021"></p><blockquote><p>再次执行上面的查询语句</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name &#x3D; &#39;小米科技&#39; and status &#x3D; &#39;1&#39; and address &#x3D; &#39;西安市&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309215727.png" alt="image-20210309215727053"></p><blockquote><p>由于<code>name</code>列中的数据辨识度最高。</p></blockquote><h2 id="4-3、查看索引使用情况"><a href="#4-3、查看索引使用情况" class="headerlink" title="4.3、查看索引使用情况"></a>4.3、查看索引使用情况</h2><h3 id="1、查看当前连接（会话）的索引情况"><a href="#1、查看当前连接（会话）的索引情况" class="headerlink" title="1、查看当前连接（会话）的索引情况"></a>1、查看当前连接（会话）的索引情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#39;Handler_read%&#39;; </span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309221124.png" alt="image-20210309221124262"></p><h3 id="2、查看全局索引使用情况"><a href="#2、查看全局索引使用情况" class="headerlink" title="2、查看全局索引使用情况"></a>2、查看全局索引使用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status like &#39;Handler_read%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309221157.png" alt="image-20210309221157356"></p><h3 id="3、属性说明"><a href="#3、属性说明" class="headerlink" title="3、属性说明"></a>3、属性说明</h3><ul><li><p>Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低<br>越好）。</p></li><li><p>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的<br>性能改善不高，因为索引不经常使用（这个值越高越好）。</p></li><li><p>Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，<br>该值增加。</p></li><li><p>Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC。</p></li><li><p>Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应<br>该建立索引来补救。</p></li><li><p>Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</p></li></ul><h2 id="4-4、综合案例"><a href="#4-4、综合案例" class="headerlink" title="4.4、综合案例"></a>4.4、综合案例</h2><h3 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">create table test03</span><br><span class="line">(</span><br><span class="line">    id int primary key not null auto_increment,</span><br><span class="line">    c1 char(10),</span><br><span class="line">    c2 char(10),</span><br><span class="line">    c3 char(10),</span><br><span class="line">    c4 char(10),</span><br><span class="line">    c5 char(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into test03(c1, c2, c3, c4, c5)</span><br><span class="line">values (&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;, &#39;a4&#39;, &#39;a5&#39;);</span><br><span class="line">insert into test03(c1, c2, c3, c4, c5)</span><br><span class="line">values (&#39;b1&#39;, &#39;b2&#39;, &#39;b3&#39;, &#39;b4&#39;, &#39;b5&#39;);</span><br><span class="line">insert into test03(c1, c2, c3, c4, c5)</span><br><span class="line">values (&#39;c1&#39;, &#39;c2&#39;, &#39;c3&#39;, &#39;c4&#39;, &#39;c5&#39;);</span><br><span class="line">insert into test03(c1, c2, c3, c4, c5)</span><br><span class="line">values (&#39;d1&#39;, &#39;d2&#39;, &#39;d3&#39;, &#39;d4&#39;, &#39;d5&#39;);</span><br><span class="line">insert into test03(c1, c2, c3, c4, c5)</span><br><span class="line">values (&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;, &#39;e4&#39;, &#39;e5&#39;);</span><br><span class="line"></span><br><span class="line">create index idx_test03_c1234 on test03(c1,c2,c3,c4);</span><br></pre></td></tr></table></figure><h3 id="2、案例1"><a href="#2、案例1" class="headerlink" title="2、案例1"></a>2、案例1</h3><blockquote><p>分析以下案例的索引使用情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c4&#x3D;&#39;a4&#39; and c3&#x3D;&#39;a3&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313152742.png" alt="image-20210313152742780"></p><blockquote><p><strong>优化器会自动优化顺序</strong></p></blockquote><h3 id="3、案例2"><a href="#3、案例2" class="headerlink" title="3、案例2"></a>3、案例2</h3><blockquote><p>分析以下案例的索引使用情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c4&gt;&#39;a4&#39; and c3&#x3D;&#39;a3&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>这里仍然用到了4个索引，因为MySQL优化器会优化顺序，将其变为a1,a2,a3,a4，虽然范围比较后的列不使用索引，但范围索引的列是使用索引的，所以使用了4个索引。</p><p>可以看到，此处的<code>key_len</code>与上面一致，都是164，所以使用了4个索引</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313153801.png" alt="image-20210313153801605"></p><h3 id="4、案例3"><a href="#4、案例3" class="headerlink" title="4、案例3"></a>4、案例3</h3><blockquote><p>分析以下案例的索引使用情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c4&#x3D;&#39;a4&#39; order by c3;</span><br></pre></td></tr></table></figure><blockquote><p><strong>这里其实也使用了c3这个索引，只不过c3作用在排序而不是查找，所以没有统计进key中。</strong></p><p>没有使用C4索引</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313154442.png" alt="image-20210313154442619"></p><h3 id="5、案例4"><a href="#5、案例4" class="headerlink" title="5、案例4"></a>5、案例4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; order by c4;</span><br></pre></td></tr></table></figure><blockquote><p>使用了索引，但出现了 <code>filesort</code>，因为此时没有c3，c4索引无法使用了。</p></blockquote><h3 id="6、案例5"><a href="#6、案例5" class="headerlink" title="6、案例5"></a>6、案例5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from test03 where c1&#x3D;&#39;a1&#39; and c4 &#x3D; &#39;a4&#39; order by c3,c2;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了c1索引，但由于c3，c2顺序没有按建索引时的顺序排序，所以c3，c2所以失效，出现了 <code>filesort</code></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313155329.png" alt="image-20210313155329368"></p><h3 id="7、案例6"><a href="#7、案例6" class="headerlink" title="7、案例6"></a>7、案例6</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from test03 where c1=<span class="string">&#x27;a1&#x27;</span> and c2 = <span class="string">&#x27;a2&#x27;</span> and c5 = <span class="string">&#x27;a5&#x27;</span> order by c3,c2;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了c1，c2索引进行排序，由于c2已经有值了（已经是一个常量了），所以此时c3依然生效，此时c3索引用于排序</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313155621.png" alt="image-20210313155621217"></p><h2 id="4-5、聚簇索引"><a href="#4-5、聚簇索引" class="headerlink" title="4.5、聚簇索引"></a>4.5、聚簇索引</h2><blockquote><p>这两者都是使用 B+ 树这种索引结构</p></blockquote><h3 id="1、聚簇索引"><a href="#1、聚簇索引" class="headerlink" title="1、聚簇索引"></a>1、聚簇索引</h3><blockquote><p>将数据和索引放在一起，而且是按照一定顺序组织的，找到索引就等于找到了数据。聚簇索引中，数据的物理存放顺序和索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。</p></blockquote><h3 id="2、非聚簇索引"><a href="#2、非聚簇索引" class="headerlink" title="2、非聚簇索引"></a>2、非聚簇索引</h3><blockquote><p>叶子节点不存放数据，而是存放数据地址，这意味着在找到数据索引后还需要根据索引上的地址再去磁盘上取数据，类似书的目录。</p></blockquote><h3 id="3、优势"><a href="#3、优势" class="headerlink" title="3、优势"></a>3、优势</h3><ul><li>查询通过聚簇索引可以直接获取数据，因为聚簇索引的数据与索引存放在一起，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率更高</li><li>聚簇索引对于范围查找的效率很高，因为其数据是按大小排序的</li><li>聚簇索引适合用在排序的场合，而非聚簇索引不适合</li></ul><h3 id="4、劣势"><a href="#4、劣势" class="headerlink" title="4、劣势"></a>4、劣势</h3><ul><li>维护索引很昂贵，尤其是插入新行或者主键被更新导致要分页的时候。建议在大量插入数据后，选择负载降低的时间段通过 <code>OPTIMIZE TABLE</code> 优化表。</li><li>如果表使用 UUID（随机ID） 作为主键，使数据存储稀疏，这就会出现聚簇索引可能比全表扫描更慢，所以建议使用自增主键或者雪花算法生成的唯一ID作为主键</li><li>如果主键比较大的话，那么辅助索引将会变得更大，因为辅助索引的叶子节点存储的是主键值，过长的主键会导致叶子节点占用更多空间。</li></ul><h3 id="5、补充"><a href="#5、补充" class="headerlink" title="5、补充"></a>5、补充</h3><ul><li><code>InnoB</code>中一定有主键,主键一定是聚族索引，不手动设置、则会使用 unique素引,没有 unique素引,则会使用数据库内部的一个行的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引,辅助索引访问数据总是需要二次查找,非聚簇索引都是铺助索引,像复合索引、前缀索引、唯一索引,辅助索引叶子节点存储的不再是行的物理位置,而是主键值。</li><li><code>MyISAM</code>使用的是非聚簇索引,没有聚簇索引,非聚簇索引的两棵B+树看上去没什么不同,节点的结构完全一致只是存储的内容不同而已,主键索引B+树的节点存储了主键,辅助键索引B+树存储了辅助键。表数据存储在独立的地方,这两颗B+树的叶子节点都使用一个地址指向真正的表数据,对于表数据来说,这两个键没有任何差别。由于索引树是独立的,通过辅助键检索无需访问主键的索引树。</li></ul><h1 id="五、SQL优化（二）"><a href="#五、SQL优化（二）" class="headerlink" title="五、SQL优化（二）"></a>五、SQL优化（二）</h1><h2 id="5-1、大批量插入数据"><a href="#5-1、大批量插入数据" class="headerlink" title="5.1、大批量插入数据"></a>5.1、大批量插入数据</h2><h3 id="1、环境准备-1"><a href="#1、环境准备-1" class="headerlink" title="1、环境准备"></a>1、环境准备</h3><blockquote><p>创建两张表，两张表结构相同，名字不同；</p><p><code>tb_user_1</code>和<code>tb_user_2</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tb_user_2&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;id&#96;          int(11)     NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;username&#96;    varchar(45) NOT NULL,</span><br><span class="line">    &#96;password&#96;    varchar(96) NOT NULL,</span><br><span class="line">    &#96;name&#96;        varchar(45) NOT NULL,</span><br><span class="line">    &#96;birthday&#96;    datetime    DEFAULT NULL,</span><br><span class="line">    &#96;sex&#96;         char(1)     DEFAULT NULL,</span><br><span class="line">    &#96;email&#96;       varchar(45) DEFAULT NULL,</span><br><span class="line">    &#96;phone&#96;       varchar(45) DEFAULT NULL,</span><br><span class="line">    &#96;qq&#96;          varchar(32) DEFAULT NULL,</span><br><span class="line">    &#96;status&#96;      varchar(32) NOT NULL COMMENT &#39;用户状态&#39;,</span><br><span class="line">    &#96;create_time&#96; datetime    NOT NULL,</span><br><span class="line">    &#96;update_time&#96; datetime    DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">    UNIQUE KEY &#96;unique_user_username&#96; (&#96;username&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure><blockquote><p>对于 <code>InnoDB</code> 类型的表，有以下几种方式可以提高导入的效率：</p></blockquote><ul><li>主键顺序插入</li><li>关闭唯一性校验</li><li>手动提交事务</li></ul><h3 id="2、InnoDB引擎表插入优化-主键顺序插入"><a href="#2、InnoDB引擎表插入优化-主键顺序插入" class="headerlink" title="2、InnoDB引擎表插入优化 - 主键顺序插入"></a>2、InnoDB引擎表插入优化 - 主键顺序插入</h3><blockquote><p>因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p><p>脚本文件介绍（大小相同） :</p></blockquote><ul><li><p>sql1.log —-&gt; 主键有序</p></li><li><p>sql2.log —-&gt; 主键无序</p></li></ul><blockquote><p>使用 <code>load data local infile 文件名 into 表名</code> 进行数据加载，查看结果</p></blockquote><ul><li>插入ID顺序排列数据：</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309223038.png" alt="image-20210309223038580"></p><ul><li>插入ID无序排列数据：</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309223954.png" alt="image-20210309223954068"></p><h3 id="2、InnoDB引擎表插入优化-关闭唯一性校验"><a href="#2、InnoDB引擎表插入优化-关闭唯一性校验" class="headerlink" title="2、InnoDB引擎表插入优化-关闭唯一性校验"></a>2、InnoDB引擎表插入优化-关闭唯一性校验</h3><blockquote><p>在导入数据前执行 <code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验，在导入结束后执行<code>SET UNIQUE_CHECKS=1</code>，恢复唯一性校验，可以提高导入的效率。</p></blockquote><h3 id="3、InnoDB引擎表插入优化-手动提交事务"><a href="#3、InnoDB引擎表插入优化-手动提交事务" class="headerlink" title="3、InnoDB引擎表插入优化-手动提交事务"></a>3、InnoDB引擎表插入优化-手动提交事务</h3><blockquote><p>如果应用使用自动提交的方式，建议在导入前执行 <code>SET AUTOCOMMIT=0</code>，关闭自动提交，导入结束后再执行 <code>SET AUTOCOMMIT=1</code>，打开自动提交，也可以提高导入的效率。</p></blockquote><h2 id="5-2、优化insert语句"><a href="#5-2、优化insert语句" class="headerlink" title="5.2、优化insert语句"></a>5.2、优化insert语句</h2><blockquote><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p></blockquote><h3 id="1、使用多个值表的insert语句"><a href="#1、使用多个值表的insert语句" class="headerlink" title="1、使用多个值表的insert语句"></a>1、使用多个值表的insert语句</h3><blockquote><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</p></blockquote><ul><li>原始方案为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br></pre></td></tr></table></figure><ul><li>优化后的方案为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;)，(3,&#39;Jerry&#39;);</span><br></pre></td></tr></table></figure><h3 id="2、在执行大量的insert语句前使用事务的手动提交"><a href="#2、在执行大量的insert语句前使用事务的手动提交" class="headerlink" title="2、在执行大量的insert语句前使用事务的手动提交"></a>2、在执行大量的insert语句前使用事务的手动提交</h3><blockquote><p>如果数据量实在太大，建议分段提交。</p><p>每一万条数据 <code>insert</code> 一次。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h3 id="3、数据有序插入"><a href="#3、数据有序插入" class="headerlink" title="3、数据有序插入"></a>3、数据有序插入</h3><blockquote><p>按照主键顺序插入</p></blockquote><ul><li>优化前</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_test values(4,&#39;Tim&#39;);</span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line">insert into tb_test values(5,&#39;Rose&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br></pre></td></tr></table></figure><ul><li>优化后</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert	into	tb_test	values(1,&#39;Tom&#39;);</span><br><span class="line">insert	into	tb_test	values(2,&#39;Cat&#39;);</span><br><span class="line">insert	into	tb_test	values(3,&#39;Jerry&#39;);</span><br><span class="line">insert	into	tb_test	values(4,&#39;Tim&#39;);</span><br><span class="line">insert	into	tb_test	values(5,&#39;Rose&#39;);</span><br></pre></td></tr></table></figure><h2 id="5-3、优化order-by语句"><a href="#5-3、优化order-by语句" class="headerlink" title="5.3、优化order by语句"></a>5.3、优化order by语句</h2><h3 id="1、准备环境-1"><a href="#1、准备环境-1" class="headerlink" title="1、准备环境"></a>1、准备环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">use index_study;</span><br><span class="line">CREATE TABLE &#96;emp&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;id&#96;     int(11)      NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;name&#96;   varchar(100) NOT NULL,</span><br><span class="line">    &#96;age&#96;    int(3)       NOT NULL,</span><br><span class="line">    &#96;salary&#96; int(11) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8mb4;</span><br><span class="line">  </span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;1&#39;, &#39;Tom&#39;, &#39;25&#39;, &#39;2300&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;2&#39;, &#39;Jerry&#39;, &#39;30&#39;, &#39;3500&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;3&#39;, &#39;Luci&#39;, &#39;25&#39;, &#39;2800&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;4&#39;, &#39;Jay&#39;, &#39;36&#39;, &#39;3500&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;5&#39;, &#39;Tom2&#39;, &#39;21&#39;, &#39;2200&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;6&#39;, &#39;Jerry2&#39;, &#39;31&#39;, &#39;3300&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;7&#39;, &#39;Luci2&#39;, &#39;26&#39;, &#39;2700&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;8&#39;, &#39;Jay2&#39;, &#39;33&#39;, &#39;3500&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;9&#39;, &#39;Tom3&#39;, &#39;23&#39;, &#39;2400&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;10&#39;, &#39;Jerry3&#39;, &#39;32&#39;, &#39;3100&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;11&#39;, &#39;Luci3&#39;, &#39;26&#39;, &#39;2900&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;)</span><br><span class="line">values (&#39;12&#39;, &#39;Jay3&#39;, &#39;37&#39;, &#39;4500&#39;);</span><br><span class="line"></span><br><span class="line">create index idx_emp_age_salary on emp (age, salary);</span><br></pre></td></tr></table></figure><h3 id="2、MySQL支持的两种排序方式"><a href="#2、MySQL支持的两种排序方式" class="headerlink" title="2、MySQL支持的两种排序方式"></a>2、MySQL支持的两种排序方式</h3><ul><li>第一种是通过对返回数据进行排序，也就是通常说的 <code>ﬁlesort</code> 排序，所有不是通过索引直接返回排序结果的排序都叫 <code>FileSort</code> 排序。</li><li>第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 <code>using index</code>，不需要额外排序，操作效率高。</li></ul><h3 id="3、查询所有字段进行的排序"><a href="#3、查询所有字段进行的排序" class="headerlink" title="3、查询所有字段进行的排序"></a>3、查询所有字段进行的排序</h3><ul><li>查询所有字段，根据 <code>age</code> 进行升序/降序排序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp order by age;</span><br><span class="line">explain select * from emp order by age desc;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309225619.png" alt="image-20210309225619147"></p><blockquote><p>和根据 <code>salary</code> 进行排序一样，这里进行的都是文件排序 <code>filesort</code></p></blockquote><ul><li>查询所有字段，根据 <code>age</code> 和 <code>salary</code> 进行排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp order by age,salary;</span><br><span class="line">explain select * from emp order by age,salary desc;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309225748.png" alt="image-20210309225748259"></p><blockquote><p>此时仍然为 <code>filesort</code></p></blockquote><h3 id="4、查询索引字段进行的排序"><a href="#4、查询索引字段进行的排序" class="headerlink" title="4、查询索引字段进行的排序"></a>4、查询索引字段进行的排序</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210309230041.png" alt="image-20210309230041747"></p><blockquote><p>如果使用 <strong>覆盖索引</strong> ，那么就会使用索引排序。</p></blockquote><h3 id="5、查询字段中有非索引字段进行的排序"><a href="#5、查询字段中有非索引字段进行的排序" class="headerlink" title="5、查询字段中有非索引字段进行的排序"></a>5、查询字段中有非索引字段进行的排序</h3><blockquote><p>如果查询的字段中有非索引字段，例如 <code>name</code> ，那么将会使用 <code>filesort</code></p></blockquote><h3 id="6、优化目标"><a href="#6、优化目标" class="headerlink" title="6、优化目标"></a>6、优化目标</h3><blockquote><p>了解了MySQL的排序方式，优化目标就清晰了：</p></blockquote><ul><li>尽量减少额外的排序，通过索引直接返回有序数据。</li><li>where 条件和Order by 使用相同的索引，并且<strong>Order By 的顺序和索引顺序相同</strong>， 并且Order by 的字段<strong>都是升序，或者都是降序</strong>。否则肯定需要额外的操作，这样就会出现 <code>FileSort</code>。</li></ul><h3 id="7、举例"><a href="#7、举例" class="headerlink" title="7、举例"></a>7、举例</h3><blockquote><p>假设现有一复合索引 <code>idx_a_b_c</code>(a,b,c)，则以下情况可以避免<code>filesort</code></p></blockquote><ul><li><p>order by 能使用索引最左前缀</p><ul><li>order by a;</li><li>order by a,b;</li><li>order by a,b,c;</li><li>order by a desc,b desc,c desc;</li></ul></li><li><p>如果where使用索引的最左前缀定义为常量，则order by可以使用索引</p><ul><li>where a = const order by b,c;</li><li>where a = const and b = const order by c;</li><li>where a = const and b &gt; const order by c;</li></ul></li><li><p>不能使用索引进行排序的情况</p><ul><li>order by a asc,b desc,c desc</li></ul><blockquote><p>上述语句排序不一致，必须要么全为desc，要么全为asc</p></blockquote><ul><li>where g = const order by b,c</li></ul><blockquote><p>上述语句丢失a索引</p></blockquote><ul><li>where a = const order by c</li></ul><blockquote><p>上述语句丢失b索引</p></blockquote><ul><li>where a = const order by a,d</li></ul><blockquote><p>上述语句中，d不是索引的一部分</p></blockquote></li></ul><h3 id="8、FileSort的优化"><a href="#8、FileSort的优化" class="headerlink" title="8、FileSort的优化"></a>8、<code>FileSort</code>的优化</h3><blockquote><p>通过创建合适的索引，能够减少 <code>Filesort</code> 的出现，但是在某些情况下，条件限制不能让<code>Filesort</code>消失，那就需要加快 <code>Filesort</code> 的排序操作。对于 <code>Filesort</code> ， MySQL 有两种排序算法：</p></blockquote><ul><li><p>两次扫描算法 ：<strong>MySQL4.1 之前</strong>，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buﬀer 中排序，如果sort buﬀer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。</p></li><li><p>一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buﬀer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。</p></li></ul><blockquote><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。</p><p>可以适当提高 sort_buﬀer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310082831.png" alt="image-20210310082831825"></p><h2 id="5-4、优化group-by-语句"><a href="#5-4、优化group-by-语句" class="headerlink" title="5.4、优化group by 语句"></a>5.4、优化group by 语句</h2><blockquote><p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是<strong>多了排序之后的分组操作</strong>。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。</p><p>所以，在 GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p><p>如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行<strong>order by null</strong>禁止排序。如下 ：</p></blockquote><h3 id="1、删除复合索引，查看group-by是否包含排序"><a href="#1、删除复合索引，查看group-by是否包含排序" class="headerlink" title="1、删除复合索引，查看group by是否包含排序"></a>1、删除复合索引，查看group by是否包含排序</h3><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310083802.png" alt="image-20210310083801891"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select age,count(*) from emp group by age;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310084218.png" alt="image-20210310084218530"></p><h3 id="2、使用order-by-null优化group-by避免排序"><a href="#2、使用order-by-null优化group-by避免排序" class="headerlink" title="2、使用order by null优化group by避免排序"></a>2、使用order by null优化group by避免排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select age,count(*) from emp group by age order by null;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310084328.png" alt="image-20210310084328837"></p><blockquote><p>从上面的例子可以看出，第一个SQL语句需要进行”ﬁlesort”，而第二个SQL由于order by null 不需要进行</p><p>“ﬁlesort”， 而上文提过Filesort往往非常耗费时间。</p></blockquote><h3 id="3、使用索引优化Group-by"><a href="#3、使用索引优化Group-by" class="headerlink" title="3、使用索引优化Group by"></a>3、使用索引优化Group by</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index idx_emp_age_salary on emp(age,salary);</span><br><span class="line">explain select age,count(*) from emp group by age order by null;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310084808.png" alt="image-20210310084808529"></p><h2 id="5-5、优化嵌套查询（子查询）"><a href="#5-5、优化嵌套查询（子查询）" class="headerlink" title="5.5、优化嵌套查询（子查询）"></a>5.5、优化嵌套查询（子查询）</h2><blockquote><p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p><p>示例 ，查找有角色的所有的用户信息 :</p></blockquote><h3 id="1、优化前"><a href="#1、优化前" class="headerlink" title="1、优化前"></a>1、优化前</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id in (select user_id from user_role );</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310085102.png" alt="image-20210310085102274"></p><h3 id="2、优化后"><a href="#2、优化后" class="headerlink" title="2、优化后"></a>2、优化后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user u , user_role ur where u.id &#x3D; ur.user_id;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310085420.png" alt="image-20210310085420290"></p><blockquote><p>连接( Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p></blockquote><h2 id="5-6、优化OR条件"><a href="#5-6、优化OR条件" class="headerlink" title="5.6、优化OR条件"></a>5.6、优化OR条件</h2><blockquote><p>包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且<strong>不能使用到复合索引</strong>； 如果没有索引，则应该考虑增加索引。</p></blockquote><h3 id="1、获取-emp-表中的所有的索引"><a href="#1、获取-emp-表中的所有的索引" class="headerlink" title="1、获取 emp 表中的所有的索引"></a>1、获取 emp 表中的所有的索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from emp;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310085646.png" alt="image-20210310085646370"></p><h3 id="2、使用union替换or"><a href="#2、使用union替换or" class="headerlink" title="2、使用union替换or"></a>2、使用union替换or</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp where id &#x3D; &#39;1&#39; or id &#x3D; &#39;10&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310085956.png" alt="image-20210310085956123"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp where id &#x3D; &#39;1&#39; union select * from emp where id &#x3D; &#39;10&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310090132.png" alt="image-20210310090132249"></p><ul><li>我们来比较下重要指标，发现主要差别是 type 和 ref 这两项</li></ul><blockquote><p>type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p></blockquote><ul><li><p>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距</p></li><li><p>UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快这两项的差距就说明了 UNION 要优于 OR 。</p></li></ul><h2 id="5-7、优化分页查询"><a href="#5-7、优化分页查询" class="headerlink" title="5.7、优化分页查询"></a>5.7、优化分页查询</h2><blockquote><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310092303.png" alt="image-20210310092303106"></p><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310092325.png" alt="image-20210310092325129"></p><h3 id="1、优化思路一"><a href="#1、优化思路一" class="headerlink" title="1、优化思路一"></a>1、优化思路一</h3><blockquote><p><strong>在索引上完成排序分页操作</strong>，最后根据主键关联回原表查询其他所需要的列的内容</p></blockquote><ul><li>常规写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_item limit 200000,10;</span><br></pre></td></tr></table></figure><ul><li>优化后写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t.* from tb_item as t join (select id from tb_seller order by id limit 200000,10) as a on a.id &#x3D; t.id;</span><br></pre></td></tr></table></figure><ul><li>查看优化后写法的执行计划</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310092839.png" alt="image-20210310092839341"></p><h3 id="2、优化思路二"><a href="#2、优化思路二" class="headerlink" title="2、优化思路二"></a>2、优化思路二</h3><blockquote><p>该方案适用于<strong>主键自增</strong>的表，可以把Limit 查询转换成某个位置的查询 。（自增的主键还不能出现断层。）</p></blockquote><ul><li>优化后写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_item where id &gt; 200000 limit 10;</span><br></pre></td></tr></table></figure><blockquote><p>由于使用了索引，所以非常快</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310184441.png" alt="image-20210310184417566"></p><h2 id="5-8、使用SQL提示"><a href="#5-8、使用SQL提示" class="headerlink" title="5.8、使用SQL提示"></a>5.8、使用SQL提示</h2><blockquote><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p></blockquote><h3 id="1、USE-INDEX"><a href="#1、USE-INDEX" class="headerlink" title="1、USE INDEX"></a>1、USE INDEX</h3><blockquote><p>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</p></blockquote><ul><li>查看表中的索引</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310185045.png" alt="image-20210310185045284"></p><blockquote><p>假设现在有如下SQL</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_seller where name &#x3D; &#39;小米科技&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>那么可能会使用两个索引，即 <code>idx_seller_name</code> 和 <code>idx_seller_name_sta_adds</code></p></blockquote><ul><li>查看上述SQL的执行计划，发现其使用了 <code>idx_seller_name</code>索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name &#x3D; &#39;小米科技&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310185703.png" alt="image-20210310185702745"></p><ul><li>使用 use index 人为干预</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller use index(idx_seller_name_sta_adds) where name &#x3D; &#39;小米科技&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310185814.png" alt="image-20210310185814793"></p><h3 id="2、IGNORE-INDEX"><a href="#2、IGNORE-INDEX" class="headerlink" title="2、IGNORE INDEX"></a>2、IGNORE INDEX</h3><blockquote><p>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 提示</p></blockquote><ul><li>从上面可知，如果不加以干预，Mysql使用的是 <code>idx_seller_name</code> 索引，我们可以使用 <code>IGNORE INDEX</code> 让MySQL忽略 <code>idx_seller_name</code> 索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller ignore index(idx_seller_name) where name &#x3D; &#39;小米科技&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310190055.png" alt="image-20210310190055316"></p><h3 id="3、FORCE-INDEX"><a href="#3、FORCE-INDEX" class="headerlink" title="3、FORCE INDEX"></a>3、FORCE INDEX</h3><blockquote><p>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为提示 。</p></blockquote><ul><li>为 <code>address</code> 属性添加一个单列索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_address on tb_seller(address);</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310191208.png" alt="image-20210310191208771"></p><ul><li>在 <code>tb_seller</code> 表中执行以下语句，MySQL不会使用索引</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310190830.png" alt="image-20210310190830900"></p><blockquote><p>这是因为表中 <code>address</code> 属性为北京市的数据占绝大多数，使用索引不如全表扫描</p></blockquote><ul><li>这里我们可以使用 <code>force index</code> 强制MySQL使用索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller force index(idx_address)  where address &#x3D; &#39;北京市&#39;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210310191304.png" alt="image-20210310191304530"></p><h3 id="4、force-和-use的区别"><a href="#4、force-和-use的区别" class="headerlink" title="4、force 和 use的区别"></a>4、force 和 use的区别</h3><blockquote><p>use index 更多的是建议，而force index是强制使用索引。</p><p>如果MySQL觉得你使用 <code>use index</code> 建议的索引效率比全表扫描慢，那么仍然不会走索引。</p><p>如果你使用 <code>force index</code> 强制MySQL使用你给的索引，那么即使你给的索引执行效率低，那么MySQL也会使用你给的索引。</p></blockquote><h2 id="5-9、分解关联查询"><a href="#5-9、分解关联查询" class="headerlink" title="5.9、分解关联查询"></a>5.9、分解关联查询</h2><blockquote><p>许多高性能的应用都会对关联查询进行分解。</p><p>即可以对每一个表进行一次 <strong>单表查询</strong> ，然后将结果在应用程序中进行关联。</p><p>例如，下面这个查询中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">  *</span><br><span class="line">from</span><br><span class="line">  tag as t</span><br><span class="line">  join tag_post as tp on tp.tag_id &#x3D; t.id</span><br><span class="line">  join post as p on p.id &#x3D; tp.post_id</span><br><span class="line">where</span><br><span class="line">  t.tag &#x3D; &#39;mysql&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>可以分解为下列这些查询来代替</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from tag where tag &#x3D; &#39;mysql&#39;;</span><br><span class="line">select * from tag_post where tag_id &#x3D; 1234;</span><br><span class="line">select * from post where post.id in (123,456,678,9097);</span><br></pre></td></tr></table></figure><blockquote><p>这样做地原因？</p></blockquote><ul><li>让缓存的效率更高。</li></ul><blockquote><p>许多应用程序可以方便地缓存单表查询对应的结果对象。</p><p>例如，上面查询中的 <code>tag</code> 已经被缓存了，那么应用就可以跳过第一个对象。</p><p>再例如，应用中已经缓存了 <code>post.id</code> 为 123、456 的内容，那么第三个查询的 <code>in</code> 就可以少几个 <code>ID</code>.</p><p>另外，对于MySQL的查询缓存来说，如果关联的中的每个表发生了变化，那么就无法是哟查询缓存了，而拆分后，如果某个表很少改变，那么基于此表的查询就可以重复利用查询缓存。</p></blockquote><ul><li>将查询分解后，执行单个查询可以减少锁的竞争。</li><li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可拓展。</li><li>查询本身效率可能有所提升</li></ul><blockquote><p>这个例子中，使用 <code>in</code> 代替 关联查询，可以让MySQL按照 <code>ID</code> 顺序进行查询，这比随机的关联要更高效。</p></blockquote><ul><li>可以减少冗余记录的查询。</li></ul><blockquote><p>在应用层做关联查询,意味着对于某条记录应用只需要查询一次,而在数据库中做关联查询,则可能需要重复地访问一部分数据。从这点看,这样的重构还可能会减少网络和内存的消耗。</p></blockquote><h1 id="六、补充-尚硅谷索引优化"><a href="#六、补充-尚硅谷索引优化" class="headerlink" title="六、补充-尚硅谷索引优化"></a>六、补充-尚硅谷索引优化</h1><h2 id="6-1、索引单表查询优化案例"><a href="#6-1、索引单表查询优化案例" class="headerlink" title="6.1、索引单表查询优化案例"></a>6.1、索引单表查询优化案例</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;article&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;id&#96;          INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    &#96;author_id&#96;   INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    &#96;category_id&#96; INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    &#96;views&#96;       INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    &#96;comments&#96;    INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    &#96;title&#96;       VARBINARY(255)   NOT NULL,</span><br><span class="line">    &#96;content&#96;     TEXT             NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;article&#96;</span><br><span class="line">    (&#96;author_id&#96;, &#96;category_id&#96;, &#96;views&#96;, &#96;comments&#96;, &#96;title&#96;, &#96;content&#96;)</span><br><span class="line">VALUES</span><br><span class="line">       (1, 1, 1, 1, &#39;1&#39;, &#39;1&#39;),</span><br><span class="line">       (2, 2, 2, 2, &#39;2&#39;, &#39;2&#39;),</span><br><span class="line">       (1, 1, 3, 3, &#39;3&#39;, &#39;3&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM article;</span><br></pre></td></tr></table></figure><h3 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h3><blockquote><p>查询 category_id 为1 且 comments 大于 1 的情况下, views 最多的 <code>article_id</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,</span><br><span class="line">		author_id</span><br><span class="line">FROM article</span><br><span class="line">WHERE category_id &#x3D; 1</span><br><span class="line">		AND comments &gt; 1</span><br><span class="line">ORDER BY  views DESC LIMIT 1;</span><br></pre></td></tr></table></figure><blockquote><p>使用explain 分析以上<code>sql</code>的执行计划，发现<code>type</code>为 ALL，即最坏的情况，<code>Extra</code>中还出现了 <code>Using FileSort</code> 的情况，这个时候必须进行优化。</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313125325.png" alt="image-20210313125318090"></p><blockquote><p>开始优化</p></blockquote><ul><li>为 <code>category_id</code>、<code>comments</code>和<code>views</code>新建一个复合索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &#96;article&#96; add index idx_cate_comm_views (&#96;category_id&#96;,&#96;comments&#96;,&#96;views&#96;);</span><br></pre></td></tr></table></figure><ul><li>再次使用 explain 分析上面的<code>sql</code>，发现使用了索引，但 <code>using filesort</code> 依然存在</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313130956.png" alt="image-20210313130955997"></p><blockquote><p>由于 范围比较 后的列索引会失效，所以 <code>sql</code> 的执行计划中出现了 文件排序，我们需要删除上面这个不怎么合适的索引，重新再建一个。</p></blockquote><ul><li>删除上面的索引。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index idx_cate_comm_views on &#96;article&#96;;</span><br></pre></td></tr></table></figure><ul><li>绕过 <code>comments</code> 字段，为 <code>category_id</code> 和 <code>views</code> 字段建一个复合索引。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &#96;article&#96; add index &#96;idx_article_cate_views&#96;(&#96;category_id&#96;,&#96;views&#96;);</span><br></pre></td></tr></table></figure><ul><li>再次运行SQL语句，查看执行计划</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT id,author_id FROM article WHERE category_id &#x3D; 1 AND comments &gt; 1 ORDER BY  views DESC LIMIT 1;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313134241.png" alt="image-20210313134241862"></p><h2 id="6-2、索引关联查询优化案例"><a href="#6-2、索引关联查询优化案例" class="headerlink" title="6.2、索引关联查询优化案例"></a>6.2、索引关联查询优化案例</h2><h3 id="1、环境准备-2"><a href="#1、环境准备-2" class="headerlink" title="1、环境准备"></a>1、环境准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;class&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;id&#96;   INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;card&#96; INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS &#96;book&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;bookid&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;card&#96;   INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;bookid&#96;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br></pre></td></tr></table></figure><h3 id="2、两表案例"><a href="#2、两表案例" class="headerlink" title="2、两表案例"></a>2、两表案例</h3><blockquote><p>下面开始explain分析</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card &#x3D; book.card;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313134918.png" alt="image-20210313134918533"></p><ul><li>给book表的card字段创建一个索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table book add index &#96;idx_book_card&#96; (&#96;card&#96;);</span><br></pre></td></tr></table></figure><ul><li>此时再次进行explain分析</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313135304.png" alt="image-20210313135304463"></p><blockquote><p>左连接在右表中创建索引</p></blockquote><ul><li>删除原有的book表中的索引，为class表的card字段创建一个索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop index &#96;idx_book_card&#96; on book;</span><br><span class="line">alter table class add index &#96;idx_book_card&#96; (&#96;card&#96;);</span><br></pre></td></tr></table></figure><ul><li>再次进行explain分析</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313140207.png" alt="image-20210313140206959"></p><blockquote><p>可以看到，此时的type为index，index的效率比ref低。</p><p>左连接以左表作为主表，左边数据是一定都有的，<strong>左连接从右表中选择数据添加到左表中</strong>，右边是我们的关键点，所以必须对右表建索引。</p><p>右连接同理需要对左表的字段建索引。</p></blockquote><h3 id="3、三表案例"><a href="#3、三表案例" class="headerlink" title="3、三表案例"></a>3、三表案例</h3><blockquote><p>添加新表，插入数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;phone&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;phoneid&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;card&#96;   INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;phoneid&#96;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO phone(card)</span><br><span class="line">VALUES (FLOOR(1 + (RAND() * 20)));</span><br></pre></td></tr></table></figure><ul><li>先删去上面为class创建的索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index &#96;idx_book_card&#96; on class;</span><br></pre></td></tr></table></figure><ul><li>编写三表查询SQL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM class</span><br><span class="line">LEFT JOIN book</span><br><span class="line">	ON class.card &#x3D; book.card</span><br><span class="line">LEFT JOIN phone</span><br><span class="line">	ON book.card &#x3D; phone.card;</span><br></pre></td></tr></table></figure><ul><li>使用explain分析执行计划</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313143428.png" alt="image-20210313143427954"></p><ul><li>给 <code>phone</code> 表和 <code>book</code> 表各自建一个索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table &#96;phone&#96; add index &#96;idx_phone_card&#96;(&#96;card&#96;);</span><br><span class="line">alter table &#96;book&#96; add index &#96;idx_book_card&#96;(&#96;card&#96;);</span><br></pre></td></tr></table></figure><ul><li>再次使用explain分析执行计划</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210313143737.png" alt="image-20210313143737877"></p><h3 id="4、结论"><a href="#4、结论" class="headerlink" title="4、结论"></a>4、结论</h3><ul><li>永远用小表（结果集）驱动大表（结果集）</li></ul><blockquote><p>先了解在join连接时，哪个表是驱动表，哪个是被驱动表</p><ol><li>当使用left join时，左表是驱动表，右表是被驱动表</li><li>当使用right join时，右表时驱动表，左表是驱动表</li><li>当使用join时，<code>mysql</code>会选择数据量比较小的表作为驱动表，大表作为被驱动表</li></ol></blockquote><ul><li>子查询尽量不要放在被驱动表，有可能使用不到索引。</li></ul><blockquote><p>join查询在有索引条件下</p><ol><li><p>驱动表有索引不会使用到索引</p></li><li><p>被驱动表建立索引会使用到索引</p></li></ol><p>在以小表驱动大表的情况下，再给大表建立索引会大大提高执行速度</p></blockquote><ul><li>在无法保证被驱动表的Join条件字段被索引且内存资源充足的情况下，不要太吝惜<code>JoinButter</code> 的设置</li></ul></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>MySQL高级学习（二）-MySQL体系结构、SQL优化、索引使用</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://sutianxin.top/posts/996934066.html">https://sutianxin.top/posts/996934066.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:120px"><h>作者</h><div class="post-copyright-cc-info"><h>天昕</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-03-09</h></div></div><div class="post-copyright-u" style="display:inline-block;width:120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-03-29</h></div></div><div class="post-copyright-c" style="display:inline-block;width:120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%98%95Java/">☕Java</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sutianxin/photo/raw/master/20210309230829.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2442351397.html"><img class="prev-cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311212615.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL高级学习（三）-MySQL锁问题、常用技巧和内存优化</div></div></a></div><div class="next-post pull-right"><a href="/posts/1389856525.html"><img class="next-cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210307165930.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL高级学习（一）-初识索引、复习视图、存储过程和函数以及触发器的学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/3341669189.html" title="JUC学习笔记（四）-分支合并框架、CAS和volatile"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210303225700.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-03</div><div class="title">JUC学习笔记（四）-分支合并框架、CAS和volatile</div></div></a></div><div><a href="/posts/3754089101.html" title="Java基础（一）-Lambda表达式学习"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210223014035.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-23</div><div class="title">Java基础（一）-Lambda表达式学习</div></div></a></div><div><a href="/posts/1128227004.html" title="Java应用学习（七）-回顾Mybatis和Spring MVC"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210327222519.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">Java应用学习（七）-回顾Mybatis和Spring MVC</div></div></a></div><div><a href="/posts/2938255980.html" title="Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/my-hexo-blog-photo/raw/master/20210208120213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-12</div><div class="title">Java应用学习（二）-Springboot整合swagger/swagger-Bootstrap-UI使用</div></div></a></div><div><a href="/posts/3229832632.html" title="Java面试总结（三）"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210329223720.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-29</div><div class="title">Java面试总结（三）</div></div></a></div><div><a href="/posts/3000794297.html" title="Java面试总结（二）-hashCode()和equals()详解"><img class="cover" data-lazy-src="https://gitee.com/sutianxin/photo/raw/master/20210311232028.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-11</div><div class="title">Java面试总结（二）-hashCode()和equals()详解</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81MySQL%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-text">一、MySQL的体系结构概览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="toc-text">1.1、连接层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="toc-text">1.2、服务层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81%E5%BC%95%E6%93%8E%E5%B1%82"><span class="toc-text">1.3、引擎层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E3%80%81%E5%AD%98%E5%82%A8%E5%B1%82"><span class="toc-text">1.4、存储层</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">二、存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1、存储引擎概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">1、查看当前数据库支持的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">2、查看默认的存储引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%89%B9%E6%80%A7"><span class="toc-text">2.2、各种存储引擎特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8B-%E4%BF%AE%E6%94%B9MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">1、查看&#x2F;修改MySQL事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81InnoDB"><span class="toc-text">2、InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-text">3、InnoDB的事务控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81InnoDB%E6%94%AF%E6%8C%81%E5%A4%96%E9%94%AE"><span class="toc-text">4、InnoDB支持外键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81InnoDB%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">5、InnoDB的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81MyISAM"><span class="toc-text">6、MyISAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81MEMORY"><span class="toc-text">7、MEMORY</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">2.3、存储引擎的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81InnoDB"><span class="toc-text">1、InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81MyISAM"><span class="toc-text">2、MyISAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Memory"><span class="toc-text">3、Memory</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-text">三、SQL优化（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E6%9F%A5%E7%9C%8BSQL%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87"><span class="toc-text">3.1、查看SQL执行频率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9F%A5%E8%AF%A2%E5%BD%93%E5%89%8D%E4%BC%9A%E8%AF%9D%E4%B8%AD%E6%89%80%E6%9C%89%E7%BB%9F%E8%AE%A1%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-text">1、查询当前会话中所有统计参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9F%A5%E8%AF%A2%E5%85%A8%E5%B1%80%E7%BB%9F%E8%AE%A1%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-text">2、查询全局统计参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9F%A5%E8%AF%A2InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0%E9%87%8F"><span class="toc-text">3、查询InnoDB存储引擎的操作数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-text">4、参数说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E5%AE%9A%E4%BD%8D%E4%BD%8E%E6%95%88%E7%8E%87%E6%89%A7%E8%A1%8CSQL"><span class="toc-text">3.2、定位低效率执行SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8show-processlist-%E6%8C%87%E4%BB%A4%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-text">1、使用show processlist 指令连接和执行操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8show-processlist%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E6%85%A2%E6%9F%A5%E8%AF%A2sql"><span class="toc-text">2、使用show processlist实时监控慢查询sql</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81Explain%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-text">3.3、Explain分析执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8-explain-%E6%9F%A5%E8%AF%A2SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-text">1、使用 explain 查询SQL语句的执行计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">2、环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81explain-%E4%B9%8B-id"><span class="toc-text">3、explain 之 id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81explain-%E4%B9%8B-select-type"><span class="toc-text">4、explain 之 select_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81explain-%E4%B9%8B-table"><span class="toc-text">5、explain 之 table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81explain-%E4%B9%8B-type"><span class="toc-text">6、explain 之 type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81explain-%E4%B9%8B-key"><span class="toc-text">7、explain 之 key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81explain-%E4%B9%8B-rows"><span class="toc-text">8、explain 之 rows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81explain-%E4%B9%8B-extra"><span class="toc-text">9、explain 之 extra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81explain%E4%B9%8Bcase"><span class="toc-text">10、explain之case</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81show-profile%E5%88%86%E6%9E%90SQL"><span class="toc-text">3.4、show profile分析SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8DMySQL%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81profile"><span class="toc-text">1、查看当前MySQL是否支持profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8-show-profiles-%E6%8C%87%E4%BB%A4%E6%9F%A5%E7%9C%8Bsql%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%80%97%E6%97%B6"><span class="toc-text">2、使用 show profiles 指令查看sql语句和耗时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E3%80%81trace%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-text">3.5、trace分析优化器执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%89%93%E5%BC%80trace-%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-text">1、打开trace 并设置格式和内存大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%89%A7%E8%A1%8CSQL%E8%AF%AD%E5%8F%A5"><span class="toc-text">2、执行SQL语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9F%A5%E7%9C%8BMysql%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%8A%E8%BF%B0%E7%9A%84SQL%E8%AF%AD%E5%8F%A5"><span class="toc-text">3、查看Mysql如何执行上述的SQL语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">四、索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E9%AA%8C%E8%AF%81%E7%B4%A2%E5%BC%95%E6%8F%90%E5%8D%87%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87"><span class="toc-text">4.1、验证索引提升查询效率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A0%B9%E6%8D%AEID%E6%9F%A5%E8%AF%A2"><span class="toc-text">1、根据ID查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A0%B9%E6%8D%AEtitle%E8%BF%9B%E8%A1%8C%E7%B2%BE%E7%A1%AE%E6%9F%A5%E8%AF%A2"><span class="toc-text">2、根据title进行精确查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%EF%BC%8C%E4%B8%BAtitle%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-text">3、优化查询，为title添加索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2、索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83"><span class="toc-text">1、准备环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E2%80%93%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-text">2、避免索引失效–全值匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E2%80%93%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-text">3、避免索引失效–最左前缀法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E2%80%93%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%88%97%EF%BC%8C%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">3、避免索引失效–范围查询右边的列，不能使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E2%80%93%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="toc-text">4、避免索引失效–不要在索引列上进行运算操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E2%80%93%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BF%85%E9%A1%BB%E5%8A%A0%E5%8D%95%E5%BC%95%E5%8F%B7"><span class="toc-text">5、避免索引失效–字符串必须加单引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%8C%E9%81%BF%E5%85%8Dselect"><span class="toc-text">6、尽量使用覆盖索引，避免select *</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81or%E5%88%86%E9%9A%94%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">7、or分隔的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E4%BB%A5-%E5%BC%80%E5%A4%B4%E7%9A%84Like%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E3%80%82"><span class="toc-text">8、以%开头的Like模糊查询，索引失效。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%A6%82%E6%9E%9CMySQL%E8%AF%84%E4%BC%B0%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%AF%94%E5%85%A8%E8%A1%A8%E6%9B%B4%E6%85%A2%EF%BC%8C%E5%88%99%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E3%80%82"><span class="toc-text">9、如果MySQL评估使用索引比全表更慢，则不使用索引。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81is-NULL%E3%80%81is-NOT-NULL-%E6%9C%89%E6%97%B6%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E3%80%82"><span class="toc-text">10、is NULL、is NOT NULL 有时索引失效。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81In%E3%80%81not-In-%E6%9C%89%E6%97%B6-%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">11、In、not In 有时 不使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E5%92%8C%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">12、单列索引和复合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">4.3、查看索引使用情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%BF%9E%E6%8E%A5%EF%BC%88%E4%BC%9A%E8%AF%9D%EF%BC%89%E7%9A%84%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5"><span class="toc-text">1、查看当前连接（会话）的索引情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8B%E5%85%A8%E5%B1%80%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">2、查看全局索引使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E"><span class="toc-text">3、属性说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-text">4.4、综合案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">1、环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A1%88%E4%BE%8B1"><span class="toc-text">2、案例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%A1%88%E4%BE%8B2"><span class="toc-text">3、案例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A1%88%E4%BE%8B3"><span class="toc-text">4、案例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%A1%88%E4%BE%8B4"><span class="toc-text">5、案例4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%A1%88%E4%BE%8B5"><span class="toc-text">6、案例5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%A1%88%E4%BE%8B6"><span class="toc-text">7、案例6</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">4.5、聚簇索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">1、聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">2、非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E5%8A%BF"><span class="toc-text">3、优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8A%A3%E5%8A%BF"><span class="toc-text">4、劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%A1%A5%E5%85%85"><span class="toc-text">5、补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-text">五、SQL优化（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E5%A4%A7%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">5.1、大批量插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-1"><span class="toc-text">1、环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E8%A1%A8%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96-%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="toc-text">2、InnoDB引擎表插入优化 - 主键顺序插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E8%A1%A8%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96-%E5%85%B3%E9%97%AD%E5%94%AF%E4%B8%80%E6%80%A7%E6%A0%A1%E9%AA%8C"><span class="toc-text">2、InnoDB引擎表插入优化-关闭唯一性校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E8%A1%A8%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96-%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="toc-text">3、InnoDB引擎表插入优化-手动提交事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E4%BC%98%E5%8C%96insert%E8%AF%AD%E5%8F%A5"><span class="toc-text">5.2、优化insert语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%80%BC%E8%A1%A8%E7%9A%84insert%E8%AF%AD%E5%8F%A5"><span class="toc-text">1、使用多个值表的insert语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%A4%A7%E9%87%8F%E7%9A%84insert%E8%AF%AD%E5%8F%A5%E5%89%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-text">2、在执行大量的insert语句前使用事务的手动提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E6%9C%89%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="toc-text">3、数据有序插入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E4%BC%98%E5%8C%96order-by%E8%AF%AD%E5%8F%A5"><span class="toc-text">5.3、优化order by语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83-1"><span class="toc-text">1、准备环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="toc-text">2、MySQL支持的两种排序方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-text">3、查询所有字段进行的排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-text">4、查询索引字段进行的排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E4%B8%AD%E6%9C%89%E9%9D%9E%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-text">5、查询字段中有非索引字段进行的排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87"><span class="toc-text">6、优化目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">7、举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81FileSort%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">8、FileSort的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81%E4%BC%98%E5%8C%96group-by-%E8%AF%AD%E5%8F%A5"><span class="toc-text">5.4、优化group by 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%A0%E9%99%A4%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E7%9C%8Bgroup-by%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8E%92%E5%BA%8F"><span class="toc-text">1、删除复合索引，查看group by是否包含排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8order-by-null%E4%BC%98%E5%8C%96group-by%E9%81%BF%E5%85%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">2、使用order by null优化group by避免排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96Group-by"><span class="toc-text">3、使用索引优化Group by</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E3%80%81%E4%BC%98%E5%8C%96%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%89"><span class="toc-text">5.5、优化嵌套查询（子查询）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BC%98%E5%8C%96%E5%89%8D"><span class="toc-text">1、优化前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E5%8C%96%E5%90%8E"><span class="toc-text">2、优化后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6%E3%80%81%E4%BC%98%E5%8C%96OR%E6%9D%A1%E4%BB%B6"><span class="toc-text">5.6、优化OR条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%8E%B7%E5%8F%96-emp-%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-text">1、获取 emp 表中的所有的索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8union%E6%9B%BF%E6%8D%A2or"><span class="toc-text">2、使用union替换or</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7%E3%80%81%E4%BC%98%E5%8C%96%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-text">5.7、优化分页查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-text">1、优化思路一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-text">2、优化思路二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8%E3%80%81%E4%BD%BF%E7%94%A8SQL%E6%8F%90%E7%A4%BA"><span class="toc-text">5.8、使用SQL提示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81USE-INDEX"><span class="toc-text">1、USE INDEX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81IGNORE-INDEX"><span class="toc-text">2、IGNORE INDEX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81FORCE-INDEX"><span class="toc-text">3、FORCE INDEX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81force-%E5%92%8C-use%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4、force 和 use的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9%E3%80%81%E5%88%86%E8%A7%A3%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-text">5.9、分解关联查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%A1%A5%E5%85%85-%E5%B0%9A%E7%A1%85%E8%B0%B7%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-text">六、补充-尚硅谷索引优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E7%B4%A2%E5%BC%95%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="toc-text">6.1、索引单表查询优化案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">1、环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A1%88%E4%BE%8B"><span class="toc-text">2、案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E7%B4%A2%E5%BC%95%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="toc-text">6.2、索引关联查询优化案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-2"><span class="toc-text">1、环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%A4%E8%A1%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">2、两表案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%89%E8%A1%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">3、三表案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BB%93%E8%AE%BA"><span class="toc-text">4、结论</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 <i style="color:#ff6a6a;animation:announ_animation .8s linear infinite" class="fa fa-heartbeat"></i> 天昕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!<span id="runtime"></span><br></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"></a><a class="github-badge" target="_blank" href="https://gitee.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Picture-Gitee-0cedbe?style=flat&amp;logo=Gitee"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"></a></p><div id="workboard"></div><script async src="/js/runtime.js"></script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><script defer src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init({el:"#twikoo-wrap",envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai"})},e=()=>{twikoo.getCommentsCount({envId:"blogcomments-2gseqioe1aa55c8c",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then(function(o){t.innerText=o[0].count}).catch(function(o){console.error(o)})};var n;n=!0,"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})})()</script></div><div class="aplayer no-destroy" data-id="6588965546" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2398185_yegv7kt2bj.js"></script><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script src="/js/custom/runtime.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/hidescrollbar/hidescrollbar.js"></script><script>let backimg=["url(https://gitee.com/sutianxin/photo/raw/master/20210411191518.jpg)","url(https://gitee.com/sutianxin/photo/raw/master/20210411191521.jpg)","url(https://gitee.com/sutianxin/photo/raw/master/20210411191536.jpg)","url(https://gitee.com/sutianxin/photo/raw/master/20210411191533.jpg)","url(https://gitee.com/sutianxin/photo/raw/master/20210411191524.jpg)"],index=Math.ceil(Math.random()*(backimg.length-1))-1;document.getElementById("web_bg").style.backgroundImage=backimg[index]</script><script async src="//at.alicdn.com/t/font_2398185_lld84dtfbb.js"></script><script src="https://www.luckyclover.top/rain.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/shuoshuo/"]):not([href="/bb/"]):not([href="/contact/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.10/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_container"></div></div>'),GithubCalendar("https://python-github-calendar-api.vercel.app/api?sutianxin",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"sutianxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:120px}}</style></body></html>